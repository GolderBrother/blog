(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{308:function(t,a,s){t.exports=s.p+"assets/img/1.f05194f2.png"},309:function(t,a,s){t.exports=s.p+"assets/img/2.11bbb91b.png"},310:function(t,a,s){t.exports=s.p+"assets/img/3.d84941f7.png"},552:function(t,a,s){"use strict";s.r(a);var _=s(1),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"浏览器如何渲染页面？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器如何渲染页面？"}},[t._v("#")]),t._v(" 浏览器如何渲染页面？")]),t._v(" "),_("p",[t._v("讲讲浏览器渲染页面时的流程和步骤。")]),t._v(" "),_("p",[t._v("先来看一个例子，假如我们在浏览器中输入了一个网址，得到了下面的 html 文件，渲染引擎是怎样通过解析代码生成页面的呢？")]),t._v(" "),_("div",{staticClass:"language-html extra-class"},[_("pre",{pre:!0,attrs:{class:"language-html"}},[_("code",[_("span",{pre:!0,attrs:{class:"token doctype"}},[t._v("<!DOCTYPE html>")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("html")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("head")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("head")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("body")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    golderbrother\n  "),_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("body")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("html")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),_("h2",{attrs:{id:"从-html-到-dom"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#从-html-到-dom"}},[t._v("#")]),t._v(" 从 HTML 到 "),_("code",[t._v("DOM")])]),t._v(" "),_("h3",{attrs:{id:"_1-字节流解码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-字节流解码"}},[t._v("#")]),t._v(" 1. 字节流解码")]),t._v(" "),_("p",[t._v("对于上面的代码，我们看到的是它的字符形式。而浏览器通过 "),_("code",[t._v("HTTP")]),t._v(" 协议接收到的文档内容是字节数据，下图是抓包工具截获的报文截图，报文内容为左侧高亮显示的区域（为了查看方便，该工具将字节数据以十六进制方式显示）。当浏览器得到字节数据后，通过“编码嗅探算法”来确定字符编码，然后根据字符编码将字节流数据进行解码，生成截图右侧的字符数据，也就是我们编写的代码。")]),t._v(" "),_("p",[t._v("这个把字节数据解码成字符数据的过程称之为"),_("strong",[t._v("字节流解码")]),t._v("。")]),t._v(" "),_("p",[_("img",{attrs:{src:s(308),alt:"1.png"}})]),t._v(" "),_("p",[t._v("我们通过浏览器调试工具查看网络请求时，也是经过了上述操作过程，才能直观地看到字符串。")]),t._v(" "),_("h3",{attrs:{id:"_2-输入流预处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-输入流预处理"}},[t._v("#")]),t._v(" 2. 输入流预处理")]),t._v(" "),_("p",[t._v("通过上一步解码得到的字符流数据在进入解析环节之前还需要进行一些预处理操作。比如将"),_("code",[t._v("换行符")]),t._v("转换成统一的格式，最终生成规范化的"),_("strong",[t._v("字符流数据")]),t._v("，这个把"),_("strong",[t._v("字符数据进行统一格式化")]),t._v("的过程称之为"),_("strong",[t._v("输入流预处理")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"_3-令牌化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-令牌化"}},[t._v("#")]),t._v(" 3. 令牌化")]),t._v(" "),_("p",[t._v("经过前两步的数据解码和预处理，下面就要进入重要的解析步骤了。")]),t._v(" "),_("p",[t._v("解析包含两步，第一步是将字符数据转化成"),_("strong",[t._v("令牌（Token）")]),t._v(",（注：此处的 "),_("code",[t._v("token")]),t._v(" 跟我们常用的权限校验 "),_("code",[t._v("token")]),t._v(" 不一样），第二步是"),_("strong",[t._v("解析 HTML 生成 DOM 树")]),t._v("。")]),t._v(" "),_("p",[t._v("先来说说"),_("strong",[t._v("令牌化")]),t._v("，其过程是使用了一种类似"),_("code",[t._v("状态机的算法")]),t._v("，即每次接收一个或多个输入流中的字符；然后根据当前状态和这些字符来更新下一个状态，也就是说在不同的状态下接收同样的字符数据可能会产生不同的结果，比如当接收到"),_("code",[t._v("body")]),t._v("字符串时，"),_("strong",[t._v("在标签打开状态会解析成标签，在标签关闭状态则会解析成文本节点")]),t._v("。")]),t._v(" "),_("p",[t._v("这个算法的解析规则较多，在此就不一一列举了，有兴趣的同学可以通过下面这个简单的例子来理解其原理。")]),t._v(" "),_("p",[t._v("上述 html 代码的标记过程如下：")]),t._v(" "),_("ol",[_("li",[t._v("初始化为“数据状态”（Data State）；")]),t._v(" "),_("li",[t._v("匹配到字符 <，状态切换到 “标签打开状态”（Tag Open State）；")]),t._v(" "),_("li",[t._v("匹配到字符 !，状态切换至 “标签声明打开状态”（Markup Declaration Open State），后续 7 个字符可以组成字符串 DOCTYPE，跳转到 “DOCTYPE 状态”（DOCTYPE State）；")]),t._v(" "),_("li",[t._v("匹配到字符为空格，当前状态切换至 “DOCTYPE 名称之前状态”（Before DOCTYPE Name State）；")]),t._v(" "),_("li",[t._v("匹配到字符串 html，创建一个新的 DOCTYPE 标记，标记的名字为 “html” ，然后当前状态切换至 “DOCTYPE 名字状态”（DOCTYPE Name State）；")]),t._v(" "),_("li",[t._v("匹配到字符 >，跳转到 “数据状态” 并且释放当前的 DOCTYPE 标记；")]),t._v(" "),_("li",[t._v("匹配到字符 <，切换到 “标签打开状态”；")]),t._v(" "),_("li",[t._v("匹配到字符 h，创建一个新的起始标签标记，设置标记的标签名为空，当前状态切换至 “标签名称状态”（Tag Name State）；")]),t._v(" "),_("li",[t._v("从字符 h 开始解析，将解析的字符一个一个添加到创建的起始标签标记的标签名中，直到匹配到字符 >，此时当前状态切换至 “数据状态” 并释放当前标记，当前标记的标签名为 “html” 。")]),t._v(" "),_("li",[t._v("解析后续的 的方式与 一致，创建并释放对应的起始标签标记，解析完毕后，当前状态处于 “数据状态” ；")]),t._v(" "),_("li",[t._v("匹配到字符串 “标记” ，针对每一个字符，创建并释放一个对应的字符标记，解析完毕后，当前状态仍然处于 “数据状态” ；")]),t._v(" "),_("li",[t._v("匹配到字符 <，进入 “标签打开状态” ；")]),t._v(" "),_("li",[t._v("匹配到字符 /，进入 “结束标签打开状态”（End Tag Open State）；")]),t._v(" "),_("li",[t._v("匹配到字符 b，创建一个新的结束标签标记，设置标记的标签名为空，当前状态切换至“标签名称状态”（Tag Name State）；")]),t._v(" "),_("li",[t._v("重新从字符 b 开始解析，将解析的字符一个一个添加到创建的结束标签标记的标签名中，直到匹配到字符 >，此时当前状态切换至 “数据状态” 并释放当前标记，当前标记的标签名为 “body”；")]),t._v(" "),_("li",[t._v("解析的方式与上面一样；")]),t._v(" "),_("li",[t._v("所有的 html 标签和文本解析完成后，状态切换至 “数据状态” ，一旦匹配到文件结束标志符（EOF），则释放 EOF 标记。")])]),t._v(" "),_("p",[t._v("最终生成类似下面的令牌结构：")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("开始标签:html\n  开始标签:head\n  结束标签:head\n  开始标签:body\n    字符串:lagou\n  结束标签:body\n结束标签:html\n\n")])])]),_("h4",{attrs:{id:"补充-1：遇到-script-标签时的处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#补充-1：遇到-script-标签时的处理"}},[t._v("#")]),t._v(" 补充 1：遇到 script 标签时的处理")]),t._v(" "),_("p",[t._v("如果在 HTML 解析过程中遇到 "),_("code",[t._v("script")]),t._v(" 标签，则会发生一些变化。")]),t._v(" "),_("p",[t._v("如果遇到的是内联代码，也就是在 "),_("code",[t._v("script")]),t._v(" 标签中直接写代码，那么解析过程会暂停，执行权限会转给 "),_("code",[t._v("JavaScript")]),t._v(" 脚本引擎，待 "),_("code",[t._v("JavaScript")]),t._v(" 脚本执行完成之后再交由渲染引擎继续解析。有一种情况例外，那就是脚本内容中调用了改变 DOM 结构的 document.write() 函数，此时渲染引擎会回到第二步，将这些代码加入字符流，重新进行解析。")]),t._v(" "),_("p",[t._v("如果遇到的是外链脚本，那么渲染引擎会根据标签属性来执行对应的操作，可以看看前面的"),_("a",{attrs:{href:"https://golderbrother.github.io/blog/views/fe-advanced/ad1.html#script-%E6%A0%87%E7%AD%BE%EF%BC%9A%E8%B0%83%E6%95%B4%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E6%8F%90%E5%8D%87%E6%B8%B2%E6%9F%93%E9%80%9F%E5%BA%A6",target:"_blank",rel:"noopener noreferrer"}},[t._v("文章"),_("OutboundLink")],1)]),t._v(" "),_("h3",{attrs:{id:"_4-构建-dom-树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-构建-dom-树"}},[t._v("#")]),t._v(" 4. 构建 DOM 树")]),t._v(" "),_("p",[t._v("解析 HTML 的第二步是树构建。")]),t._v(" "),_("p",[t._v("浏览器在创建解析器的同时会创建一个 "),_("code",[t._v("Document")]),t._v(" 对象。在树构建阶段，"),_("code",[t._v("Document")]),t._v(" 会作为根节点被不断地修改和扩充。标记步骤产生的令牌会被送到树构建器进行处理。HTML 5 标准中定义了每类令牌对应的 DOM 元素，当树构建器接收到某个令牌时就会创建该令牌对应的 DOM 元素并将该元素插入到 DOM 树中。")]),t._v(" "),_("p",[t._v("为了纠正元素标签嵌套错位的问题和处理未关闭的元素标签，树构建器创建的新 DOM 元素还会被插入到一个"),_("strong",[t._v("开放元素栈")]),t._v("中。")]),t._v(" "),_("p",[t._v("树构建算法也可以采用"),_("strong",[t._v("状态机")]),t._v("的方式来描述，具体我们以步骤 1 的 HTML 代码为例进行举例说明。")]),t._v(" "),_("ol",[_("li",[t._v("进入初始状态 “initial” 模式；")]),t._v(" "),_("li",[t._v("树构建器接收到 DOCTYPE 令牌后，树构建器会创建一个 "),_("code",[t._v("DocumentType")]),t._v(" 节点附加到 "),_("code",[t._v("Document")]),t._v(" 节点上，``Document"),_("code",[t._v("Type")]),t._v(" 节点的 name 属性为 DOCTYPE 令牌的名称，切换到 “before html” 模式；")]),t._v(" "),_("li",[t._v("接收到令牌 html 后，树构建器创建一个 html 元素并将该元素作为 "),_("code",[t._v("Document")]),t._v(" 的子节点插入到 DOM 树中和开放元素栈中，切换为 “before head” 模式；")]),t._v(" "),_("li",[t._v("虽然没有接收到 head 令牌，但仍然会隐式地创建 head 元素并加到 DOM 树和开放元素栈中，切换到“in head”模式；")]),t._v(" "),_("li",[t._v("将开放元素栈中的 head 元素弹出，进入 “after head”模式；")]),t._v(" "),_("li",[t._v("接收到 body 令牌后，会创建一个 body 元素插入到 DOM 树中同时压入开放元素栈中，当前状态切换为 “in body” 模式；")]),t._v(" "),_("li",[t._v("接收到字符令牌，创建 Text 节点，节点值为字符内容“标记”，将 Text 节点作为 body 元素节点插入到 DOM 树中；")]),t._v(" "),_("li",[t._v("接收到结束令牌 body，将开放元素栈中的 body 元素弹出，切换至 “after body” 模式；")]),t._v(" "),_("li",[t._v("接收到结束令牌 html，将开放元素栈中的 html 元素弹出，切换至 “after after body” 模式；")]),t._v(" "),_("li",[t._v("接收到 EOF 令牌，树构建器停止构建，html 文档解析过程完成。")])]),t._v(" "),_("p",[t._v("最终生成下面的 DOM 树结构：")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("              Document\n             /        \\\nDocumentType           HTMLHtmlElement\n                      /               \\\n       HTMLHeadElement                 HTMLBodyElement\n                                              |\n                                          TextNode\n\n")])])]),_("p",[_("img",{attrs:{src:s(309),alt:"2.png"}})]),t._v(" "),_("h4",{attrs:{id:"补充-2：从-css-到-cssom"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#补充-2：从-css-到-cssom"}},[t._v("#")]),t._v(" 补充 2：从 CSS 到 "),_("code",[t._v("CSSOM")])]),t._v(" "),_("p",[t._v("渲染引擎除了解析 "),_("code",[t._v("HTML")]),t._v(" 之外，也需要解析 "),_("code",[t._v("CSS")]),t._v("。")]),t._v(" "),_("p",[_("code",[t._v("CSS")]),t._v(" 解析的过程与 "),_("code",[t._v("HTML")]),t._v(" 解析过程步骤一致，最终也会生成树状结构。")]),t._v(" "),_("p",[t._v("与 DOM 树不同的是，"),_("code",[t._v("CSSOM")]),t._v(" 树的节点具有"),_("strong",[t._v("继承")]),t._v("特性，也就是"),_("strong",[t._v("会先继承父节点样式作为当前样式，然后再进行补充或覆盖")]),t._v("。下面举例说明。")]),t._v(" "),_("div",{staticClass:"language-css extra-class"},[_("pre",{pre:!0,attrs:{class:"language-css"}},[_("code",[_("span",{pre:!0,attrs:{class:"token selector"}},[t._v("body")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-size")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 12px"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token selector"}},[t._v("p")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-weight")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" light"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token selector"}},[t._v("span")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" blue"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token selector"}},[t._v("p span")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("display")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" none"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token selector"}},[t._v("img")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("float")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" left"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),_("p",[t._v("对于上面的代码，会解析生成类似下面结构的 DOM 树：")]),t._v(" "),_("p",[_("img",{attrs:{src:s(310),alt:"3.png"}})]),t._v(" "),_("p",[t._v("需要注意的是，上图中的 "),_("code",[t._v("CSSOM")]),t._v(" 树并不完整，完整的 "),_("code",[t._v("CSSOM")]),t._v(" 树还应当包括浏览器提供的默认样式（也称为"),_("code",[t._v("User Agent 样式")]),t._v("）。")]),t._v(" "),_("h3",{attrs:{id:"从-dom-到渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#从-dom-到渲染"}},[t._v("#")]),t._v(" 从 DOM 到渲染")]),t._v(" "),_("p",[t._v("有了 "),_("code",[t._v("DOM")]),t._v(" 树和 "),_("code",[t._v("CSSOM")]),t._v(" 树之后，渲染引擎就可以开始生成页面了。")]),t._v(" "),_("h3",{attrs:{id:"_5-构建渲染树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-构建渲染树"}},[t._v("#")]),t._v(" 5. 构建渲染树")]),t._v(" "),_("p",[_("code",[t._v("DOM")]),t._v(" 树包含的结构内容与 "),_("code",[t._v("CSSOM")]),t._v(" 树包含的样式规则都是独立的，为了更方便渲染，先需要将它们"),_("strong",[t._v("合并成一棵渲染树("),_("code",[t._v("Render Tree")]),t._v(")")]),t._v("。")]),t._v(" "),_("p",[t._v("这个过程会从 "),_("code",[t._v("DOM")]),t._v(" 树的根节点开始遍历，然后在 "),_("code",[t._v("CSSOM")]),t._v(" 树上"),_("strong",[t._v("找到每个节点对应的样式")]),t._v("。")]),t._v(" "),_("p",[t._v("遍历过程中会"),_("strong",[t._v("自动忽略那些不需要渲染的节点")]),t._v("（比如脚本标记、元标记等）以及不可见的节点（比如设置了"),_("code",[t._v("display:none")]),t._v("样式），也就不会继续遍历不可见节点的子节点。同时也会将一些需要显示的伪类元素加到渲染树中。")]),t._v(" "),_("p",[t._v("所以针对不可见的节点，比如 "),_("code",[t._v("display: none")]),t._v(" 的元素会出现在 "),_("code",[t._v("DOM树")]),t._v(" 中，但不会出现在 "),_("code",[t._v("Render树")]),t._v(" 中。")]),t._v(" "),_("p",[t._v("对于上面的 "),_("code",[t._v("HTML")]),t._v(" 和 "),_("code",[t._v("CSS")]),t._v(" 代码，最终生成的渲染树就只有一个 "),_("code",[t._v("body")]),t._v(" 节点，样式为 "),_("code",[t._v("font-size:12px")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"_6-布局"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-布局"}},[t._v("#")]),t._v(" 6. 布局")]),t._v(" "),_("p",[t._v("生成了渲染树之后，就可以进入布局阶段了，布局就是"),_("strong",[t._v("计算元素的大小及位置")]),t._v("。")]),t._v(" "),_("p",[t._v("计算元素布局是一个比较复杂的操作，因为需要考虑的因素有很多，包括字体大小、换行位置等，这些因素会影响段落的大小和形状，进而影响下一个段落的位置。")]),t._v(" "),_("p",[t._v("布局完成后会输出对应的"),_("code",[t._v("盒模型")]),t._v("，它会"),_("strong",[t._v("精确地捕获每个元素的确切位置和大小，将所有相对值都转换为屏幕上的绝对像素")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"_7-绘制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-绘制"}},[t._v("#")]),t._v(" 7. 绘制")]),t._v(" "),_("p",[t._v("绘制就是"),_("strong",[t._v("将渲染树中的每个节点转换成屏幕上的实际像素")]),t._v("的过程。得到**布局树（REnder Tree）**这份"),_("code",[t._v("施工图")]),t._v("之后，渲染引擎并不能立即绘制，因为还不知道绘制顺序，如果没有弄清楚绘制顺序，那么很可能会导致页面被错误地渲染。")]),t._v(" "),_("p",[t._v("例如，对于使用 "),_("code",[t._v("z-index")]),t._v(" 属性的元素（如遮罩层）如果未按照正确的顺序绘制，则将导致渲染结果和预期不符（失去遮罩作用）。")]),t._v(" "),_("p",[t._v("所以绘制过程中的第一步就是遍历"),_("strong",[t._v("布局树（REnder Tree）")]),t._v("，生成"),_("strong",[t._v("绘制记录")]),t._v("，然后"),_("strong",[t._v("渲染引擎会根据绘制记录去绘制相应的内容")]),t._v("。")]),t._v(" "),_("p",[t._v("对于无动画效果的情况，只需要考虑空间维度，生成不同的"),_("strong",[t._v("图层")]),t._v("，然后再把这些"),_("strong",[t._v("图层进行合成")]),t._v("，最终成为我们看到的页面。当然这个绘制过程并不是静态不变的，会随着页面滚动不断合成新的图形。")]),t._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),_("p",[t._v("这篇文章主要讲解了浏览器渲染引擎生成页面的 7 个步骤，前面 4 个步骤为 "),_("code",[t._v("DOM")]),t._v(" 树的生成过程，后面 3 个步骤是利用 "),_("code",[t._v("DOM")]),t._v(" 树和 "),_("code",[t._v("CSSOM")]),t._v(" 树来渲染页面的过程。我们想要理解和记忆这些过程其实很简单，那就是以"),_("strong",[t._v("数据变化")]),t._v("为线索，具体来说数据的变化过程为：")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("字节 → 字符 → 令牌 → 树 → 页面\n")])])]),_("h2",{attrs:{id:"最后"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[t._v("#")]),t._v(" 最后")]),t._v(" "),_("p",[t._v("文中若有不准确或错误的地方，欢迎指出，有兴趣可以的关注下"),_("a",{attrs:{href:"https://github.com/GolderBrother",target:"_blank",rel:"noopener noreferrer"}},[t._v("Github"),_("OutboundLink")],1),t._v("~")])])}),[],!1,null,null,null);a.default=v.exports}}]);