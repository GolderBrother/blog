(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{361:function(v,_,e){v.exports=e.p+"assets/img/20200505095924.0a0431c9.gif"},362:function(v,_,e){v.exports=e.p+"assets/img/20200505100229.d5be0dfa.gif"},363:function(v,_,e){v.exports=e.p+"assets/img/20200505100410.6e083b97.jpg"},364:function(v,_,e){v.exports=e.p+"assets/img/20200505100523.c13ad15a.gif"},365:function(v,_,e){v.exports=e.p+"assets/img/20200505100641.6b8427b4.gif"},366:function(v,_,e){v.exports=e.p+"assets/img/20200505101028.7189da32.gif"},367:function(v,_,e){v.exports=e.p+"assets/img/20200505101355.d57bd0c4.gif"},368:function(v,_,e){v.exports=e.p+"assets/img/20200505101529.6b8697cb.gif"},369:function(v,_,e){v.exports=e.p+"assets/img/20200505101732.381df5ae.gif"},370:function(v,_,e){v.exports=e.p+"assets/img/20200505101935.486f540a.gif"},371:function(v,_,e){v.exports=e.p+"assets/img/20200505102101.686ae54f.gif"},372:function(v,_,e){v.exports=e.p+"assets/img/20200505102304.1298832b.gif"},373:function(v,_,e){v.exports=e.p+"assets/img/20200505102408.cda25104.gif"},374:function(v,_,e){v.exports=e.p+"assets/img/20200505102504.4131550e.gif"},590:function(v,_,e){"use strict";e.r(_);var t=e(1),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"相见恨晚的-git-命令动画演示，一看就懂！"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相见恨晚的-git-命令动画演示，一看就懂！"}},[v._v("#")]),v._v(" 相见恨晚的 Git 命令动画演示，一看就懂！")]),v._v(" "),t("p",[v._v("虽然 "),t("code",[v._v("Git")]),v._v(" 是一个强大的工具，但是我觉得大部分人都会同意我说的：它也可以是一个……噩梦！我一直觉得，使用 "),t("code",[v._v("Git")]),v._v(" 的时候把操作过程在脑海里视觉化会非常有用：当我执行某个命令的时候，分支之间是如何交互的？又是如何影响提交历史的？当我在"),t("code",[v._v("master")]),v._v("分支执行"),t("code",[v._v("hard reset")]),v._v("、"),t("code",[v._v("force push")]),v._v("到 "),t("code",[v._v("origin")]),v._v("、在"),t("code",[v._v(".git")]),v._v("文件夹执行"),t("code",[v._v("rimraf")]),v._v("的时候，为什么我的同事都哭了？")]),v._v(" "),t("p",[v._v("我认为创建一些最常见、最实用的命令的可视化示例是最佳使用指南！接下来介绍的这些命令，很多都有可选参数，用于改变命令的行为。文中的示例只讨论命令的默认行为，不会涉及太多的配置选项。这些命令包括 "),t("code",[v._v("merge")]),v._v("，"),t("code",[v._v("rebase")]),v._v("，"),t("code",[v._v("reset")]),v._v("， "),t("code",[v._v("revert")]),v._v("，"),t("code",[v._v("cherry-pick")]),v._v("，"),t("code",[v._v("fetch")]),v._v("，"),t("code",[v._v("pull")]),v._v("，"),t("code",[v._v("reflog")]),v._v(" 等。")]),v._v(" "),t("h2",{attrs:{id:"merge"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#merge"}},[v._v("#")]),v._v(" merge")]),v._v(" "),t("p",[v._v("多分支可以非常方便地将新的改动互相隔离，并确保你不会意外地将未经批准或破坏性的变更推到生产环境。一旦变更被批准，我们就能在生产分支中得到这些变更。")]),v._v(" "),t("p",[v._v("从一个分支获取变更到另一个分支的方式之一是执行"),t("code",[v._v("git merge")]),v._v("命令。"),t("code",[v._v("Git")]),v._v(" 有两类合并操作："),t("code",[v._v("fast-forward")]),v._v(" 和 "),t("code",[v._v("no-fast-forward")]),v._v("。")]),v._v(" "),t("p",[v._v("这么说你可能没什么概念，我们来看看区别吧。")]),v._v(" "),t("h3",{attrs:{id:"fast-forward-ff"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fast-forward-ff"}},[v._v("#")]),v._v(" fast-forward ("),t("code",[v._v("--ff")]),v._v(")")]),v._v(" "),t("p",[v._v("如果当前分支与即将合并过来的分支相比，没有额外的提交，这种就是"),t("code",[v._v("fast-forward")]),v._v("合并。"),t("code",[v._v("Git")]),v._v(" 很会偷懒，它会首先尝试最简单的方案，即"),t("code",[v._v("fast-forward")]),v._v("。这种合并方式不会创建新的提交，只是把另一个分支的提交记录直接合并到当前分支。")]),v._v(" "),t("p",[v._v("fast-forward merge\n"),t("img",{attrs:{src:e(361),alt:"20200505095924"}})]),v._v(" "),t("p",[v._v("没毛病！现在我们在"),t("code",[v._v("master")]),v._v("分支上有了"),t("code",[v._v("dev")]),v._v("分支上的所有变更。那么，"),t("code",[v._v("no-fast-forward")]),v._v(" 又是什么呢？")]),v._v(" "),t("h3",{attrs:{id:"no-fast-foward-no-ff"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#no-fast-foward-no-ff"}},[v._v("#")]),v._v(" no-fast-foward ("),t("code",[v._v("--no-ff")]),v._v(")")]),v._v(" "),t("p",[v._v("跟即将合并过来的分支比较，当前分支如果没有额外的提交，这固然很好，但实际情况往往不是这样！如果我们在当前分支上也提交了一些改动，那么 "),t("code",[v._v("Git")]),v._v(" 就会执行"),t("code",[v._v("no-fast-forward")]),v._v("合并。")]),v._v(" "),t("p",[v._v("对于 "),t("code",[v._v("no-fast-forward")]),v._v(" 合并，"),t("code",[v._v("Git")]),v._v(" 会在当前分支上创建一个新的合并提交。该提交的父提交同时指向当前分支和合并过来的分支。")]),v._v(" "),t("p",[v._v("no-fast-forward\n"),t("img",{attrs:{src:e(362),alt:"20200505100229"}})]),v._v(" "),t("p",[v._v("也没毛病！现在"),t("code",[v._v("master")]),v._v("分支上有了我们在"),t("code",[v._v("dev")]),v._v("分支上做的所有变更。")]),v._v(" "),t("h2",{attrs:{id:"合并冲突"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合并冲突"}},[v._v("#")]),v._v(" 合并冲突")]),v._v(" "),t("p",[v._v("虽然 "),t("code",[v._v("Git")]),v._v(" 擅长决定如何合并分支和更改文件，但它也不是总能自己做出决定。当我们试图合并的两个分支在同一文件的同一行上都有改动时，或者一个分支删除了文件，另一个分支又修改了它，都可能发生这种情况。")]),v._v(" "),t("p",[v._v("这种情况下，"),t("code",[v._v("Git")]),v._v(" 会要求你帮助决定要保留哪边的改动。假设在两个分支上，我们都编辑了"),t("code",[v._v("README.md")]),v._v("文件的第一行：")]),v._v(" "),t("p",[t("img",{attrs:{src:e(363),alt:"20200505100410"}})]),v._v(" "),t("p",[v._v("如果把"),t("code",[v._v("dev")]),v._v("合并到"),t("code",[v._v("master")]),v._v("，会导致合并冲突：你是要 "),t("code",[v._v("Hello!")]),v._v("呢，还是要 "),t("code",[v._v("Hey!")]),v._v("？")]),v._v(" "),t("p",[v._v("合并分支时，"),t("code",[v._v("Git")]),v._v(" 会显示冲突的位置。我们可以手动删除不想保留的改动，然后保存，再添加改动后的文件（"),t("code",[v._v("git add")]),v._v("）并提交。")]),v._v(" "),t("p",[t("img",{attrs:{src:e(364),alt:"20200505100523"}})]),v._v(" "),t("p",[v._v("大功告成！合并冲突虽然很烦人，但也是合理的：因为 "),t("code",[v._v("Git")]),v._v(" 不应该自作主张保留哪边的改动。")]),v._v(" "),t("h2",{attrs:{id:"rebase"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rebase"}},[v._v("#")]),v._v(" rebase")]),v._v(" "),t("p",[v._v("刚刚我们看到了如何通过执行"),t("code",[v._v("git merge")]),v._v("将一个分支的改动应用到另一个分支。另一种方式是使用"),t("code",[v._v("git rebase")]),v._v("。")]),v._v(" "),t("p",[t("code",[v._v("git rebase")]),v._v(" 命令会"),t("strong",[v._v("复制")]),v._v("当前分支的提交，然后把这些提交"),t("strong",[v._v("放到指定分支")]),v._v("之上。")]),v._v(" "),t("p",[v._v("git rebase\n"),t("img",{attrs:{src:e(365),alt:"20200505100641"}})]),v._v(" "),t("p",[v._v("现在"),t("code",[v._v("master")]),v._v("分支上的所有改动都跑到"),t("code",[v._v("dev")]),v._v("分支上了！")]),v._v(" "),t("p",[v._v("与"),t("code",[v._v("merge")]),v._v("相比，最大的区别是 "),t("code",[v._v("Git")]),v._v(" 不会去找出哪些文件需要保留，哪些文件不需要保留。我们要"),t("code",[v._v("rebase")]),v._v("的分支总是包含了我们想要保留的最新改动。这种方式不会有合并冲突，并且保持了良好的线性 "),t("code",[v._v("Git")]),v._v(" 历史记录。")]),v._v(" "),t("p",[v._v("这个例子演示了在 "),t("code",[v._v("master")]),v._v("分支上执行"),t("code",[v._v("rebase")]),v._v("。不过，在大项目里你可能不会这么做。"),t("code",[v._v("git rebase")]),v._v("命令会修改项目历史记录，因为复制的提交会产生新的 "),t("code",[v._v("hash")]),v._v("。")]),v._v(" "),t("p",[v._v("当你在特性分支上开发时，"),t("code",[v._v("master")]),v._v("分支有更新的时候，"),t("code",[v._v("rebase")]),v._v(" 很有用。这样你在当前分支就能拿到所有更新，避免了将来可能的合并冲突。")]),v._v(" "),t("h2",{attrs:{id:"交互式-rebase"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#交互式-rebase"}},[v._v("#")]),v._v(" 交互式 rebase")]),v._v(" "),t("p",[v._v("在 "),t("code",[v._v("rebase")]),v._v(" 之前，我们还可以修改！这是通过交互式 "),t("code",[v._v("rebase")]),v._v(" 实现的。交互式 "),t("code",[v._v("rebase")]),v._v(" 也可以用于当前正在处理的分支，在希望修改某些提交的时候。\n对于即将 "),t("code",[v._v("rebase")]),v._v(" 的提交，可以执行 6 种操作：")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("reword")]),v._v("：修改提交说明")]),v._v(" "),t("li",[t("code",[v._v("edit")]),v._v("：修改提交内容（"),t("code",[v._v("amend")]),v._v("）")]),v._v(" "),t("li",[t("code",[v._v("squash")]),v._v("：将该提交合并到前一个提交")]),v._v(" "),t("li",[t("code",[v._v("fixup")]),v._v(": 将该提交合并到前一个提交，不保留提交的日志消息")]),v._v(" "),t("li",[t("code",[v._v("exec")]),v._v(": 在想要 "),t("code",[v._v("rebase")]),v._v(" 的每一个提交上执行命令")]),v._v(" "),t("li",[t("code",[v._v("drop")]),v._v(": 删除提交")])]),v._v(" "),t("p",[v._v("666！这样，我们就能完全控制提交记录了。如果想删除某个提交，只要 "),t("code",[v._v("drop")]),v._v(" 它就行了。")]),v._v(" "),t("p",[t("img",{attrs:{src:e(366),alt:"20200505101028"}})]),v._v(" "),t("p",[v._v("或者，如果我们想要把多个提交合并到一起，这样历史记录会更清晰，也没问题！")]),v._v(" "),t("p",[v._v("交互式 "),t("code",[v._v("rebase")]),v._v(" 给了你对想要 "),t("code",[v._v("rebase")]),v._v(" 的提交很多控制权，哪怕是当前的活动分支。")]),v._v(" "),t("h2",{attrs:{id:"reset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reset"}},[v._v("#")]),v._v(" reset")]),v._v(" "),t("p",[v._v("有时候我们提交了一些改动，后来又不想要了。有可能是"),t("code",[v._v("WIP")]),v._v("提交，也可能是某个引入了 "),t("code",[v._v("bug")]),v._v(" 的提交。这种情况，我们可以执行"),t("code",[v._v("git reset")]),v._v("。")]),v._v(" "),t("p",[t("code",[v._v("git reset")]),v._v("会"),t("strong",[v._v("丢弃")]),v._v("当前"),t("strong",[v._v("所有暂存")]),v._v("的文件，并让我们决定 "),t("code",[v._v("HEAD")]),v._v(" 应该"),t("strong",[v._v("指向哪里")]),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"soft-reset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#soft-reset"}},[v._v("#")]),v._v(" soft reset")]),v._v(" "),t("p",[t("code",[v._v("soft reset")]),v._v(" 将 "),t("code",[v._v("HEAD")]),v._v(" "),t("strong",[v._v("移动")]),v._v("到指定的提交（或者相对于"),t("code",[v._v("HEAD")]),v._v(" 的位置索引），同时不会丢弃这些提交带来的改动。")]),v._v(" "),t("p",[v._v("假设我们不想保留添加了"),t("code",[v._v("style.css")]),v._v("文件的提交"),t("code",[v._v("9e78i")]),v._v("，也不想保留添加了"),t("code",[v._v("index.js")]),v._v("文件的提交"),t("code",[v._v("035cc")]),v._v(" 。但是，我们却想要保留新增的"),t("code",[v._v("style.css")]),v._v("和"),t("code",[v._v("index.js")]),v._v(" 文件。这里用 "),t("code",[v._v("soft reset")]),v._v(" 就非常合适。")]),v._v(" "),t("p",[t("img",{attrs:{src:e(367),alt:"20200505101355"}})]),v._v(" "),t("p",[v._v("执行"),t("code",[v._v("git status")]),v._v("，你会看到我们依然能够查看之前提交所做的改动。这很有用，因为这样我们就能继续修改文件内容，后续再次提交了。")]),v._v(" "),t("h2",{attrs:{id:"hard-reset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hard-reset"}},[v._v("#")]),v._v(" hard reset")]),v._v(" "),t("p",[v._v("有时候，我们不想保留某些提交带来的改动。跟 "),t("code",[v._v("soft reset")]),v._v(" 不一样，我们不再需要访问这些变动了。"),t("code",[v._v("Git")]),v._v(" 应该简单地重置到指定的提交，并且会重置工作区和暂存区的文件。")]),v._v(" "),t("p",[t("img",{attrs:{src:e(368),alt:"20200505101529"}})]),v._v(" "),t("p",[t("code",[v._v("Git")]),v._v(" 已经丢弃了 "),t("code",[v._v("9e78i")]),v._v(" 和 "),t("code",[v._v("035cc")]),v._v(" 两个提交引起的改动，并把状态"),t("em",[v._v("重置")]),v._v("到了提交"),t("code",[v._v("ec5be")]),v._v("的位置。")]),v._v(" "),t("h2",{attrs:{id:"revert"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#revert"}},[v._v("#")]),v._v(" revert")]),v._v(" "),t("p",[v._v("撤销改动的另一种方式是执行"),t("code",[v._v("git revert")]),v._v("。"),t("strong",[v._v("复原")]),v._v("某个提交后，会"),t("strong",[v._v("创建一个新的提交")]),v._v("，包含了恢复后的改动。")]),v._v(" "),t("p",[v._v("假设提交 "),t("code",[v._v("ec5be")]),v._v(" 添加了一个"),t("code",[v._v("index.js")]),v._v("文件。随后，我们发现实际上不再需要这个改动了，就可以恢复"),t("code",[v._v("ec5be")]),v._v("这个提交。")]),v._v(" "),t("p",[t("img",{attrs:{src:e(369),alt:"20200505101732"}})]),v._v(" "),t("p",[v._v("提交"),t("code",[v._v("9e78i")]),v._v("恢复了"),t("code",[v._v("ec5be")]),v._v(" 这个提交带来的改动。执行 "),t("code",[v._v("git revert")]),v._v(" 对于"),t("strong",[v._v("撤销")]),v._v("某个提交非常有用，同时又"),t("strong",[v._v("不会修改分支的历史")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"cherry-pick"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cherry-pick"}},[v._v("#")]),v._v(" cherry-pick")]),v._v(" "),t("p",[v._v("当活动分支需要"),t("strong",[v._v("某个分支的某个提交包含的改动")]),v._v("时，我们可以用"),t("code",[v._v("cherry-pick")]),v._v("命令。通过"),t("code",[v._v("cherry-pick")]),v._v("某个提交，在当前活动分支上会创建一个新提交，包含了前者带来的改动。")]),v._v(" "),t("p",[v._v("假设 "),t("code",[v._v("dev")]),v._v(" 分支上的提交"),t("code",[v._v("76d12")]),v._v("改动了"),t("code",[v._v("index.js")]),v._v("文件，我们在"),t("code",[v._v("master")]),v._v("分支上也需要。我们不需要整个分支上的改动，只要这个提交。")]),v._v(" "),t("p",[v._v("Alt Text\n"),t("img",{attrs:{src:e(370),alt:"20200505101935"}})]),v._v(" "),t("p",[v._v("666，"),t("code",[v._v("master")]),v._v("分支现在也包含了"),t("code",[v._v("76d12")]),v._v("这个提交的改动了。")]),v._v(" "),t("h2",{attrs:{id:"fetch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fetch"}},[v._v("#")]),v._v(" fetch")]),v._v(" "),t("p",[v._v("如果存在远程分支，远程分支可能有些提交是当前的本地分支没有的。有可能是其他分支合并过去了，或者你的同事推送了某些改动，等等。")]),v._v(" "),t("p",[v._v("我们可以用 "),t("code",[v._v("git fetch")]),v._v(" 把这些改动获取到本地。这不会影响本地分支，"),t("code",[v._v("fetch")]),v._v("只是"),t("strong",[v._v("下载数据")]),v._v("。")]),v._v(" "),t("p",[t("img",{attrs:{src:e(371),alt:"20200505102101"}})]),v._v(" "),t("p",[v._v("现在就可以看到从最近一次推送以来的所有变动。"),t("strong",[v._v("本地")]),v._v("有了这些新数据，我们就可以决定如何使用了。")]),v._v(" "),t("h2",{attrs:{id:"pull"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pull"}},[v._v("#")]),v._v(" pull")]),v._v(" "),t("p",[v._v("除了用"),t("code",[v._v("git fetch")]),v._v(" 获取远程分支信息外，还可以用"),t("code",[v._v("git pull")]),v._v("。"),t("code",[v._v("git pull")]),v._v("实际上是两个命令合而为一："),t("code",[v._v("git fetch")]),v._v("和"),t("code",[v._v("git merge")]),v._v("。当我们从 "),t("code",[v._v("origin")]),v._v(" 拉取改动时，先是像"),t("code",[v._v("git fetch")]),v._v("一样"),t("strong",[v._v("获取所有数据")]),v._v("，然后"),t("strong",[v._v("最新改动")]),v._v("会"),t("strong",[v._v("自动合并")]),v._v("到本地分支。")]),v._v(" "),t("p",[t("img",{attrs:{src:e(372),alt:"20200505102304"}})]),v._v(" "),t("h2",{attrs:{id:"reflog"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reflog"}},[v._v("#")]),v._v(" reflog")]),v._v(" "),t("p",[v._v("每个人都会犯错误，这完全没有关系！有时候你可能觉得自己把仓库搞得一团糟，只想把它删了完事。")]),v._v(" "),t("p",[t("code",[v._v("git reflog")]),v._v("是个非常有用的命令，可以显示所有操作的日志。包括 "),t("code",[v._v("merge")]),v._v("，"),t("code",[v._v("reset")]),v._v("，"),t("code",[v._v("revert")]),v._v(" 等，基本上包括了"),t("strong",[v._v("对分支的任何更改")]),v._v("。")]),v._v(" "),t("p",[t("img",{attrs:{src:e(373),alt:"20200505102408"}})]),v._v(" "),t("p",[v._v("如果出错了，你可以根据"),t("code",[v._v("reflog")]),v._v("提供的信息通过重置 "),t("code",[v._v("HEAD")]),v._v(" 来撤销改动。")]),v._v(" "),t("p",[v._v("比如，我们实际上并不想合并分支。当我们执行 "),t("code",[v._v("git reflog")]),v._v(" 命令时，我们看到在合并前仓库位于 "),t("code",[v._v("HEAD@{1}")]),v._v("。我们执行下"),t("code",[v._v("git reset")]),v._v("命令，让 "),t("code",[v._v("HEAD")]),v._v(" 重新指回原来的"),t("code",[v._v("HEAD@{1}")]),v._v("位置。")]),v._v(" "),t("p",[t("img",{attrs:{src:e(374),alt:"20200505102504"}})]),v._v(" "),t("p",[v._v("这里我们可以看到，最新的操作也记录到"),t("code",[v._v("reflog")]),v._v("里了！")]),v._v(" "),t("h2",{attrs:{id:"最后"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[v._v("#")]),v._v(" 最后")]),v._v(" "),t("p",[v._v("文中若有不准确或错误的地方，欢迎指出，有兴趣可以的关注下"),t("a",{attrs:{href:"https://github.com/GolderBrother",target:"_blank",rel:"noopener noreferrer"}},[v._v("Github"),t("OutboundLink")],1),v._v("~")]),v._v(" "),t("comment"),v._v(" "),t("comment")],1)}),[],!1,null,null,null);_.default=r.exports}}]);