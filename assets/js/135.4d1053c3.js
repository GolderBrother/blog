(window.webpackJsonp=window.webpackJsonp||[]).push([[135],{563:function(_,v,e){"use strict";e.r(v);var t=e(1),o=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"浏览器渲染过程是怎样的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染过程是怎样的"}},[_._v("#")]),_._v(" 浏览器渲染过程是怎样的")]),_._v(" "),e("p",[_._v("按照渲染的时间顺序，流水线可分为如下几个子阶段："),e("strong",[_._v("构建 DOM 树")]),_._v("、"),e("strong",[_._v("样式计算")]),_._v("、"),e("strong",[_._v("布局阶段")]),_._v("、"),e("strong",[_._v("分层")]),_._v("、"),e("strong",[_._v("栅格化")]),_._v("和显示。")]),_._v(" "),e("p",[_._v("渲染进程将 "),e("code",[_._v("HTML")]),_._v(" 内容转换为能够读懂 "),e("code",[_._v("DOM")]),_._v(" 树结构。\n渲染引擎将 "),e("code",[_._v("CSS")]),_._v(" 样式表转化为浏览器可以理解的 styleSheets，计算出 "),e("code",[_._v("DOM")]),_._v(" 节点的样式。\n创建布局树，并计算元素的布局信息。\n对布局树进行分层，并生成分层树。\n为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。\n合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。\n浏览器从网络或硬盘中获得"),e("code",[_._v("HTML")]),_._v("字节数据后会经过一个流程将字节解析为"),e("code",[_._v("DOM")]),_._v("树,先将"),e("code",[_._v("HTML")]),_._v("的原始字节数据转换为文件指定编码的字符,然后浏览器会根据"),e("code",[_._v("HTML")]),_._v("规范来将字符串转换成各种"),e("strong",[_._v("令牌标签")]),_._v("，如"),e("code",[_._v("html、body")]),_._v("等。最终解析成一个树状的对象模型，就是"),e("code",[_._v("dom")]),_._v("树；")]),_._v(" "),e("p",[_._v("获取"),e("code",[_._v("css")]),_._v("，获取 style 标签内的"),e("code",[_._v("css")]),_._v("、或者内嵌的"),e("code",[_._v("css")]),_._v(",或者当 HTML 代码遇见标签时，浏览器会发送请求获得该标签中标记的 CSS，当渲染引擎接收到 "),e("code",[_._v("CSS")]),_._v(" 文本时，会执行一个转换操作，将 "),e("code",[_._v("CSS")]),_._v(" 文本转换为浏览器可以理解的"),e("code",[_._v("styleSheets")])]),_._v(" "),e("p",[_._v("创建布局树，遍历 "),e("code",[_._v("DOM")]),_._v(" 树中的所有可见节点，并把这些节点加到布局中；而不可见的节点会被布局树忽略掉，如 "),e("code",[_._v("head")]),_._v(" 标签下面的全部内容，再比如 "),e("code",[_._v("body.p.span")]),_._v(" 这个元素，因为它的属性包含 "),e("code",[_._v("dispaly:none")]),_._v("，所以这个元素也没有被包进布局树。最后计算 "),e("code",[_._v("DOM")]),_._v(" 元素的布局信息，使其都保存在布局树中。布局完成过程中，如果有 js 操作或者其他操作，对元素的** "),e("strong",[_._v("等作出改变就会引起")]),_._v("重绘**，如果有对元素的"),e("strong",[_._v("大小、定位")]),_._v("等有改变则会引起**回流**。")]),_._v(" "),e("p",[_._v("因为页面中有很多复杂的效果，如一些复杂的 "),e("code",[_._v("3D")]),_._v(" 变换、页面滚动，或者使用 "),e("code",[_._v("z-index")]),_._v(" 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。")]),_._v(" "),e("p",[_._v("渲染引擎实现图层的绘制，把一个图层的绘制拆分成很多小的绘制指令然后再把这些指令按照顺序组成一个待绘制列表，当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程，合成线程会将图层划分为图块，然后按照视口附近的图块来优先生成位图(实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将"),e("strong",[_._v("图块转换为位图")]),_._v(")")]),_._v(" "),e("p",[_._v("一旦所有图块都被"),e("strong",[_._v("光栅化")]),_._v("，合成线程就会生成一个绘制图块的命令，然后将该命令提交给浏览器进程,浏览器最后进行显示。")]),_._v(" "),e("h2",{attrs:{id:"最后"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[_._v("#")]),_._v(" 最后")]),_._v(" "),e("p",[_._v("文中若有不准确或错误的地方，欢迎指出，有兴趣可以的关注下"),e("a",{attrs:{href:"https://github.com/GolderBrother",target:"_blank",rel:"noopener noreferrer"}},[_._v("Github"),e("OutboundLink")],1),_._v("，一起学习呀~~")]),_._v(" "),e("comment")],1)}),[],!1,null,null,null);v.default=o.exports}}]);