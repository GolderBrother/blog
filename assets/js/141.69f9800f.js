(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{574:function(v,_,e){"use strict";e.r(_);var t=e(1),o=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"http2-http3-协议有什么优劣"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http2-http3-协议有什么优劣"}},[v._v("#")]),v._v(" http2/http3 协议有什么优劣")]),v._v(" "),e("h2",{attrs:{id:"http2-的主要特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http2-的主要特性"}},[v._v("#")]),v._v(" HTTP2 的主要特性")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("http2.0")]),v._v("是一个二进制协议,"),e("code",[v._v("http1")]),v._v("是超文本协议.传输的内容都不是一样的。")]),v._v(" "),e("li",[e("code",[v._v("http2.0")]),v._v("遵循多路复用即,代替同一 host 下的内容,只建立一次连接. "),e("code",[v._v("http1")]),v._v("不是。")]),v._v(" "),e("li",[e("code",[v._v("http2.0")]),v._v("可以使用"),e("code",[v._v("HPACK")]),v._v("进行头部的压缩,"),e("code",[v._v("http1")]),v._v("则不论什么请求都会发送。")]),v._v(" "),e("li",[e("code",[v._v("http2.0")]),v._v("允许服务器,预先将网页所需要的资源"),e("code",[v._v("PUSH")]),v._v("到浏览器的内存当中。")])]),v._v(" "),e("h2",{attrs:{id:"http2-的多路复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http2-的多路复用"}},[v._v("#")]),v._v(" HTTP2 的多路复用")]),v._v(" "),e("ul",[e("li",[v._v("在"),e("code",[v._v("HTTP1.1")]),v._v("的协议中，我们传输的 request 和 response 都是基本于文本的，这样就会引发一个问题：所有的数据必须按顺序传输，比如需要传输："),e("code",[v._v("hello world")]),v._v("，那么只能从 h 到 d 一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在"),e("code",[v._v("HTTP1.1")]),v._v("是不能实现的。")]),v._v(" "),e("li",[v._v("在"),e("code",[v._v("HTTP2.0")]),v._v("引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。")]),v._v(" "),e("li",[v._v("在"),e("code",[v._v("HTTP2.0")]),v._v("对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一次连接。")])]),v._v(" "),e("h2",{attrs:{id:"http2-的新特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http2-的新特性"}},[v._v("#")]),v._v(" HTTP2 的新特性")]),v._v(" "),e("h3",{attrs:{id:"新的二进制格式（binary-format）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#新的二进制格式（binary-format）"}},[v._v("#")]),v._v(" 新的二进制格式（Binary Format）")]),v._v(" "),e("p",[e("code",[v._v("HTTP1.x")]),v._v("的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。")]),v._v(" "),e("h3",{attrs:{id:"多路复用-（multiplexing）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多路复用-（multiplexing）"}},[v._v("#")]),v._v(" 多路复用 （MultiPlexing）")]),v._v(" "),e("p",[v._v("即连接共享，即每一个"),e("code",[v._v("request")]),v._v("都是是用作连接共享机制的。一个"),e("code",[v._v("request")]),v._v("对应一个 id，这样一个连接上可以有多个"),e("code",[v._v("request")]),v._v("，每个连接的"),e("code",[v._v("request")]),v._v("可以随机的混杂在一起，接收方可以根据"),e("code",[v._v("request")]),v._v("的 id 将"),e("code",[v._v("request")]),v._v("再归属到各自不同的服务端请求里面。")]),v._v(" "),e("h3",{attrs:{id:"header-压缩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#header-压缩"}},[v._v("#")]),v._v(" header 压缩")]),v._v(" "),e("p",[e("code",[v._v("HTTP1.x")]),v._v("的"),e("code",[v._v("header")]),v._v("带有大量信息，而且每次都要重复发送，"),e("code",[v._v("HTTP2.0")]),v._v("使用"),e("code",[v._v("encoder")]),v._v("来减少需要传输的"),e("code",[v._v("header")]),v._v("大小，通讯双方各自"),e("code",[v._v("cache")]),v._v("一份"),e("code",[v._v("header")]),v._v(" "),e("code",[v._v("fields")]),v._v("表，既避免了重复"),e("code",[v._v("header")]),v._v("的传输，又减小了需要传输的大小。")]),v._v(" "),e("h3",{attrs:{id:"服务端推送-（server-push）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务端推送-（server-push）"}},[v._v("#")]),v._v(" 服务端推送 （server push）")]),v._v(" "),e("p",[v._v("同 SPDY 一样，"),e("code",[v._v("HTTP2.0")]),v._v("也具有 server push 功能。目前，有大多数网站已经启用"),e("code",[v._v("HTTP2.0")]),v._v("，例如 "),e("code",[v._v("YouTuBe")]),v._v("，淘宝网等网站，可以利用"),e("code",[v._v("chrome")]),v._v("控制台可以查看是否启用"),e("code",[v._v("Http2.0")])]),v._v(" "),e("h2",{attrs:{id:"spdy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spdy"}},[v._v("#")]),v._v(" SPDY")]),v._v(" "),e("p",[v._v("2012 年 google 如一声惊雷提出了"),e("code",[v._v("SPDY")]),v._v("的方案，大家才开始从正面看待和解决老版本 HTTP 协议本身的问题，"),e("code",[v._v("SPDY")]),v._v("可以说是综合了 HTTPS 和 HTTP 两者优点于一体的传输协议，主要解决：")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("降低延迟")]),v._v(" "),e("p",[v._v("针对 HTTP 高延迟的问题，"),e("code",[v._v("SPDY")]),v._v("优雅的采取了多路复用（multiplexing）。多路复用通过多个请求"),e("code",[v._v("stream")]),v._v("共享一个"),e("code",[v._v("tcp")]),v._v("连接的方式，解决了"),e("code",[v._v("HOL blocking")]),v._v("的问题，降低了延迟同时提高了带宽的利用率。")])]),v._v(" "),e("li",[e("p",[v._v("请求优先级（request prioritization）")]),v._v(" "),e("p",[v._v("多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。"),e("code",[v._v("SPDY")]),v._v("允许给每个 request 设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的 html 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。")])]),v._v(" "),e("li",[e("p",[v._v("header 压缩\n前面提到"),e("code",[v._v("HTTP1.x")]),v._v("的"),e("code",[v._v("header")]),v._v("很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。")])]),v._v(" "),e("li",[e("p",[v._v("基于"),e("code",[v._v("HTTPS")]),v._v("的加密协议传输\n这大大提高了传输数据的可靠性。")])]),v._v(" "),e("li",[e("p",[v._v("服务端推送（server push）\n采用了"),e("code",[v._v("SPDY")]),v._v("的网页，例如我的网页有一个"),e("code",[v._v("style.css")]),v._v("的请求，在客户端收到"),e("code",[v._v("style.css")]),v._v("数据的同时，服务端会将"),e("code",[v._v("style.js")]),v._v("的文件推送给客户端，当客户端再次尝试获取"),e("code",[v._v("style.js")]),v._v("时就可以直接从缓存中获取到，不用再发请求了。")])])]),v._v(" "),e("p",[e("code",[v._v("SPDY")]),v._v("位于"),e("code",[v._v("HTTP")]),v._v("之下，"),e("code",[v._v("TCP")]),v._v("和"),e("code",[v._v("SSL")]),v._v("之上，这样可以轻松兼容老版本的"),e("code",[v._v("HTTP")]),v._v("协议(将"),e("code",[v._v("HTTP1.x")]),v._v("的内容封装成一种新的 frame 格式)，同时可以使用已有的"),e("code",[v._v("SSL")]),v._v("功能。")]),v._v(" "),e("h2",{attrs:{id:"spdy-与-http2-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spdy-与-http2-的区别"}},[v._v("#")]),v._v(" SPDY 与 HTTP2 的区别")]),v._v(" "),e("ul",[e("li",[v._v("头部压缩算法，"),e("code",[v._v("SPDY")]),v._v("，通用的"),e("code",[v._v("deflate")]),v._v("算法[注 1]；"),e("code",[v._v("HTTP2")]),v._v("，专门为压缩头部设计的"),e("code",[v._v("HPACK")]),v._v("算法")]),v._v(" "),e("li",[e("code",[v._v("SPDY")]),v._v("必须在"),e("code",[v._v("TLS")]),v._v("上运行，"),e("code",[v._v("HTTP2")]),v._v("可在"),e("code",[v._v("TCP")]),v._v("上直接使用，因为增加了"),e("code",[v._v("HTTP1.1")]),v._v("的"),e("code",[v._v("Upgrade")]),v._v("机制")]),v._v(" "),e("li",[v._v("更加完善的协议商讨和确认流程")]),v._v(" "),e("li",[v._v("更加完善的"),e("code",[v._v("Server Push")]),v._v("流程")]),v._v(" "),e("li",[v._v("增加控制帧的种类，并对帧的格式考虑的更细致")])]),v._v(" "),e("h2",{attrs:{id:"http2-的缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http2-的缺点"}},[v._v("#")]),v._v(" HTTP2 的缺点")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("TCP")]),v._v(" 以及 "),e("code",[v._v("TCP+TLS")]),v._v("建立连接的延时,"),e("code",[v._v("HTTP2.0")]),v._v("使用"),e("code",[v._v("TCP")]),v._v("协议来传输的，而如果使用"),e("code",[v._v("HTTPS")]),v._v("的话，还需要使用"),e("code",[v._v("TLS")]),v._v("协议进行安全传输，而使用"),e("code",[v._v("TLS")]),v._v("也需要一个握手过程,在传输数据之前，导致我们需要花掉 3 ～ 4 个 "),e("code",[v._v("RTT")]),v._v("。")]),v._v(" "),e("li",[e("code",[v._v("TCP")]),v._v("的队头阻塞并没有彻底解决。在"),e("code",[v._v("HTTP2.0")]),v._v("中，多个请求是跑在一个"),e("code",[v._v("TCP")]),v._v("管道中的。但当 HTTP/2 出现丢包时，整个 "),e("code",[v._v("TCP")]),v._v(" 都要开始等待重传，那么就会阻塞该"),e("code",[v._v("TCP")]),v._v("连接中的所有请求。")])]),v._v(" "),e("h2",{attrs:{id:"http3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http3"}},[v._v("#")]),v._v(" HTTP3")]),v._v(" "),e("p",[v._v("Google 在推···的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 "),e("code",[v._v("UDP")]),v._v(" 协议的"),e("code",[v._v("QUIC")]),v._v("协议，让"),e("code",[v._v("HTTP")]),v._v("跑在"),e("code",[v._v("QUIC")]),v._v("上而不是"),e("code",[v._v("TCP")]),v._v("上。主要特性如下：")]),v._v(" "),e("ul",[e("li",[v._v("实现了类似"),e("code",[v._v("TCP")]),v._v("的"),e("strong",[v._v("流量控制")]),v._v("、"),e("strong",[v._v("传输可靠性")]),v._v("的功能。虽然"),e("code",[v._v("UDP")]),v._v("不提供可靠性的传输，但"),e("code",[v._v("QUIC")]),v._v("在"),e("code",[v._v("UDP")]),v._v("的基础之上增加了一层来保证数据可靠性传输。它提供了"),e("strong",[v._v("数据包重传")]),v._v("、"),e("strong",[v._v("拥塞控制")]),v._v("以及其他一些"),e("code",[v._v("TCP")]),v._v("中存在的特性")]),v._v(" "),e("li",[e("strong",[v._v("实现了快速握手功能")]),v._v("。由于"),e("code",[v._v("QUIC")]),v._v("是基于"),e("code",[v._v("UDP")]),v._v("的，所以"),e("code",[v._v("QUIC")]),v._v("可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着"),e("code",[v._v("QUIC")]),v._v("可以用最快的速度来发送和接收数据。")]),v._v(" "),e("li",[e("strong",[v._v("集成了 TLS 加密功能")]),v._v("。目前"),e("code",[v._v("QUIC")]),v._v("使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的"),e("code",[v._v("RTT")]),v._v("个数。")]),v._v(" "),e("li",[e("strong",[v._v("多路复用")]),v._v("，彻底解决"),e("code",[v._v("TCP")]),v._v("中队头阻塞的问题")])]),v._v(" "),e("h2",{attrs:{id:"最后"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最后"}},[v._v("#")]),v._v(" 最后")]),v._v(" "),e("p",[v._v("文中若有不准确或错误的地方，欢迎指出，有兴趣可以的关注下"),e("a",{attrs:{href:"https://github.com/GolderBrother",target:"_blank",rel:"noopener noreferrer"}},[v._v("Github"),e("OutboundLink")],1),v._v("，一起学习呀~~")]),v._v(" "),e("comment")],1)}),[],!1,null,null,null);_.default=o.exports}}]);