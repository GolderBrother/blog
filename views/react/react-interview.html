<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- 为了可以访问第三方图床的图片，才添加了这句代码，如果你的图片是存在本地的，去掉这句代码即可 -->
    <meta id="referrer" name="referrer" content="never" />
    <!-- <meta id="referrer" name="referrer" content="always" /> -->
    <title>35 道咱们必须要清楚的 React 面试题 | 全栈修炼</title>
    <meta name="description" content="GolderBrother的博客" />
    <link rel="icon" href="/blog/assets/favicon.ico">  <link rel="preload" href="/blog/assets/css/0.styles.2dde6c16.css" as="style"><link rel="preload" href="/blog/assets/js/app.74817549.js" as="script"><link rel="preload" href="/blog/assets/js/2.f761193d.js" as="script"><link rel="preload" href="/blog/assets/js/172.eeb81923.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.ea66aff3.js"><link rel="prefetch" href="/blog/assets/js/100.1650309e.js"><link rel="prefetch" href="/blog/assets/js/101.dd5cdc51.js"><link rel="prefetch" href="/blog/assets/js/102.81a755d8.js"><link rel="prefetch" href="/blog/assets/js/103.84d1e041.js"><link rel="prefetch" href="/blog/assets/js/104.6bb79eda.js"><link rel="prefetch" href="/blog/assets/js/105.ac0fa491.js"><link rel="prefetch" href="/blog/assets/js/106.e7f21162.js"><link rel="prefetch" href="/blog/assets/js/107.a932b9dd.js"><link rel="prefetch" href="/blog/assets/js/108.08337848.js"><link rel="prefetch" href="/blog/assets/js/109.0a8ac1ac.js"><link rel="prefetch" href="/blog/assets/js/11.2b17f742.js"><link rel="prefetch" href="/blog/assets/js/110.63f713ce.js"><link rel="prefetch" href="/blog/assets/js/111.3ded28af.js"><link rel="prefetch" href="/blog/assets/js/112.feb77183.js"><link rel="prefetch" href="/blog/assets/js/113.ca7a3dfe.js"><link rel="prefetch" href="/blog/assets/js/114.278aaabb.js"><link rel="prefetch" href="/blog/assets/js/115.3f930fa5.js"><link rel="prefetch" href="/blog/assets/js/116.0686a02f.js"><link rel="prefetch" href="/blog/assets/js/117.22090497.js"><link rel="prefetch" href="/blog/assets/js/118.d7f089fa.js"><link rel="prefetch" href="/blog/assets/js/119.3c8db627.js"><link rel="prefetch" href="/blog/assets/js/12.d4feb8d0.js"><link rel="prefetch" href="/blog/assets/js/120.e516c49a.js"><link rel="prefetch" href="/blog/assets/js/121.d702cc4d.js"><link rel="prefetch" href="/blog/assets/js/122.13d4f773.js"><link rel="prefetch" href="/blog/assets/js/123.6905c46b.js"><link rel="prefetch" href="/blog/assets/js/124.ccac9465.js"><link rel="prefetch" href="/blog/assets/js/125.3fad187d.js"><link rel="prefetch" href="/blog/assets/js/126.065c2aad.js"><link rel="prefetch" href="/blog/assets/js/127.d4aef2ae.js"><link rel="prefetch" href="/blog/assets/js/128.00766f11.js"><link rel="prefetch" href="/blog/assets/js/129.51d245ca.js"><link rel="prefetch" href="/blog/assets/js/13.21c8139a.js"><link rel="prefetch" href="/blog/assets/js/130.82b8009d.js"><link rel="prefetch" href="/blog/assets/js/131.fb8da159.js"><link rel="prefetch" href="/blog/assets/js/132.2484fde1.js"><link rel="prefetch" href="/blog/assets/js/133.177fe1b1.js"><link rel="prefetch" href="/blog/assets/js/134.5611fa2b.js"><link rel="prefetch" href="/blog/assets/js/135.4d1053c3.js"><link rel="prefetch" href="/blog/assets/js/136.2973975f.js"><link rel="prefetch" href="/blog/assets/js/137.7c44ba09.js"><link rel="prefetch" href="/blog/assets/js/138.16973a68.js"><link rel="prefetch" href="/blog/assets/js/139.2f797054.js"><link rel="prefetch" href="/blog/assets/js/14.8cf70ab3.js"><link rel="prefetch" href="/blog/assets/js/140.f94ba770.js"><link rel="prefetch" href="/blog/assets/js/141.69f9800f.js"><link rel="prefetch" href="/blog/assets/js/142.b567c447.js"><link rel="prefetch" href="/blog/assets/js/143.f1ee0ada.js"><link rel="prefetch" href="/blog/assets/js/144.138163b4.js"><link rel="prefetch" href="/blog/assets/js/145.e3bee357.js"><link rel="prefetch" href="/blog/assets/js/146.3a9fd8c7.js"><link rel="prefetch" href="/blog/assets/js/147.0b8e88a6.js"><link rel="prefetch" href="/blog/assets/js/148.81da2cf3.js"><link rel="prefetch" href="/blog/assets/js/149.d44d0121.js"><link rel="prefetch" href="/blog/assets/js/15.ea38d450.js"><link rel="prefetch" href="/blog/assets/js/150.7665d423.js"><link rel="prefetch" href="/blog/assets/js/151.1ab5f781.js"><link rel="prefetch" href="/blog/assets/js/152.620db4ac.js"><link rel="prefetch" href="/blog/assets/js/153.695d756f.js"><link rel="prefetch" href="/blog/assets/js/154.ee82e0a2.js"><link rel="prefetch" href="/blog/assets/js/155.d7bc8987.js"><link rel="prefetch" href="/blog/assets/js/156.95cf0d01.js"><link rel="prefetch" href="/blog/assets/js/157.76159f7e.js"><link rel="prefetch" href="/blog/assets/js/158.e27d7f12.js"><link rel="prefetch" href="/blog/assets/js/159.84d58dcb.js"><link rel="prefetch" href="/blog/assets/js/16.7794197c.js"><link rel="prefetch" href="/blog/assets/js/160.44f17ac0.js"><link rel="prefetch" href="/blog/assets/js/161.a9fc1420.js"><link rel="prefetch" href="/blog/assets/js/162.953ffb8f.js"><link rel="prefetch" href="/blog/assets/js/163.d4b64d04.js"><link rel="prefetch" href="/blog/assets/js/164.d718bdc2.js"><link rel="prefetch" href="/blog/assets/js/165.464562ce.js"><link rel="prefetch" href="/blog/assets/js/166.3486924a.js"><link rel="prefetch" href="/blog/assets/js/167.044ce06a.js"><link rel="prefetch" href="/blog/assets/js/168.81e22c48.js"><link rel="prefetch" href="/blog/assets/js/169.4c4a576c.js"><link rel="prefetch" href="/blog/assets/js/17.7083b50c.js"><link rel="prefetch" href="/blog/assets/js/170.4b71dfab.js"><link rel="prefetch" href="/blog/assets/js/171.d2051e87.js"><link rel="prefetch" href="/blog/assets/js/173.aafb24fa.js"><link rel="prefetch" href="/blog/assets/js/174.2e261a79.js"><link rel="prefetch" href="/blog/assets/js/175.aafd75a2.js"><link rel="prefetch" href="/blog/assets/js/176.b7681070.js"><link rel="prefetch" href="/blog/assets/js/177.e9bdb5f5.js"><link rel="prefetch" href="/blog/assets/js/178.4a3ca305.js"><link rel="prefetch" href="/blog/assets/js/179.40201a86.js"><link rel="prefetch" href="/blog/assets/js/18.3dbb7741.js"><link rel="prefetch" href="/blog/assets/js/180.68c6346e.js"><link rel="prefetch" href="/blog/assets/js/181.326c1f42.js"><link rel="prefetch" href="/blog/assets/js/182.92780c32.js"><link rel="prefetch" href="/blog/assets/js/183.65f40b5a.js"><link rel="prefetch" href="/blog/assets/js/19.78fd69da.js"><link rel="prefetch" href="/blog/assets/js/20.be39648e.js"><link rel="prefetch" href="/blog/assets/js/21.80a318b4.js"><link rel="prefetch" href="/blog/assets/js/22.4040efb3.js"><link rel="prefetch" href="/blog/assets/js/23.dbb39e0a.js"><link rel="prefetch" href="/blog/assets/js/24.f27f8467.js"><link rel="prefetch" href="/blog/assets/js/25.448302be.js"><link rel="prefetch" href="/blog/assets/js/26.78106ffa.js"><link rel="prefetch" href="/blog/assets/js/27.2a65554d.js"><link rel="prefetch" href="/blog/assets/js/28.55501022.js"><link rel="prefetch" href="/blog/assets/js/29.af733838.js"><link rel="prefetch" href="/blog/assets/js/3.df759ff3.js"><link rel="prefetch" href="/blog/assets/js/30.8ce1d72b.js"><link rel="prefetch" href="/blog/assets/js/31.7925ec43.js"><link rel="prefetch" href="/blog/assets/js/32.f9892d98.js"><link rel="prefetch" href="/blog/assets/js/33.afd7fd02.js"><link rel="prefetch" href="/blog/assets/js/34.ee49fe13.js"><link rel="prefetch" href="/blog/assets/js/35.0e4f5335.js"><link rel="prefetch" href="/blog/assets/js/36.96311e99.js"><link rel="prefetch" href="/blog/assets/js/37.fb3163b1.js"><link rel="prefetch" href="/blog/assets/js/38.778ed95b.js"><link rel="prefetch" href="/blog/assets/js/39.0531a2e1.js"><link rel="prefetch" href="/blog/assets/js/4.bb581d32.js"><link rel="prefetch" href="/blog/assets/js/40.ec9153c6.js"><link rel="prefetch" href="/blog/assets/js/41.2e9e71db.js"><link rel="prefetch" href="/blog/assets/js/42.af718b8a.js"><link rel="prefetch" href="/blog/assets/js/43.7a4efaa6.js"><link rel="prefetch" href="/blog/assets/js/44.21916db9.js"><link rel="prefetch" href="/blog/assets/js/45.c02e6427.js"><link rel="prefetch" href="/blog/assets/js/46.c95ab531.js"><link rel="prefetch" href="/blog/assets/js/47.d505fc9f.js"><link rel="prefetch" href="/blog/assets/js/48.9291572a.js"><link rel="prefetch" href="/blog/assets/js/49.79fd5fda.js"><link rel="prefetch" href="/blog/assets/js/5.cc289552.js"><link rel="prefetch" href="/blog/assets/js/50.40ff6888.js"><link rel="prefetch" href="/blog/assets/js/51.d16aa2b4.js"><link rel="prefetch" href="/blog/assets/js/52.4528f49d.js"><link rel="prefetch" href="/blog/assets/js/53.b16b42d4.js"><link rel="prefetch" href="/blog/assets/js/54.4fff7e01.js"><link rel="prefetch" href="/blog/assets/js/55.6832b1c5.js"><link rel="prefetch" href="/blog/assets/js/56.d16f1707.js"><link rel="prefetch" href="/blog/assets/js/57.de08e9ba.js"><link rel="prefetch" href="/blog/assets/js/58.6ca6f21b.js"><link rel="prefetch" href="/blog/assets/js/59.e518317a.js"><link rel="prefetch" href="/blog/assets/js/6.4efa9fa4.js"><link rel="prefetch" href="/blog/assets/js/60.935521f1.js"><link rel="prefetch" href="/blog/assets/js/61.ce9eda13.js"><link rel="prefetch" href="/blog/assets/js/62.e6c745bf.js"><link rel="prefetch" href="/blog/assets/js/63.647fd8d7.js"><link rel="prefetch" href="/blog/assets/js/64.4c9b4781.js"><link rel="prefetch" href="/blog/assets/js/65.80857907.js"><link rel="prefetch" href="/blog/assets/js/66.b89b796a.js"><link rel="prefetch" href="/blog/assets/js/67.b9798c32.js"><link rel="prefetch" href="/blog/assets/js/68.49b67f24.js"><link rel="prefetch" href="/blog/assets/js/69.665837ff.js"><link rel="prefetch" href="/blog/assets/js/7.b94332e9.js"><link rel="prefetch" href="/blog/assets/js/70.ce57ed8e.js"><link rel="prefetch" href="/blog/assets/js/71.71ae5067.js"><link rel="prefetch" href="/blog/assets/js/72.69c7c32d.js"><link rel="prefetch" href="/blog/assets/js/73.6b47b8f7.js"><link rel="prefetch" href="/blog/assets/js/74.bd6cd299.js"><link rel="prefetch" href="/blog/assets/js/75.297a83bc.js"><link rel="prefetch" href="/blog/assets/js/76.e49268ee.js"><link rel="prefetch" href="/blog/assets/js/77.6efa828f.js"><link rel="prefetch" href="/blog/assets/js/78.c38cb032.js"><link rel="prefetch" href="/blog/assets/js/79.478e1642.js"><link rel="prefetch" href="/blog/assets/js/8.80c6038b.js"><link rel="prefetch" href="/blog/assets/js/80.ff9e57e9.js"><link rel="prefetch" href="/blog/assets/js/81.e3dbf4d0.js"><link rel="prefetch" href="/blog/assets/js/82.270df640.js"><link rel="prefetch" href="/blog/assets/js/83.3bc7036f.js"><link rel="prefetch" href="/blog/assets/js/84.a3ccc99e.js"><link rel="prefetch" href="/blog/assets/js/85.7cdab723.js"><link rel="prefetch" href="/blog/assets/js/86.9f0c2ccd.js"><link rel="prefetch" href="/blog/assets/js/87.b7e93260.js"><link rel="prefetch" href="/blog/assets/js/88.557a99bb.js"><link rel="prefetch" href="/blog/assets/js/89.16a0d8d1.js"><link rel="prefetch" href="/blog/assets/js/9.4fbaf7a8.js"><link rel="prefetch" href="/blog/assets/js/90.52190781.js"><link rel="prefetch" href="/blog/assets/js/91.b9507740.js"><link rel="prefetch" href="/blog/assets/js/92.c0eb92c0.js"><link rel="prefetch" href="/blog/assets/js/93.ca3ba1d1.js"><link rel="prefetch" href="/blog/assets/js/94.a8ffcee7.js"><link rel="prefetch" href="/blog/assets/js/95.23fe688e.js"><link rel="prefetch" href="/blog/assets/js/96.b5d64bc6.js"><link rel="prefetch" href="/blog/assets/js/97.c41d4d64.js"><link rel="prefetch" href="/blog/assets/js/98.c415501d.js"><link rel="prefetch" href="/blog/assets/js/99.ab069b22.js"> <link rel="stylesheet" href="/blog/assets/css/0.styles.2dde6c16.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/assets/logo.jpg" alt="全栈修炼" class="logo"> <span class="site-name can-hide">全栈修炼</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/guide/" class="nav-link">主页</a></div><div class="nav-item"><a href="/blog/views/" class="nav-link router-link-active">大前端</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Select language" class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/views/react/react-interview.html" class="nav-link router-link-exact-active router-link-active">zh-CN</a></li><li class="dropdown-item"><!----> <a href="/blog/en/" class="nav-link">en-US</a></li></ul></div></div> <a href="https://github.com/GolderBrother/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/guide/" class="nav-link">主页</a></div><div class="nav-item"><a href="/blog/views/" class="nav-link router-link-active">大前端</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Select language" class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/views/react/react-interview.html" class="nav-link router-link-exact-active router-link-active">zh-CN</a></li><li class="dropdown-item"><!----> <a href="/blog/en/" class="nav-link">en-US</a></li></ul></div></div> <a href="https://github.com/GolderBrother/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/blog/views/" class="sidebar-link">大前端知识大集合</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>GitHub 软技能</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/github/follow.html" class="sidebar-link">GitHub 挖宝技巧</a></li><li><a href="/blog/views/github/star.html" class="sidebar-link">GitHub 吸星大法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器工作原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/browser/input-url-course.html" class="sidebar-link">导航流程：从输入 URL 到页面展示，这中间发生了什么</a></li><li><a href="/blog/views/browser/dom-bind-event.html" class="sidebar-link">一个DOM元素绑定多个事件时，先执行冒泡还是捕获</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>css</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/css/css-skills1.html" class="sidebar-link">10 个让你受益匪浅的 css 使用技巧</a></li><li><a href="/blog/views/css/css-knowledge.html" class="sidebar-link">你未必知道的 49 个 CSS 知识点</a></li><li><a href="/blog/views/css/css-knowledge2.html" class="sidebar-link">你未必知道的 49 个 CSS 知识点二~</a></li><li><a href="/blog/views/css/css-center.html" class="sidebar-link">一起搞懂 CSS 水平居中与垂直居中的 16 个方法</a></li><li><a href="/blog/views/css/css-flex.html" class="sidebar-link">弹性盒子中 flex: 0 1 auto 表示什么意思</a></li><li><a href="/blog/views/css/css-BFC.html" class="sidebar-link">CSS 中的 BFC 详解</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>移动端h5</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/h5/h5-demo1.html" class="sidebar-link">移动端 H5 和 Hybrid 相关基础技术概览</a></li><li><a href="/blog/views/mobile/mobile-skill.html" class="sidebar-link">总结移动端 H5 开发常用技巧</a></li><li><a href="/blog/views/mobile/mobile-optmization.html" class="sidebar-link">关于移动端体验优化经验总结</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Javascript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/javascript/js-skills.html" class="sidebar-link">你可能不知道的 JS 开发技巧</a></li><li><a href="/blog/views/javascript/js-skills2.html" class="sidebar-link">一个合格的中级前端er需要掌握的 28 个 JavaScript 技巧</a></li><li><a href="/blog/views/javascript/js-utils.html" class="sidebar-link">书到用时方恨少，一大波 JS 开发工具函数来了</a></li><li><a href="/blog/views/javascript/js-utils2.html" class="sidebar-link">前端常用的 60 余种工具方法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Typescript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/typescript/ts-demo.html" class="sidebar-link">TypeScript 高级用法详解</a></li><li><a href="/blog/views/typescript/ts-difficult.html" class="sidebar-link">TypeScript 重难点梳理</a></li><li><a href="/blog/views/typescript/ts-problem.html" class="sidebar-link">TS 常见问题整理（60 多个）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue.js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/vue/vue-ts.html" class="sidebar-link">Vue + TS + El 搭建博客及踩坑记</a></li><li><a href="/blog/views/vue/vue-lazyload.html" class="sidebar-link">vue 路由懒加载及组件懒加载</a></li><li><a href="/blog/views/vue/vue-skills-36.html" class="sidebar-link">Vue 开发必须知道的 36 个技巧</a></li><li><a href="/blog/views/vue/vue-interview.html" class="sidebar-link">30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度）</a></li><li><a href="/blog/views/vue/vue-interview/part-one/note.html" class="sidebar-link">Vue 面试题汇总</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React.js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/react/react-hooks.html" class="sidebar-link">React Hooks 相关 API 总结</a></li><li><a href="/blog/views/react/react-lifecycle.html" class="sidebar-link">React v16.0 前的生命周期</a></li><li><a href="/blog/views/react/react-skill.html" class="sidebar-link">5 个技巧助你编写更好的 React 代码</a></li><li><a href="/blog/views/react/react-nice-library.html" class="sidebar-link">5 个很棒的 React.js 库，值得你亲手试试！</a></li><li><a href="/blog/views/react/react-interview.html" class="active sidebar-link">35 道咱们必须要清楚的 React 面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/views/react/react-interview.html#_35-道咱们必须要清楚的-react-面试题" class="sidebar-link">35 道咱们必须要清楚的 React 面试题</a></li><li class="sidebar-sub-header"><a href="/blog/views/react/react-interview.html#最后" class="sidebar-link">最后</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React-Native</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/react-native/RN&amp;Native-message.html" class="sidebar-link">React Native 跟原生之间的通信</a></li><li><a href="/blog/views/react-native/ReactNative&amp;Flutter&amp;uni-app.html" class="sidebar-link">一、技术学习成本和难度</a></li><li><a href="/blog/views/react-native/ReactNative&amp;Flutter&amp;uni-app.html" class="sidebar-link">一、技术学习成本和难度</a></li><li><a href="/blog/views/react-native/codepush-config.html" class="sidebar-link">RN 配置热更新+使用文档</a></li><li><a href="/blog/views/react-native/codepush-deploy.html" class="sidebar-link">React Native + 热更新(Code Push) 部署文档</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/webpack/webpack1.html" class="sidebar-link">一大波 Webpack 面试题来啦~</a></li><li><a href="/blog/views/webpack/webpack-optimize.html" class="sidebar-link">webpack 优化篇</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端跨域相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/cors/corssOrigin-pro.html" class="sidebar-link">10 种跨域解决方案（附终极方案）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>vite</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/vite/vite-study.html" class="sidebar-link">vite原理剖析</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>cli</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/cli/james-cli.html" class="sidebar-link">手撸一个自己的前端脚手架</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Node.js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/node/node1.html" class="sidebar-link">/views/node/node1.html</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端设计模式之美</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/fe-design/fe-design-9.html" class="sidebar-link">前端应知应会的 9 种设计模式(详细篇)</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端数据结构之美</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/data-structure/data-structure.html" class="sidebar-link">前端数据结构之美</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端算法学习指南</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/algorithms/sort.html" class="sidebar-link">十大经典算法</a></li><li><a href="/blog/views/algorithms/interview.html" class="sidebar-link">面试必刷-《剑指 offer》刷题小结</a></li><li><a href="/blog/views/algorithms/string.html" class="sidebar-link">字符串相关算法</a></li><li><a href="/blog/views/algorithms/array.html" class="sidebar-link">数组串相关算法</a></li><li><a href="/blog/views/algorithms/linklist.html" class="sidebar-link">链表相关算法题</a></li><li><a href="/blog/views/algorithms/tree.html" class="sidebar-link">二叉树相关算法</a></li><li><a href="/blog/views/algorithms/tencent/array&amp;string.html" class="sidebar-link">腾讯算法题-数组与字符串</a></li><li><a href="/blog/views/algorithms/tencent/number.html" class="sidebar-link">腾讯算法题-数学与数字</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端面试集锦</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/fe-interview/alibaba.html" class="sidebar-link">阿里面试题</a></li><li><a href="/blog/views/fe-interview/bytedance.html" class="sidebar-link">字节跳动面试题</a></li><li><a href="/blog/views/fe-interview/bytedance-algorithms.html" class="sidebar-link">字节跳动算法题</a></li><li><a href="/blog/views/fe-interview/tencent.html" class="sidebar-link">微信面试题</a></li><li><a href="/blog/views/fe-interview/classic-layout.html" class="sidebar-link">掌握两大经典布局方案</a></li><li><a href="/blog/views/fe-interview/web-safe.html" class="sidebar-link">谈谈 web 安全问题及解决方案</a></li><li><a href="/blog/views/fe-interview/http&amp;https.html" class="sidebar-link">http2/http3 协议有什么优劣</a></li><li><a href="/blog/views/fe-interview/webpack-performance-optimization.html" class="sidebar-link">Webpack 性能优化你知道哪些</a></li><li><a href="/blog/views/fe-interview/webpack-principle.html" class="sidebar-link">说说 webpack 打包的原理</a></li><li><a href="/blog/views/fe-interview/webpack-HMR.html" class="sidebar-link">HMR 的原理是什么</a></li><li><a href="/blog/views/fe-interview/chrome-start-process.html" class="sidebar-link">Chrome 打开一个页面需要启动多少进程？分别有哪些进程</a></li><li><a href="/blog/views/fe-interview/dns-prefetch.html" class="sidebar-link">谈谈你对 dns-prefetch 的理解</a></li><li><a href="/blog/views/fe-interview/browser-cache.html" class="sidebar-link">浏览器缓存一探究竟~</a></li><li><a href="/blog/views/fe-interview/send-content-to-browser.html" class="sidebar-link">如何保证页面文件能被完整送达浏览器</a></li><li><a href="/blog/views/fe-interview/browser-render.html" class="sidebar-link">浏览器渲染过程是怎样的</a></li><li><a href="/blog/views/fe-interview/browser-reflow&amp;repain.html" class="sidebar-link">如何理解回流和重绘</a></li><li><a href="/blog/views/fe-interview/renderEngine-createNewLayer.html" class="sidebar-link">渲染引擎什么情况下才会为特定的节点创建新的图层</a></li><li><a href="/blog/views/fe-interview/UDP&amp;TCP-different.html" class="sidebar-link">UDP 和 TCP 有什么区别</a></li><li><a href="/blog/views/fe-interview/js-modules.html" class="sidebar-link">说说 js 的模块化</a></li><li><a href="/blog/views/fe-interview/lazyMan.html" class="sidebar-link">实现一个 LazyMan，可以按照以下方式调用</a></li><li><a href="/blog/views/fe-interview/handwriting-promise.html" class="sidebar-link">少年，来，手写一个 Promise 吧</a></li><li><a href="/blog/views/fe-interview/fetch&amp;ajax-diference.html" class="sidebar-link">请说下 fetch 和 ajax 的区别吧</a></li><li><a href="/blog/views/fe-interview/browser-input-url.html" class="sidebar-link">细说浏览器输入 URL 后发生了什么</a></li><li><a href="/blog/views/fe-interview/picture-optimization.html" class="sidebar-link">前端的图片优化方案你知道多少</a></li><li><a href="/blog/views/fe-interview/node-eventLoop.html" class="sidebar-link">来，说说 node 的事件循环机制吧</a></li><li><a href="/blog/views/fe-interview/browser-eventLoop.html" class="sidebar-link">小伙子，谈谈浏览器端的事件循环吧</a></li><li><a href="/blog/views/fe-interview/setTimeout&amp;setImmediate.html" class="sidebar-link">node中的setTimeout 和 setImmediate有什么区别</a></li><li><a href="/blog/views/fe-interview/js-interview.html" class="sidebar-link">收集一些 javascript 相关的面试题</a></li><li><a href="/blog/views/fe-interview/fuck-interview.html" class="sidebar-link">那些恶心的面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端必知必会的网络基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/network/http-interview.html" class="sidebar-link">HTTP 灵魂之问，巩固你的 HTTP 知识体系</a></li><li><a href="/blog/views/network/tcp-interview.html" class="sidebar-link">TCP 协议灵魂之问，巩固你的网络底层基础</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端应知应会的Nginx知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/nginx/nginx-details.html" class="sidebar-link">Nginx 从入门到实践，万字详解！</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端必不可少的git知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/git/git-command-animation.html" class="sidebar-link">相见恨晚的 Git 命令动画演示，一看就懂！</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端性能优化专题，让你的网站飞起来吧</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/performance/code-split.html" class="sidebar-link">项目不知道如何做性能优化？不妨试试代码分割吧</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端高手进阶专题，告别小菜鸟</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/fe-advanced/ad1.html" class="sidebar-link">你真的熟悉 HTML 标签吗？</a></li><li><a href="/blog/views/fe-advanced/ad2.html" class="sidebar-link">如何高效操作 DOM 元素？</a></li><li><a href="/blog/views/fe-advanced/ad3.html" class="sidebar-link">3 个使用场景助你用好 DOM 事件</a></li><li><a href="/blog/views/fe-advanced/ad6.html" class="sidebar-link">浏览器如何渲染页面？</a></li><li><a href="/blog/views/fe-advanced/ad7.html" class="sidebar-link">关于 JavaScript 的数据类型，你知多少</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_35-道咱们必须要清楚的-react-面试题"><a href="#_35-道咱们必须要清楚的-react-面试题" class="header-anchor">#</a> 35 道咱们必须要清楚的 React 面试题</h2> <h3 id="问题-1：什么是虚拟-dom"><a href="#问题-1：什么是虚拟-dom" class="header-anchor">#</a> 问题 1：什么是虚拟 DOM</h3> <blockquote><p>主题: React
难度: ⭐</p></blockquote> <p><strong>虚拟 DOM (VDOM)是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。</strong></p> <h3 id="问题-2：类组件和函数组件之间的区别是啥？"><a href="#问题-2：类组件和函数组件之间的区别是啥？" class="header-anchor">#</a> 问题 2：类组件和函数组件之间的区别是啥？</h3> <p>主题: React</p> <p>难度: ⭐⭐</p> <ul><li><p><strong>类组件</strong>可以使用其他特性，如状态 state 和生命周期钩子。</p></li> <li><p>当组件只是接收 props 渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。</p></li></ul> <p>函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。</p> <table><thead><tr><th>区别</th> <th>函数组件</th> <th>类组件</th></tr></thead> <tbody><tr><td>是否有 <code>this</code></td> <td>没有</td> <td>有</td></tr> <tr><td>是否有生命周期</td> <td>没有</td> <td>有</td></tr> <tr><td>是否有状态 <code>state</code></td> <td>没有</td> <td>有</td></tr></tbody></table> <h3 id="问题-3：react-中-refs-干嘛用的？"><a href="#问题-3：react-中-refs-干嘛用的？" class="header-anchor">#</a> 问题 3：React 中 refs 干嘛用的？</h3> <blockquote><p>主题: React</p></blockquote> <blockquote><p>难度: ⭐⭐</p></blockquote> <p><code>Refs</code>提供了一种访问在<code>render</code>方法中创建的<code>DOM</code>节点或者<code>React</code>元素的方法。在典型的数据流中，<code>props</code>是父子组件交互的唯一方式，想要修改子组件，需要使用新的<code>prosp</code>重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用<code>Refs</code>。</p> <p>咱们可以在组件添加一个<code>ref</code>属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层<code>DOM</code>元素或组件的挂载实例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">UnControlledForm</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">handleSubmit</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Input Value: '</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>input<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit<span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token parameter">input</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>input <span class="token operator">=</span> input<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">&quot;submit&quot;</span><span class="token operator">&gt;</span>Submit<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>请注意，<code>input</code>元素有一个<code>ref</code>属性，它的值是一个函数。该函数接收输入的实际<code>DOM</code>元素，然后将其放在实例上，这样就可以在<code>handleSubmit</code>函数内部访问它。</p> <p>经常被误解的只有在类组件中才能使用<code>refs</code>，但是 refs 也可以通过利用<code>JS</code>中的闭包与函数组件一起使用。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">CustomForm</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> handleSubmit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> inputElement<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">handleSubmit</span><span class="token punctuation">(</span>inputElement<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token parameter">input</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>inputElement <span class="token operator">=</span> input<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">&quot;submit&quot;</span><span class="token operator">&gt;</span>Submit<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="问题-4：在-react-中如何处理事件"><a href="#问题-4：在-react-中如何处理事件" class="header-anchor">#</a> 问题 4：在 React 中如何处理事件</h3> <blockquote><p>主题: React
难度: ⭐⭐</p></blockquote> <p>为了解决跨浏览器的兼容性问题，<code>SyntheticEvent</code>实例将被传递给你的事件处理函数，<code>SyntheticEvent</code>是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括<code>stopPropagation()</code>和 <code>preventDefault()</code>。
比较有趣的是，React 实际上并不将事件附加到子节点本身。React 使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着 React 在更新 DOM 时不需要跟踪事件监听器。</p> <h3 id="问题-5：state-和-props-区别是啥？"><a href="#问题-5：state-和-props-区别是啥？" class="header-anchor">#</a> 问题 5：state 和 props 区别是啥？</h3> <blockquote><p>主题: React
难度: ⭐⭐</p></blockquote> <p><code>props</code>和<code>state</code>是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即</p> <ul><li><code>state</code>是组件自己管理数据，控制自己的状态，可变；</li> <li><code>props</code>是外部传入的数据参数，不可变；</li> <li>没有<code>state</code>的叫做无状态组件，有 state 的叫做有状态组件；</li> <li>多用<code>props</code>，少用<code>state</code>，也就是多写无状态组件。</li></ul> <h3 id="问题-6：如何创建-refs"><a href="#问题-6：如何创建-refs" class="header-anchor">#</a> 问题 6：如何创建 refs</h3> <blockquote><p>主题: React
难度: ⭐⭐</p></blockquote> <p>Refs 是使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素上。在构造组件时，通常将 <code>Refs</code> 分配给实例属性，以便可以在整个组件中引用它们。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>myRef <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>myRef<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>或者这样用：</p> <blockquote><p>使用回调函数的形式</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">UserForm</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">handleSubmit</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Input Value is: '</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>input<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit<span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token parameter">input</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>input <span class="token operator">=</span> input<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span> <span class="token comment">// Access DOM input in handle</span>
        submit
        <span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">&quot;submit&quot;</span><span class="token operator">&gt;</span>Submit<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="问题-7：什么是高阶组件"><a href="#问题-7：什么是高阶组件" class="header-anchor">#</a> 问题 7：什么是高阶组件</h3> <blockquote><p>主题: React
难度: ⭐⭐</p></blockquote> <p><strong>高阶组件(HOC)是接受一个组件并返回一个新组件的函数。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为纯组件</strong>，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 元组件：WrappedComponent EnhancedComponent：增强后的组件</span>
<span class="token keyword">const</span> EnhancedComponent <span class="token operator">=</span> <span class="token function">higherOrderComponent</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>HOC 可以用于以下许多用例</p> <ul><li>代码重用、逻辑和引导抽象</li> <li>渲染劫持</li> <li>state 抽象和操作</li> <li>props 处理</li></ul> <h3 id="问题-8：在构造函数调用-super-并将-props-作为参数传入的作用是啥"><a href="#问题-8：在构造函数调用-super-并将-props-作为参数传入的作用是啥" class="header-anchor">#</a> 问题 8：在构造函数调用 super 并将 props 作为参数传入的作用是啥</h3> <blockquote><p>主题: React
难度: ⭐⭐</p></blockquote> <p>在调用 <code>super()</code> 方法之前，子类构造函数无法使用<code>this</code>引用，ES6 子类也是如此。将 <code>props</code> 参数传递给 <code>super()</code> 调用的主要原因是在子构造函数中能够通过<code>this.props</code>来获取传入的 <code>props</code>。</p> <h4 id="传递-props"><a href="#传递-props" class="header-anchor">#</a> 传递 props</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { name: 'sudheer',age: 30 }</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="没传递-props"><a href="#没传递-props" class="header-anchor">#</a> 没传递 props</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
    <span class="token comment">// 但是 Props 参数仍然可用</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Prints { name: 'sudheer',age: 30 }</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 构造函数外部不受影响</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { name: 'sudheer',age: 30 }</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>上面示例揭示了一点。<code>props</code> 的行为只有在构造函数中是不同的，在构造函数之外也是一样的。</p></blockquote> <h3 id="问题-9：什么是控制组件"><a href="#问题-9：什么是控制组件" class="header-anchor">#</a> 问题 9：什么是控制组件</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <p>在 HTML 中，表单元素如 ·<code>&lt;input&gt;、&lt;textarea&gt;和&lt;select&gt;</code>通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。</p> <p>而 React 的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数(例如<code>onChange</code>)触发时重新渲染组件，因为状态被更新。以这种方式由 React 控制其值的输入表单元素称为<strong>受控组件</strong>。</p> <h3 id="问题-10：如何-react-createelement"><a href="#问题-10：如何-react-createelement" class="header-anchor">#</a> 问题 10：如何 React.createElement</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <h4 id="问题"><a href="#问题" class="header-anchor">#</a> 问题</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token operator">&lt;</span>h1 className<span class="token operator">=</span><span class="token string">&quot;greeting&quot;</span><span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> world<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><p>上述代码如何使用 <code>React.createElement</code> 来实现:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> element <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>
  <span class="token string">'h1'</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    className<span class="token operator">:</span> <span class="token string">'greeting'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">'Hello, world!'</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="问题-11：讲讲什么是-jsx"><a href="#问题-11：讲讲什么是-jsx" class="header-anchor">#</a> 问题 11：讲讲什么是 JSX</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <p>当 <code>Facebook</code> 第一次发布 React 时，他们还引入了一种新的 JS 方言 <code>JSX</code>，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用<code>Babel</code>和<code>webpack</code>等工具将其转换为传统的 JS。很多开发人员就能无意识使用 JSX，因为它已经与 React 结合在一起了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> props <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;my-component&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>url<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="问题-12：根据下面定义的代码，可以找出存在的两个问题吗"><a href="#问题-12：根据下面定义的代码，可以找出存在的两个问题吗" class="header-anchor">#</a> 问题 12：根据下面定义的代码，可以找出存在的两个问题吗</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <p>请看下面的代码：</p> <p><img src="http://img.golderbrother.cn/react-interview.png" alt="image"></p> <p>答案：</p> <p>1.在构造函数没有将 <code>props</code> 传递给 <code>super</code>，准确点说是没有调用<code>super</code>函数来<strong>初始化父类</strong>, 它应该包括以下行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>2.事件监听器(通过<code>addEventListener()</code>分配时)的作用域不正确，因为 ES6 不提供自动绑定。因此，开发人员可以在构造函数中重新分配<code>clickHandler</code>来包含正确的绑定:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>clickHandler <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">clickHandler</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="问题-13：为什么不直接更新-state-呢"><a href="#问题-13：为什么不直接更新-state-呢" class="header-anchor">#</a> 问题 13：为什么不直接更新 state 呢</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <p>如果试图直接更新 <code>state</code> ，则不会重新渲染组件</p> <blockquote><p>如果我们了解 setState 的原理的话，可能就能解答这个问题了，<code>setState</code> 做的事情不仅仅只是修改了 this.state 的&gt; 值，另外最重要的是它会触发 <code>React 的更新机制</code>，会进行 <code>diff</code> ，然后将<code>patch部分</code>更新到<code>真实dom</code>里。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 错误</span>
This<span class="token punctuation">.</span>state<span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">'Hello world'</span><span class="token punctuation">;</span>
</code></pre></div><p>需要使用<code>setState()</code>方法来更新 <code>state</code>。它调度对组件<code>state</code>对象的更新。当<code>state</code>改变时，组件通过重新渲染来响应：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 正确做法</span>
This<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>message<span class="token operator">:</span> ‘Hello World’<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="问题-14：react-组件生命周期有哪些不同阶段"><a href="#问题-14：react-组件生命周期有哪些不同阶段" class="header-anchor">#</a> 问题 14：React 组件生命周期有哪些不同阶段</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <p>在组件生命周期中有四个不同的阶段：</p> <ol><li><p>Initialization：在这个阶段，组件准备设置初始化状态和默认属性。</p></li> <li><p>Mounting：react 组件已经准备好挂载到浏览器 DOM 中。这个阶段包括<code>componentWillMount</code>和<code>componentDidMount</code>生命周期方法。</p></li> <li><p>Updating：在这个阶段，组件以两种方式更新，发送新的 props 和 state 状态。此阶段包括<code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>和<code>componentDidUpdate</code>生命周期方法。</p></li> <li><p>Unmounting：在这个阶段，组件已经不再被需要了，它从浏览器 DOM 中卸载下来。这个阶段包含 <code>componentWillUnmount</code> 生命周期方法。</p></li></ol> <p>除以上四个常用生命周期外，还有一个错误处理的阶段：</p> <p><strong>Error Handling</strong>：在这个阶段，不论在渲染的过程中，还是在生命周期方法中或是在任何子组件的构造函数中发生错误，该组件都会被调用。这个阶段包含了 <code>componentDidCatch</code> 生命周期方法。</p> <p><img src="http://img.golderbrother.cn/react-lifecycle.png" alt="image"></p> <h3 id="问题-15：react-的生命周期方法有哪些"><a href="#问题-15：react-的生命周期方法有哪些" class="header-anchor">#</a> 问题 15：React 的生命周期方法有哪些</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <ul><li><p><code>componentWillMount</code>:在渲染之前执行，用于根组件中的 App 级配置。</p></li> <li><p><code>componentDidMount</code>：在第一次渲染之后执行，可以在这里做 AJAX 请求，DOM 的操作或状态更新以及设置事件监听器。</p></li> <li><p><code>componentWillReceiveProps</code>：在初始化 render 的时候不会执行，它会在组件接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染</p></li> <li><p><code>shouldComponentUpdate</code>：确定是否更新组件。默认情况下，它返回<code>true</code>。如果确定在 <code>state</code> 或 <code>props</code> 更新后组件不需要在重新渲染，则可以返回 false，这是一个提高性能的方法。</p></li> <li><p><code>componentWillUpdate</code>：在<code>shouldComponentUpdate</code>返回 <code>true</code> 确定要更新组件之前件之前执行。</p></li> <li><p><code>componentDidUpdate</code>：它主要用于更新 DOM 以响应<code>props</code>或 <code>state</code>更改。</p></li> <li><p><code>componentWillUnmount</code>：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。</p></li></ul> <h3 id="问题-16：这三个点-在-react-干嘛用的"><a href="#问题-16：这三个点-在-react-干嘛用的" class="header-anchor">#</a> 问题 16：这三个点(...)在 React 干嘛用的</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <p>... 在 React（使用 JSX）代码中做什么？它叫什么？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>Modal <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> title<span class="token operator">=</span><span class="token string">&quot;Modal heading&quot;</span> animation<span class="token operator">=</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre></div><p>这个叫<strong>扩展运算符</strong>或者<strong>展开操作符</strong>,属于<code>ES2018</code>的语法，例如，如果<code>this.props</code>包含<code>a：1</code>和<code>b：2</code>，则</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>Modal <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> title<span class="token operator">=</span><span class="token string">'Modal heading'</span> animation<span class="token operator">=</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
</code></pre></div><p>等价于下面内容：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>Modal a<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>a<span class="token punctuation">}</span> b<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>b<span class="token punctuation">}</span> title<span class="token operator">=</span><span class="token string">'Modal heading'</span> animation<span class="token operator">=</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
</code></pre></div><p>扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新<code>state</code> 咱们就经常这么做：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token parameter">prevState</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span>prevState<span class="token punctuation">.</span>foo<span class="token punctuation">,</span> a<span class="token operator">:</span> <span class="token string">'updated'</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="问题-17：使用-react-hooks-好处是啥"><a href="#问题-17：使用-react-hooks-好处是啥" class="header-anchor">#</a> 问题 17：使用 React Hooks 好处是啥</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <p>首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。</p> <p>Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code>。相反，使用像 useEffect 这样的内置钩子。</p> <p>代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// update xxx =&gt; componentDidUpdate:每次state或者props更新后都会执行一次（默认会先执行上次return函数(也就是下面的函数)里面的逻辑，然后再执行这里面的逻辑）</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// remove listener xxx =&gt; componentWillUnmount:在挂载后执行一次</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// =&gt; componentDidMount 在挂在后执行一次</span>
</code></pre></div><h3 id="问题-18：什么是-react-hooks？"><a href="#问题-18：什么是-react-hooks？" class="header-anchor">#</a> 问题 18：什么是 React Hooks？</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <p><strong>Hooks</strong>是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用<code>state</code>和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。</p> <h3 id="问题-19：react-中的-usestate-是什么？"><a href="#问题-19：react-中的-usestate-是什么？" class="header-anchor">#</a> 问题 19：React 中的 useState() 是什么？</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <p>下面说明 useState(0)的用途：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCounter<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>moreStuff<span class="token punctuation">,</span> setMoreStuff<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">const</span> <span class="token function-variable function">setCount</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setCounter</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setMoreStuff</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><code>useState</code> 是一个内置的 React Hook。<code>useState(0)</code> 返回一个元组，其中第一个参数<code>count</code>是计数器的当前状态，<code>setCounter</code> 提供更新计数器状态的方法。</p> <p>咱们可以在任何地方使用<code>setCounter</code>方法更新计数状态-在这种情况下，咱们在 setCount 函数内部使用它可以做更多的事情，使用 <code>Hooks</code>，能够使咱们的代码保持更多功能,并购且更加简洁易读，还可以避免过多使用基于类的组件。</p> <h3 id="问题-20：react-中的-strictmode-严格模式-是什么？？"><a href="#问题-20：react-中的-strictmode-严格模式-是什么？？" class="header-anchor">#</a> 问题 20：React 中的 StrictMode(严格模式)是什么？？</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <p>React 的<code>StrictMode</code>是一种辅助组件，可以帮助咱们编写更好的 react 组件，可以使用<code>&lt;StrictMode /&gt;</code>包装一组组件，并且可以帮咱们以下检查：</p> <ul><li><p>验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告。</p></li> <li><p>验证是否使用的已经废弃的方法，如果有，会在控制台给出警告。</p></li> <li><p>通过识别潜在的风险预防一些副作用。</p></li></ul> <h3 id="问题-21：为什么类方法需要绑定到类实例"><a href="#问题-21：为什么类方法需要绑定到类实例" class="header-anchor">#</a> 问题 21：为什么类方法需要绑定到类实例</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <p>在 JS 中，this 值会根据当前上下文变化。因为在 react 内部处理事件的特殊性。</p> <p>简单的理解 react 如何处理事件的，React 在组件加载(<code>mount</code>)和更新(<code>update</code>)时，将事件通过<code>addEventListener</code>统一注册到 <code>document</code>上，然后会有一个<strong>事件池</strong>存储了所有的事件，当事件触发的时候，通过<code>dispatchEvent</code>进行事件分发。</p> <p>所以你可以简单的理解为，最终<code>this.handleClick</code>会作为一个<strong>回调函数</strong>调用。</p> <p><strong>如何解决</strong>
在 React 类组件方法中，开发人员通常希望 this 引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的:</p> <p>以下展示了四种方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">SubmitButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      isFormSubmitted<span class="token operator">:</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 2. constuctor 手动 bind 型</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleSubmit</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">handleSubmit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      isFormSubmitted<span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 4. 方法定义成箭头函数型(推荐!)</span>
  <span class="token comment">/* handleSubmit = () =&gt; {
    this.setState({
      isFormSubmitted: true
    });
  } */</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token comment">// 1. 直接 bind this 型</span>
      <span class="token comment">// &lt;button onClick={this.handleSubmit.bind(this)}&gt;Submit&lt;/button&gt;</span>
      <span class="token comment">// 3. 内部直接绑定箭头函数型</span>
      <span class="token comment">// &lt;button onClick={() =&gt; this.handleSubmit()}&gt;Submit&lt;/button&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit<span class="token punctuation">}</span><span class="token operator">&gt;</span>Submit<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="问题-22：什么是-prop-drilling，如何避免"><a href="#问题-22：什么是-prop-drilling，如何避免" class="header-anchor">#</a> 问题 22：什么是 prop drilling，如何避免</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <p>在构建 React 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个 prop 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做 prop drilling。</p> <p><code>prop drilling</code>的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。</p> <p>为了避免<code>prop drilling</code>，一种常用的方法是使用<strong>React Context</strong>。通过定义提供数据的<code>Provider</code>组件，并允许嵌套的组件通过<code>Consumer</code>组件或<code>useContext</code> Hook 使用上下文数据。</p> <h3 id="问题-23：描述-flux-与-mvc"><a href="#问题-23：描述-flux-与-mvc" class="header-anchor">#</a> 问题 23：描述 Flux 与 MVC</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <p>传统的 MVC 模式在分离数据(Model)、UI(View 和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:</p> <p><strong>数据流不够清晰</strong>:跨视图发生的级联更新常常会导致混乱的事件网络，难于调试。</p> <p><strong>缺乏数据完整性</strong>:模型数据可以在任何地方发生突变，从而在整个 UI 中产生不可预测的结果。</p> <p>使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的 React 组件都能够根据 store 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性。</p> <h3 id="问题-24：受控组件和非受控组件区别是啥"><a href="#问题-24：受控组件和非受控组件区别是啥" class="header-anchor">#</a> 问题 24：受控组件和非受控组件区别是啥</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐</p></blockquote> <ul><li><strong>受控组件</strong>是 React 控制中的组件，并且是表单数据真实的唯一来源。</li> <li><strong>非受控组件</strong>是由 DOM 处理表单数据的地方，而不是在 React 组件中。</li></ul> <p>尽管非受控组件通常更易于实现，因为只需使用<code>refs</code>即可从 DOM 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。
这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式。</p> <h3 id="问题-25：这段代码有什么问题吗"><a href="#问题-25：这段代码有什么问题吗" class="header-anchor">#</a> 问题 25：这段代码有什么问题吗</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐⭐</p></blockquote> <p>这段代码有什么问题:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">prevState<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    streak<span class="token operator">:</span> prevState<span class="token punctuation">.</span>streak <span class="token operator">+</span> props<span class="token punctuation">.</span>count
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>答案：
没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给<code>setState</code>，该函数接收上一个 <code>state</code> 的值和当前的<code>props</code>，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式，并且这种方式来更新状态，在<strong>下一行</strong>可以直接获取更新后的状态。</p> <h3 id="问题-26：什么是-react-context"><a href="#问题-26：什么是-react-context" class="header-anchor">#</a> 问题 26：什么是 React Context</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐⭐</p></blockquote> <p><code>Context</code> 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 <code>props</code> 属性。</p> <h3 id="问题-27：什么是-react-fiber"><a href="#问题-27：什么是-react-fiber" class="header-anchor">#</a> 问题 27：什么是 React Fiber</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐⭐</p></blockquote> <p><strong>Fiber</strong> 是 React 16 中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟 DOM 的<strong>增量渲染</strong>。<code>React Fiber</code> 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。</p> <p><code>React Fiber</code> 的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是<strong>增量渲染</strong>:能够将渲染工作分割成块，并将其分散到多个帧中。</p> <h3 id="问题-28：如何在-reactjs-的-props-上应用验证"><a href="#问题-28：如何在-reactjs-的-props-上应用验证" class="header-anchor">#</a> 问题 28：如何在 ReactJS 的 Props 上应用验证</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐⭐</p></blockquote> <p>当应用程序在开发模式下运行时，React 将自动检查咱们在组件上设置的所有 <code>props</code>，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的 <code>props</code> 用 <code>isRequired</code>定义的。</p> <p>下面是一组预定义的 prop 类型:</p> <ul><li>React.PropTypes.string</li> <li>React.PropTypes.number</li> <li>React.PropTypes.func</li> <li>React.PropTypes.node</li> <li>React.PropTypes.bool</li></ul> <p>例如，咱们为用户组件定义了如下的<code>propTypes</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> PropTypes <span class="token keyword">from</span> <span class="token string">'prop-types'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Welcome<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span>Age<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>age<span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

User<span class="token punctuation">.</span>propTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>string<span class="token punctuation">.</span>isRequired<span class="token punctuation">,</span>
  age<span class="token operator">:</span> PropTypes<span class="token punctuation">.</span>number<span class="token punctuation">.</span>isRequired
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="问题-29：在-react-中使用构造函数和-getinitialstate-有什么区别？"><a href="#问题-29：在-react-中使用构造函数和-getinitialstate-有什么区别？" class="header-anchor">#</a> 问题 29：在 React 中使用构造函数和 getInitialState 有什么区别？</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐⭐</p></blockquote> <p>构造函数和<code>getInitialState</code>之间的区别就是<code>ES6</code>和<code>ES5</code>本身的区别。在使用 ES6 类时，应该在构造函数中初始化<code>state</code>，并在使用<code>React.createClass</code>时定义<code>getInitialState</code>方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token comment">/* initial state */</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>等价于：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">getInitialState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token comment">/* initial state */</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="问题-30：如何有条件地向-react-组件添加属性"><a href="#问题-30：如何有条件地向-react-组件添加属性" class="header-anchor">#</a> 问题 30：如何有条件地向 React 组件添加属性</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐⭐</p></blockquote> <p>对于某些属性，React 非常聪明，如果传递给它的值是虚值(假值)，会<strong>省略</strong>该属性。例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> InputComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> disabled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> disabled<span class="token operator">=</span><span class="token punctuation">{</span>disabled<span class="token punctuation">}</span> required<span class="token operator">=</span><span class="token punctuation">{</span>required<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>渲染结果：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> required<span class="token operator">&gt;</span>
</code></pre></div><p>另一种可能的方法是：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> condition <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> component <span class="token operator">=</span> <span class="token operator">&lt;</span>div value<span class="token operator">=</span><span class="token string">&quot;foo&quot;</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">(</span>condition <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> disabled<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="问题-31：hooks-会取代-render-props-和高阶组件吗"><a href="#问题-31：hooks-会取代-render-props-和高阶组件吗" class="header-anchor">#</a> 问题 31：Hooks 会取代 render props 和高阶组件吗</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐⭐</p></blockquote> <p>通常，<code>render props</code>和高阶组件仅渲染一个子组件。React 团队认为，Hooks 是服务此用例的更简单方法。</p> <p>这两种模式仍然有一席之地(例如，一个虚拟的 <code>scroller</code> 组件可能有一个 <code>renderItem prop</code>，或者一个可视化的容器组件可能有它自己的 DOM 结构)。但在大多数情况下，Hooks 就足够了，可以帮助减少树中的嵌套。</p> <h3 id="问题-32：如何避免组件的重新渲染"><a href="#问题-32：如何避免组件的重新渲染" class="header-anchor">#</a> 问题 32：如何避免组件的重新渲染</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐⭐</p></blockquote> <p>React 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用：</p> <ul><li><p><code>React.memo()</code>:这可以防止不必要地重新渲染函数组件</p></li> <li><p><code>PureComponent</code>:这可以防止不必要地重新渲染类组件</p></li></ul> <p>这两种方法都依赖于对传递给组件的<code>props</code>的<strong>浅比较</strong>，如果 <code>props</code> 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。</p> <p>通过使用 <strong>React Profiler</strong>，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。</p> <h3 id="问题-33：什么是纯函数"><a href="#问题-33：什么是纯函数" class="header-anchor">#</a> 问题 33：什么是纯函数</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐⭐⭐</p></blockquote> <p>纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。也就是说，只要是同样的输入，必定得到同样的输出。</p> <p>纯函数是函数式编程的概念，必须遵守以下一些约束。</p> <ul><li>不得改写参数</li> <li>不能调用系统 I/O 的 API</li> <li>不能调用 Date.now()或者 Math.random()等不纯的方法，因为每次会得到不一样的结果</li></ul> <h3 id="问题-34：当调用-setstate-时，react-render-是如何工作的？"><a href="#问题-34：当调用-setstate-时，react-render-是如何工作的？" class="header-anchor">#</a> 问题 34：当调用 setState 时，React render 是如何工作的？</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐⭐⭐</p></blockquote> <p>咱们可以将&quot;<code>render</code>&quot;分为两个步骤：</p> <ul><li><p>虚拟 DOM 渲染:当<code>render</code>方法被调用时，它返回一个新的组件的虚拟 <code>DOM</code> 结构。当调用<code>setState()</code>时，<code>render</code>会被再次调用，因为默认情况下<code>shouldComponentUpdate</code>总是返回<code>true</code>，所以默认情况下 <code>React</code> 是没有优化的。</p></li> <li><p>原生 DOM 渲染:React 只会在虚拟 DOM 中修改真实 DOM 节点，而且修改的次数非常少——这是很棒的 React 特性，它优化了真实 DOM 的变化，使 React 变得更快。</p></li></ul> <h3 id="问题-35：如何避免在-react-重新绑定实例"><a href="#问题-35：如何避免在-react-重新绑定实例" class="header-anchor">#</a> 问题 35：如何避免在 React 重新绑定实例</h3> <blockquote><p>主题: React
难度: ⭐⭐⭐⭐⭐</p></blockquote> <p>有几种常用方法可以避免在 React 中绑定方法：</p> <p>1.将事件处理程序定义为内联箭头函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">SubmitButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      isFormSubmitted<span class="token operator">:</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>button
        onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> isFormSubmitted<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">}</span>
      <span class="token operator">&gt;</span>
        Submit
      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>2.使用箭头函数来定义方法(<strong>推荐</strong>)：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">SubmitButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    isFormSubmitted<span class="token operator">:</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function-variable function">handleSubmit</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      isFormSubmitted<span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit<span class="token punctuation">}</span><span class="token operator">&gt;</span>Submit<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>3.使用带有 Hooks 的函数组件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">SubmitButton</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isFormSubmitted<span class="token punctuation">,</span> setIsFormSubmitted<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>button
      onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setIsFormSubmitted</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">}</span>
    <span class="token operator">&gt;</span>
      Submit
    <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p><a href="https://github.com/GolderBrother" target="_blank" rel="noopener noreferrer">小菜鸡的 github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, 觉得这篇文章不多的可以给个 <a href="https://github.com/GolderBrother" target="_blank" rel="noopener noreferrer">star<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="最后"><a href="#最后" class="header-anchor">#</a> 最后</h2> <p>文中若有不准确或错误的地方，欢迎指出，有兴趣可以的关注下<a href="https://github.com/GolderBrother" target="_blank" rel="noopener noreferrer">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>~</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2020/9/7 下午8:45:37</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/views/react/react-nice-library.html" class="prev">5 个很棒的 React.js 库，值得你亲手试试！</a></span> <span class="next"><a href="/blog/views/react-native/RN&amp;Native-message.html">React Native 跟原生之间的通信</a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.74817549.js" defer></script><script src="/blog/assets/js/2.f761193d.js" defer></script><script src="/blog/assets/js/172.eeb81923.js" defer></script>
  </body>
</html>
