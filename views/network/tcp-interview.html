<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- 为了可以访问第三方图床的图片，才添加了这句代码，如果你的图片是存在本地的，去掉这句代码即可 -->
    <meta id="referrer" name="referrer" content="never" />
    <!-- <meta id="referrer" name="referrer" content="always" /> -->
    <title>TCP 协议灵魂之问，巩固你的网络底层基础 | 全栈修炼</title>
    <meta name="description" content="GolderBrother的博客" />
    <link rel="icon" href="/blog/assets/favicon.ico">  <link rel="preload" href="/blog/assets/css/0.styles.2dde6c16.css" as="style"><link rel="preload" href="/blog/assets/js/app.74817549.js" as="script"><link rel="preload" href="/blog/assets/js/2.f761193d.js" as="script"><link rel="preload" href="/blog/assets/js/167.044ce06a.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.ea66aff3.js"><link rel="prefetch" href="/blog/assets/js/100.1650309e.js"><link rel="prefetch" href="/blog/assets/js/101.dd5cdc51.js"><link rel="prefetch" href="/blog/assets/js/102.81a755d8.js"><link rel="prefetch" href="/blog/assets/js/103.84d1e041.js"><link rel="prefetch" href="/blog/assets/js/104.6bb79eda.js"><link rel="prefetch" href="/blog/assets/js/105.ac0fa491.js"><link rel="prefetch" href="/blog/assets/js/106.e7f21162.js"><link rel="prefetch" href="/blog/assets/js/107.a932b9dd.js"><link rel="prefetch" href="/blog/assets/js/108.08337848.js"><link rel="prefetch" href="/blog/assets/js/109.0a8ac1ac.js"><link rel="prefetch" href="/blog/assets/js/11.2b17f742.js"><link rel="prefetch" href="/blog/assets/js/110.63f713ce.js"><link rel="prefetch" href="/blog/assets/js/111.3ded28af.js"><link rel="prefetch" href="/blog/assets/js/112.feb77183.js"><link rel="prefetch" href="/blog/assets/js/113.ca7a3dfe.js"><link rel="prefetch" href="/blog/assets/js/114.278aaabb.js"><link rel="prefetch" href="/blog/assets/js/115.3f930fa5.js"><link rel="prefetch" href="/blog/assets/js/116.0686a02f.js"><link rel="prefetch" href="/blog/assets/js/117.22090497.js"><link rel="prefetch" href="/blog/assets/js/118.d7f089fa.js"><link rel="prefetch" href="/blog/assets/js/119.3c8db627.js"><link rel="prefetch" href="/blog/assets/js/12.d4feb8d0.js"><link rel="prefetch" href="/blog/assets/js/120.e516c49a.js"><link rel="prefetch" href="/blog/assets/js/121.d702cc4d.js"><link rel="prefetch" href="/blog/assets/js/122.13d4f773.js"><link rel="prefetch" href="/blog/assets/js/123.6905c46b.js"><link rel="prefetch" href="/blog/assets/js/124.ccac9465.js"><link rel="prefetch" href="/blog/assets/js/125.3fad187d.js"><link rel="prefetch" href="/blog/assets/js/126.065c2aad.js"><link rel="prefetch" href="/blog/assets/js/127.d4aef2ae.js"><link rel="prefetch" href="/blog/assets/js/128.00766f11.js"><link rel="prefetch" href="/blog/assets/js/129.51d245ca.js"><link rel="prefetch" href="/blog/assets/js/13.21c8139a.js"><link rel="prefetch" href="/blog/assets/js/130.82b8009d.js"><link rel="prefetch" href="/blog/assets/js/131.fb8da159.js"><link rel="prefetch" href="/blog/assets/js/132.2484fde1.js"><link rel="prefetch" href="/blog/assets/js/133.177fe1b1.js"><link rel="prefetch" href="/blog/assets/js/134.5611fa2b.js"><link rel="prefetch" href="/blog/assets/js/135.4d1053c3.js"><link rel="prefetch" href="/blog/assets/js/136.2973975f.js"><link rel="prefetch" href="/blog/assets/js/137.7c44ba09.js"><link rel="prefetch" href="/blog/assets/js/138.16973a68.js"><link rel="prefetch" href="/blog/assets/js/139.2f797054.js"><link rel="prefetch" href="/blog/assets/js/14.8cf70ab3.js"><link rel="prefetch" href="/blog/assets/js/140.f94ba770.js"><link rel="prefetch" href="/blog/assets/js/141.69f9800f.js"><link rel="prefetch" href="/blog/assets/js/142.b567c447.js"><link rel="prefetch" href="/blog/assets/js/143.f1ee0ada.js"><link rel="prefetch" href="/blog/assets/js/144.138163b4.js"><link rel="prefetch" href="/blog/assets/js/145.e3bee357.js"><link rel="prefetch" href="/blog/assets/js/146.3a9fd8c7.js"><link rel="prefetch" href="/blog/assets/js/147.0b8e88a6.js"><link rel="prefetch" href="/blog/assets/js/148.81da2cf3.js"><link rel="prefetch" href="/blog/assets/js/149.d44d0121.js"><link rel="prefetch" href="/blog/assets/js/15.ea38d450.js"><link rel="prefetch" href="/blog/assets/js/150.7665d423.js"><link rel="prefetch" href="/blog/assets/js/151.1ab5f781.js"><link rel="prefetch" href="/blog/assets/js/152.620db4ac.js"><link rel="prefetch" href="/blog/assets/js/153.695d756f.js"><link rel="prefetch" href="/blog/assets/js/154.ee82e0a2.js"><link rel="prefetch" href="/blog/assets/js/155.d7bc8987.js"><link rel="prefetch" href="/blog/assets/js/156.95cf0d01.js"><link rel="prefetch" href="/blog/assets/js/157.76159f7e.js"><link rel="prefetch" href="/blog/assets/js/158.e27d7f12.js"><link rel="prefetch" href="/blog/assets/js/159.84d58dcb.js"><link rel="prefetch" href="/blog/assets/js/16.7794197c.js"><link rel="prefetch" href="/blog/assets/js/160.44f17ac0.js"><link rel="prefetch" href="/blog/assets/js/161.a9fc1420.js"><link rel="prefetch" href="/blog/assets/js/162.953ffb8f.js"><link rel="prefetch" href="/blog/assets/js/163.d4b64d04.js"><link rel="prefetch" href="/blog/assets/js/164.d718bdc2.js"><link rel="prefetch" href="/blog/assets/js/165.464562ce.js"><link rel="prefetch" href="/blog/assets/js/166.3486924a.js"><link rel="prefetch" href="/blog/assets/js/168.81e22c48.js"><link rel="prefetch" href="/blog/assets/js/169.4c4a576c.js"><link rel="prefetch" href="/blog/assets/js/17.7083b50c.js"><link rel="prefetch" href="/blog/assets/js/170.4b71dfab.js"><link rel="prefetch" href="/blog/assets/js/171.d2051e87.js"><link rel="prefetch" href="/blog/assets/js/172.eeb81923.js"><link rel="prefetch" href="/blog/assets/js/173.aafb24fa.js"><link rel="prefetch" href="/blog/assets/js/174.2e261a79.js"><link rel="prefetch" href="/blog/assets/js/175.aafd75a2.js"><link rel="prefetch" href="/blog/assets/js/176.b7681070.js"><link rel="prefetch" href="/blog/assets/js/177.e9bdb5f5.js"><link rel="prefetch" href="/blog/assets/js/178.4a3ca305.js"><link rel="prefetch" href="/blog/assets/js/179.40201a86.js"><link rel="prefetch" href="/blog/assets/js/18.3dbb7741.js"><link rel="prefetch" href="/blog/assets/js/180.68c6346e.js"><link rel="prefetch" href="/blog/assets/js/181.326c1f42.js"><link rel="prefetch" href="/blog/assets/js/182.92780c32.js"><link rel="prefetch" href="/blog/assets/js/183.65f40b5a.js"><link rel="prefetch" href="/blog/assets/js/19.78fd69da.js"><link rel="prefetch" href="/blog/assets/js/20.be39648e.js"><link rel="prefetch" href="/blog/assets/js/21.80a318b4.js"><link rel="prefetch" href="/blog/assets/js/22.4040efb3.js"><link rel="prefetch" href="/blog/assets/js/23.dbb39e0a.js"><link rel="prefetch" href="/blog/assets/js/24.f27f8467.js"><link rel="prefetch" href="/blog/assets/js/25.448302be.js"><link rel="prefetch" href="/blog/assets/js/26.78106ffa.js"><link rel="prefetch" href="/blog/assets/js/27.2a65554d.js"><link rel="prefetch" href="/blog/assets/js/28.55501022.js"><link rel="prefetch" href="/blog/assets/js/29.af733838.js"><link rel="prefetch" href="/blog/assets/js/3.df759ff3.js"><link rel="prefetch" href="/blog/assets/js/30.8ce1d72b.js"><link rel="prefetch" href="/blog/assets/js/31.7925ec43.js"><link rel="prefetch" href="/blog/assets/js/32.f9892d98.js"><link rel="prefetch" href="/blog/assets/js/33.afd7fd02.js"><link rel="prefetch" href="/blog/assets/js/34.ee49fe13.js"><link rel="prefetch" href="/blog/assets/js/35.0e4f5335.js"><link rel="prefetch" href="/blog/assets/js/36.96311e99.js"><link rel="prefetch" href="/blog/assets/js/37.fb3163b1.js"><link rel="prefetch" href="/blog/assets/js/38.778ed95b.js"><link rel="prefetch" href="/blog/assets/js/39.0531a2e1.js"><link rel="prefetch" href="/blog/assets/js/4.bb581d32.js"><link rel="prefetch" href="/blog/assets/js/40.ec9153c6.js"><link rel="prefetch" href="/blog/assets/js/41.2e9e71db.js"><link rel="prefetch" href="/blog/assets/js/42.af718b8a.js"><link rel="prefetch" href="/blog/assets/js/43.7a4efaa6.js"><link rel="prefetch" href="/blog/assets/js/44.21916db9.js"><link rel="prefetch" href="/blog/assets/js/45.c02e6427.js"><link rel="prefetch" href="/blog/assets/js/46.c95ab531.js"><link rel="prefetch" href="/blog/assets/js/47.d505fc9f.js"><link rel="prefetch" href="/blog/assets/js/48.9291572a.js"><link rel="prefetch" href="/blog/assets/js/49.79fd5fda.js"><link rel="prefetch" href="/blog/assets/js/5.cc289552.js"><link rel="prefetch" href="/blog/assets/js/50.40ff6888.js"><link rel="prefetch" href="/blog/assets/js/51.d16aa2b4.js"><link rel="prefetch" href="/blog/assets/js/52.4528f49d.js"><link rel="prefetch" href="/blog/assets/js/53.b16b42d4.js"><link rel="prefetch" href="/blog/assets/js/54.4fff7e01.js"><link rel="prefetch" href="/blog/assets/js/55.6832b1c5.js"><link rel="prefetch" href="/blog/assets/js/56.d16f1707.js"><link rel="prefetch" href="/blog/assets/js/57.de08e9ba.js"><link rel="prefetch" href="/blog/assets/js/58.6ca6f21b.js"><link rel="prefetch" href="/blog/assets/js/59.e518317a.js"><link rel="prefetch" href="/blog/assets/js/6.4efa9fa4.js"><link rel="prefetch" href="/blog/assets/js/60.935521f1.js"><link rel="prefetch" href="/blog/assets/js/61.ce9eda13.js"><link rel="prefetch" href="/blog/assets/js/62.e6c745bf.js"><link rel="prefetch" href="/blog/assets/js/63.647fd8d7.js"><link rel="prefetch" href="/blog/assets/js/64.4c9b4781.js"><link rel="prefetch" href="/blog/assets/js/65.80857907.js"><link rel="prefetch" href="/blog/assets/js/66.b89b796a.js"><link rel="prefetch" href="/blog/assets/js/67.b9798c32.js"><link rel="prefetch" href="/blog/assets/js/68.49b67f24.js"><link rel="prefetch" href="/blog/assets/js/69.665837ff.js"><link rel="prefetch" href="/blog/assets/js/7.b94332e9.js"><link rel="prefetch" href="/blog/assets/js/70.ce57ed8e.js"><link rel="prefetch" href="/blog/assets/js/71.71ae5067.js"><link rel="prefetch" href="/blog/assets/js/72.69c7c32d.js"><link rel="prefetch" href="/blog/assets/js/73.6b47b8f7.js"><link rel="prefetch" href="/blog/assets/js/74.bd6cd299.js"><link rel="prefetch" href="/blog/assets/js/75.297a83bc.js"><link rel="prefetch" href="/blog/assets/js/76.e49268ee.js"><link rel="prefetch" href="/blog/assets/js/77.6efa828f.js"><link rel="prefetch" href="/blog/assets/js/78.c38cb032.js"><link rel="prefetch" href="/blog/assets/js/79.478e1642.js"><link rel="prefetch" href="/blog/assets/js/8.80c6038b.js"><link rel="prefetch" href="/blog/assets/js/80.ff9e57e9.js"><link rel="prefetch" href="/blog/assets/js/81.e3dbf4d0.js"><link rel="prefetch" href="/blog/assets/js/82.270df640.js"><link rel="prefetch" href="/blog/assets/js/83.3bc7036f.js"><link rel="prefetch" href="/blog/assets/js/84.a3ccc99e.js"><link rel="prefetch" href="/blog/assets/js/85.7cdab723.js"><link rel="prefetch" href="/blog/assets/js/86.9f0c2ccd.js"><link rel="prefetch" href="/blog/assets/js/87.b7e93260.js"><link rel="prefetch" href="/blog/assets/js/88.557a99bb.js"><link rel="prefetch" href="/blog/assets/js/89.16a0d8d1.js"><link rel="prefetch" href="/blog/assets/js/9.4fbaf7a8.js"><link rel="prefetch" href="/blog/assets/js/90.52190781.js"><link rel="prefetch" href="/blog/assets/js/91.b9507740.js"><link rel="prefetch" href="/blog/assets/js/92.c0eb92c0.js"><link rel="prefetch" href="/blog/assets/js/93.ca3ba1d1.js"><link rel="prefetch" href="/blog/assets/js/94.a8ffcee7.js"><link rel="prefetch" href="/blog/assets/js/95.23fe688e.js"><link rel="prefetch" href="/blog/assets/js/96.b5d64bc6.js"><link rel="prefetch" href="/blog/assets/js/97.c41d4d64.js"><link rel="prefetch" href="/blog/assets/js/98.c415501d.js"><link rel="prefetch" href="/blog/assets/js/99.ab069b22.js"> <link rel="stylesheet" href="/blog/assets/css/0.styles.2dde6c16.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/assets/logo.jpg" alt="全栈修炼" class="logo"> <span class="site-name can-hide">全栈修炼</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/guide/" class="nav-link">主页</a></div><div class="nav-item"><a href="/blog/views/" class="nav-link router-link-active">大前端</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Select language" class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/views/network/tcp-interview.html" class="nav-link router-link-exact-active router-link-active">zh-CN</a></li><li class="dropdown-item"><!----> <a href="/blog/en/" class="nav-link">en-US</a></li></ul></div></div> <a href="https://github.com/GolderBrother/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/guide/" class="nav-link">主页</a></div><div class="nav-item"><a href="/blog/views/" class="nav-link router-link-active">大前端</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Select language" class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/views/network/tcp-interview.html" class="nav-link router-link-exact-active router-link-active">zh-CN</a></li><li class="dropdown-item"><!----> <a href="/blog/en/" class="nav-link">en-US</a></li></ul></div></div> <a href="https://github.com/GolderBrother/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/blog/views/" class="sidebar-link">大前端知识大集合</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>GitHub 软技能</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/github/follow.html" class="sidebar-link">GitHub 挖宝技巧</a></li><li><a href="/blog/views/github/star.html" class="sidebar-link">GitHub 吸星大法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器工作原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/browser/input-url-course.html" class="sidebar-link">导航流程：从输入 URL 到页面展示，这中间发生了什么</a></li><li><a href="/blog/views/browser/dom-bind-event.html" class="sidebar-link">一个DOM元素绑定多个事件时，先执行冒泡还是捕获</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>css</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/css/css-skills1.html" class="sidebar-link">10 个让你受益匪浅的 css 使用技巧</a></li><li><a href="/blog/views/css/css-knowledge.html" class="sidebar-link">你未必知道的 49 个 CSS 知识点</a></li><li><a href="/blog/views/css/css-knowledge2.html" class="sidebar-link">你未必知道的 49 个 CSS 知识点二~</a></li><li><a href="/blog/views/css/css-center.html" class="sidebar-link">一起搞懂 CSS 水平居中与垂直居中的 16 个方法</a></li><li><a href="/blog/views/css/css-flex.html" class="sidebar-link">弹性盒子中 flex: 0 1 auto 表示什么意思</a></li><li><a href="/blog/views/css/css-BFC.html" class="sidebar-link">CSS 中的 BFC 详解</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>移动端h5</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/h5/h5-demo1.html" class="sidebar-link">移动端 H5 和 Hybrid 相关基础技术概览</a></li><li><a href="/blog/views/mobile/mobile-skill.html" class="sidebar-link">总结移动端 H5 开发常用技巧</a></li><li><a href="/blog/views/mobile/mobile-optmization.html" class="sidebar-link">关于移动端体验优化经验总结</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Javascript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/javascript/js-skills.html" class="sidebar-link">你可能不知道的 JS 开发技巧</a></li><li><a href="/blog/views/javascript/js-skills2.html" class="sidebar-link">一个合格的中级前端er需要掌握的 28 个 JavaScript 技巧</a></li><li><a href="/blog/views/javascript/js-utils.html" class="sidebar-link">书到用时方恨少，一大波 JS 开发工具函数来了</a></li><li><a href="/blog/views/javascript/js-utils2.html" class="sidebar-link">前端常用的 60 余种工具方法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Typescript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/typescript/ts-demo.html" class="sidebar-link">TypeScript 高级用法详解</a></li><li><a href="/blog/views/typescript/ts-difficult.html" class="sidebar-link">TypeScript 重难点梳理</a></li><li><a href="/blog/views/typescript/ts-problem.html" class="sidebar-link">TS 常见问题整理（60 多个）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue.js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/vue/vue-ts.html" class="sidebar-link">Vue + TS + El 搭建博客及踩坑记</a></li><li><a href="/blog/views/vue/vue-lazyload.html" class="sidebar-link">vue 路由懒加载及组件懒加载</a></li><li><a href="/blog/views/vue/vue-skills-36.html" class="sidebar-link">Vue 开发必须知道的 36 个技巧</a></li><li><a href="/blog/views/vue/vue-interview.html" class="sidebar-link">30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度）</a></li><li><a href="/blog/views/vue/vue-interview/part-one/note.html" class="sidebar-link">Vue 面试题汇总</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React.js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/react/react-hooks.html" class="sidebar-link">React Hooks 相关 API 总结</a></li><li><a href="/blog/views/react/react-lifecycle.html" class="sidebar-link">React v16.0 前的生命周期</a></li><li><a href="/blog/views/react/react-skill.html" class="sidebar-link">5 个技巧助你编写更好的 React 代码</a></li><li><a href="/blog/views/react/react-nice-library.html" class="sidebar-link">5 个很棒的 React.js 库，值得你亲手试试！</a></li><li><a href="/blog/views/react/react-interview.html" class="sidebar-link">35 道咱们必须要清楚的 React 面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React-Native</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/react-native/RN&amp;Native-message.html" class="sidebar-link">React Native 跟原生之间的通信</a></li><li><a href="/blog/views/react-native/ReactNative&amp;Flutter&amp;uni-app.html" class="sidebar-link">一、技术学习成本和难度</a></li><li><a href="/blog/views/react-native/ReactNative&amp;Flutter&amp;uni-app.html" class="sidebar-link">一、技术学习成本和难度</a></li><li><a href="/blog/views/react-native/codepush-config.html" class="sidebar-link">RN 配置热更新+使用文档</a></li><li><a href="/blog/views/react-native/codepush-deploy.html" class="sidebar-link">React Native + 热更新(Code Push) 部署文档</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/webpack/webpack1.html" class="sidebar-link">一大波 Webpack 面试题来啦~</a></li><li><a href="/blog/views/webpack/webpack-optimize.html" class="sidebar-link">webpack 优化篇</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端跨域相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/cors/corssOrigin-pro.html" class="sidebar-link">10 种跨域解决方案（附终极方案）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>vite</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/vite/vite-study.html" class="sidebar-link">vite原理剖析</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>cli</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/cli/james-cli.html" class="sidebar-link">手撸一个自己的前端脚手架</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Node.js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/node/node1.html" class="sidebar-link">/views/node/node1.html</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端设计模式之美</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/fe-design/fe-design-9.html" class="sidebar-link">前端应知应会的 9 种设计模式(详细篇)</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端数据结构之美</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/data-structure/data-structure.html" class="sidebar-link">前端数据结构之美</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端算法学习指南</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/algorithms/sort.html" class="sidebar-link">十大经典算法</a></li><li><a href="/blog/views/algorithms/interview.html" class="sidebar-link">面试必刷-《剑指 offer》刷题小结</a></li><li><a href="/blog/views/algorithms/string.html" class="sidebar-link">字符串相关算法</a></li><li><a href="/blog/views/algorithms/array.html" class="sidebar-link">数组串相关算法</a></li><li><a href="/blog/views/algorithms/linklist.html" class="sidebar-link">链表相关算法题</a></li><li><a href="/blog/views/algorithms/tree.html" class="sidebar-link">二叉树相关算法</a></li><li><a href="/blog/views/algorithms/tencent/array&amp;string.html" class="sidebar-link">腾讯算法题-数组与字符串</a></li><li><a href="/blog/views/algorithms/tencent/number.html" class="sidebar-link">腾讯算法题-数学与数字</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端面试集锦</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/fe-interview/alibaba.html" class="sidebar-link">阿里面试题</a></li><li><a href="/blog/views/fe-interview/bytedance.html" class="sidebar-link">字节跳动面试题</a></li><li><a href="/blog/views/fe-interview/bytedance-algorithms.html" class="sidebar-link">字节跳动算法题</a></li><li><a href="/blog/views/fe-interview/tencent.html" class="sidebar-link">微信面试题</a></li><li><a href="/blog/views/fe-interview/classic-layout.html" class="sidebar-link">掌握两大经典布局方案</a></li><li><a href="/blog/views/fe-interview/web-safe.html" class="sidebar-link">谈谈 web 安全问题及解决方案</a></li><li><a href="/blog/views/fe-interview/http&amp;https.html" class="sidebar-link">http2/http3 协议有什么优劣</a></li><li><a href="/blog/views/fe-interview/webpack-performance-optimization.html" class="sidebar-link">Webpack 性能优化你知道哪些</a></li><li><a href="/blog/views/fe-interview/webpack-principle.html" class="sidebar-link">说说 webpack 打包的原理</a></li><li><a href="/blog/views/fe-interview/webpack-HMR.html" class="sidebar-link">HMR 的原理是什么</a></li><li><a href="/blog/views/fe-interview/chrome-start-process.html" class="sidebar-link">Chrome 打开一个页面需要启动多少进程？分别有哪些进程</a></li><li><a href="/blog/views/fe-interview/dns-prefetch.html" class="sidebar-link">谈谈你对 dns-prefetch 的理解</a></li><li><a href="/blog/views/fe-interview/browser-cache.html" class="sidebar-link">浏览器缓存一探究竟~</a></li><li><a href="/blog/views/fe-interview/send-content-to-browser.html" class="sidebar-link">如何保证页面文件能被完整送达浏览器</a></li><li><a href="/blog/views/fe-interview/browser-render.html" class="sidebar-link">浏览器渲染过程是怎样的</a></li><li><a href="/blog/views/fe-interview/browser-reflow&amp;repain.html" class="sidebar-link">如何理解回流和重绘</a></li><li><a href="/blog/views/fe-interview/renderEngine-createNewLayer.html" class="sidebar-link">渲染引擎什么情况下才会为特定的节点创建新的图层</a></li><li><a href="/blog/views/fe-interview/UDP&amp;TCP-different.html" class="sidebar-link">UDP 和 TCP 有什么区别</a></li><li><a href="/blog/views/fe-interview/js-modules.html" class="sidebar-link">说说 js 的模块化</a></li><li><a href="/blog/views/fe-interview/lazyMan.html" class="sidebar-link">实现一个 LazyMan，可以按照以下方式调用</a></li><li><a href="/blog/views/fe-interview/handwriting-promise.html" class="sidebar-link">少年，来，手写一个 Promise 吧</a></li><li><a href="/blog/views/fe-interview/fetch&amp;ajax-diference.html" class="sidebar-link">请说下 fetch 和 ajax 的区别吧</a></li><li><a href="/blog/views/fe-interview/browser-input-url.html" class="sidebar-link">细说浏览器输入 URL 后发生了什么</a></li><li><a href="/blog/views/fe-interview/picture-optimization.html" class="sidebar-link">前端的图片优化方案你知道多少</a></li><li><a href="/blog/views/fe-interview/node-eventLoop.html" class="sidebar-link">来，说说 node 的事件循环机制吧</a></li><li><a href="/blog/views/fe-interview/browser-eventLoop.html" class="sidebar-link">小伙子，谈谈浏览器端的事件循环吧</a></li><li><a href="/blog/views/fe-interview/setTimeout&amp;setImmediate.html" class="sidebar-link">node中的setTimeout 和 setImmediate有什么区别</a></li><li><a href="/blog/views/fe-interview/js-interview.html" class="sidebar-link">收集一些 javascript 相关的面试题</a></li><li><a href="/blog/views/fe-interview/fuck-interview.html" class="sidebar-link">那些恶心的面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端必知必会的网络基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/network/http-interview.html" class="sidebar-link">HTTP 灵魂之问，巩固你的 HTTP 知识体系</a></li><li><a href="/blog/views/network/tcp-interview.html" class="active sidebar-link">TCP 协议灵魂之问，巩固你的网络底层基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/views/network/tcp-interview.html#_001-能不能说一说-tcp-和-udp-的区别" class="sidebar-link">001. 能不能说一说 TCP 和 UDP 的区别</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/tcp-interview.html#_002-说说-tcp-三次握手的过程？为什么是三次而不是两次、四次？" class="sidebar-link">002: 说说 TCP 三次握手的过程？为什么是三次而不是两次、四次？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/tcp-interview.html#_003-说说-tcp-四次挥手的过程" class="sidebar-link">003: 说说 TCP 四次挥手的过程</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/tcp-interview.html#_004-说说半连接队列和-syn-flood-攻击的关系" class="sidebar-link">004: 说说半连接队列和 SYN Flood 攻击的关系</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/tcp-interview.html#_005-介绍一下-tcp-报文头部的字段" class="sidebar-link">005: 介绍一下 TCP 报文头部的字段</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/tcp-interview.html#_006-说说-tcp-快速打开的原理-tfo" class="sidebar-link">006: 说说 TCP 快速打开的原理(TFO)</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/tcp-interview.html#_007-能不能说说-tcp-报文中时间戳的作用？" class="sidebar-link">007: 能不能说说 TCP 报文中时间戳的作用？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/tcp-interview.html#_008-tcp-的超时重传时间是如何计算的？" class="sidebar-link">008: TCP 的超时重传时间是如何计算的？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/tcp-interview.html#_009-能不能说一说-tcp-的流量控制？" class="sidebar-link">009: 能不能说一说 TCP 的流量控制？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/tcp-interview.html#_010-能不能说说-tcp-的拥塞控制？" class="sidebar-link">010: 能不能说说 TCP 的拥塞控制？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/tcp-interview.html#_011-能不能说说-nagle-算法和延迟确认？" class="sidebar-link">011: 能不能说说 Nagle 算法和延迟确认？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/tcp-interview.html#_012-如何理解-tcp-的-keep-alive？" class="sidebar-link">012. 如何理解 TCP 的 keep-alive？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/tcp-interview.html#最后" class="sidebar-link">最后</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端应知应会的Nginx知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/nginx/nginx-details.html" class="sidebar-link">Nginx 从入门到实践，万字详解！</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端必不可少的git知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/git/git-command-animation.html" class="sidebar-link">相见恨晚的 Git 命令动画演示，一看就懂！</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端性能优化专题，让你的网站飞起来吧</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/performance/code-split.html" class="sidebar-link">项目不知道如何做性能优化？不妨试试代码分割吧</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端高手进阶专题，告别小菜鸟</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/fe-advanced/ad1.html" class="sidebar-link">你真的熟悉 HTML 标签吗？</a></li><li><a href="/blog/views/fe-advanced/ad2.html" class="sidebar-link">如何高效操作 DOM 元素？</a></li><li><a href="/blog/views/fe-advanced/ad3.html" class="sidebar-link">3 个使用场景助你用好 DOM 事件</a></li><li><a href="/blog/views/fe-advanced/ad6.html" class="sidebar-link">浏览器如何渲染页面？</a></li><li><a href="/blog/views/fe-advanced/ad7.html" class="sidebar-link">关于 JavaScript 的数据类型，你知多少</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="tcp-协议灵魂之问，巩固你的网络底层基础"><a href="#tcp-协议灵魂之问，巩固你的网络底层基础" class="header-anchor">#</a> TCP 协议灵魂之问，巩固你的网络底层基础</h1> <p>先亮出这篇文章的思维导图:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/23/1707236e03d22cbc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="tcp-img"></p> <p>TCP 作为传输层的协议，是一个软件工程师素养的体现，也是面试中经常被问到的知识点。</p> <h2 id="_001-能不能说一说-tcp-和-udp-的区别"><a href="#_001-能不能说一说-tcp-和-udp-的区别" class="header-anchor">#</a> 001. 能不能说一说 TCP 和 UDP 的区别</h2> <p>首先概括一下基本的区别:</p> <p><strong>TCP 是一个面向连接的、可靠的、基于字节流的传输层协议。</strong></p> <p>而 UDP 是一个<strong>面向无连接的传输层协议</strong>。</p> <p>具体来分析，和 <code>UDP</code> 相比，<code>TCP</code> 有三大核心特性:</p> <ol><li><p><strong>面向连接</strong>。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，<code>TCP</code> 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。</p></li> <li><p><strong>可靠性</strong>。<code>TCP</code> 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。</p></li></ol> <p>TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是有<strong>状态</strong>。</p> <p>当意识到丢包了或者网络环境不佳，<code>TCP</code> 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是<strong>可控制</strong>。</p> <p>相应的，<code>UDP</code> 就是<strong>无状态</strong>, <strong>不可控</strong>的。</p> <ol start="3"><li><strong>面向字节流</strong>。<code>UDP</code> 的数据传输是基于数据报的，这是因为仅仅只是继承了 <code>IP</code> 层的特性，而 <code>TCP</code> 为了维护状态，将一个个 <code>IP</code> 包变成了字节流。</li></ol> <h2 id="_002-说说-tcp-三次握手的过程？为什么是三次而不是两次、四次？"><a href="#_002-说说-tcp-三次握手的过程？为什么是三次而不是两次、四次？" class="header-anchor">#</a> 002: 说说 TCP 三次握手的过程？为什么是三次而不是两次、四次？</h2> <h3 id="恋爱模拟"><a href="#恋爱模拟" class="header-anchor">#</a> 恋爱模拟</h3> <p>以谈恋爱为例，两个人能够在一起最重要的事情是首先确认各自爱和被爱的能力。接下来我们以此来模拟三次握手的过程。</p> <p>第一次:</p> <p>男: <strong>我爱你</strong>。</p> <p>女方收到。</p> <p>由此证明男方拥有<strong>爱</strong>的能力。</p> <p>第二次:</p> <p>女: <strong>亲爱的，我收到了你的爱，我也爱你</strong>。</p> <p>男方收到。</p> <p>OK，现在的情况说明，女方拥有<strong>爱</strong>和<strong>被爱</strong>的能力。</p> <p>第三次:</p> <p>男: <strong>哇，我收到了你的爱, 余生都是你(瞬间情绪爆炸，嘤嘤嘤~~)</strong>。</p> <p>女方收到。</p> <p>现在能够保证男方具备<strong>被爱</strong>的能力。</p> <p>由此完整地确认了双方<strong>爱</strong>和<strong>被爱</strong>的能力，两人开始一段甜蜜的爱情。</p> <h3 id="真实握手"><a href="#真实握手" class="header-anchor">#</a> 真实握手</h3> <p>当然刚刚那段属于扯淡，不代表本人价值观，目的是让大家理解整个握手过程的意义，因为两个过程非常相似。对应到 TCP 的三次握手，也是需要确认双方的两样能力: <strong>发送的能力</strong>和<strong>接收的能力</strong>。于是便会有下面的三次握手的过程:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170723de9b8aa08b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>从最开始双方都处于<code>CLOSED</code>状态。然后服务端开始监听某个端口，进入了<code>LISTEN</code>状态。</p> <p><strong>第一次握手</strong>：然后客户端主动发起连接，发送 <code>SYN</code>(向女方表白) , 自己变成了<code>SYN-SENT</code>状态。</p> <p><strong>第二次握手</strong>：服务端接收到，返回<code>SYN</code>(也跟男方表白)和<code>ACK</code>(收到爱，对应客户端发来的 <code>SYN</code>)，自己变成了 <code>SYN-REVD</code>。</p> <p><strong>第三次握手</strong>：之后客户端再发送<code>ACK</code>给服务端(男方收到女方的爱并回应女方)，自己变成了<code>ESTABLISHED</code>状态；服务端收到 <code>ACK</code> 之后(女方收到男方的回应)，也变成了 ESTABLISHED 状态。</p> <p>另外需要提醒你注意的是，从图中可以看出，<code>SYN</code> 是需要消耗一个<strong>序列号</strong>的，下次发送对应的 ACK <strong>序列号</strong>要加 1，为什么呢？只需要记住一个规则:</p> <blockquote><p>凡是需要<strong>对端确认</strong>的，一定消耗<code>TCP报文</code>的序列号。</p></blockquote> <p><code>SYN</code> 需要对端的确认， 而 <code>ACK</code> 并不需要，因此 <code>SYN</code> 消耗一个序列号而 <code>ACK</code> 不需要。</p> <h3 id="为什么不是两次？"><a href="#为什么不是两次？" class="header-anchor">#</a> 为什么不是两次？</h3> <p>根本原因: <strong>无法确认客户端的接收能力</strong>。</p> <p>分析如下:</p> <p>如果是两次，你现在发了 <code>SYN</code> 报文想握手，但是这个包<strong>滞留</strong>在了当前的网络中迟迟没有到达，TCP 以为这是<strong>丢了包</strong>，于是<strong>重传</strong>，两次握手建立好了连接。
看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是<strong>两次握手</strong>，服务端只要接收到然后发送相应的数据包给客户端，就默认建立连接，但是现在客户端已经断开了，无法<strong>确认、回复消息</strong>和<strong>建立连接</strong>了。</p> <p>看到问题的吧，这就带来了<strong>连接资源的浪费</strong>。</p> <p>为什么不是四次？</p> <p>三次握手的目的是确认双方<strong>发送</strong>和<strong>接收</strong>的能力，那四次握手可以嘛？</p> <p>当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。</p> <h3 id="三次握手过程中可以携带数据么？"><a href="#三次握手过程中可以携带数据么？" class="header-anchor">#</a> 三次握手过程中可以携带数据么？</h3> <p>第三次握手的时候，可以<strong>携带</strong>。前两次握手不能<strong>携带数据</strong>。</p> <p>如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中<strong>放大量数据</strong>，那么服务器势必会消耗更多的<strong>时间</strong>和<strong>内存空间</strong>去处理这些数据，增大了服务器被攻击的风险。</p> <p>第三次握手的时候，客户端已经处于 <code>ESTABLISHED</code> 状态，并且已经能够确认服务器的<strong>接收、发送能力正常</strong>，这个时候相对安全了，可以携带数据。</p> <h3 id="同时打开会怎样？"><a href="#同时打开会怎样？" class="header-anchor">#</a> 同时打开会怎样？</h3> <p>如果双方同时发 <code>SYN</code> 报文，状态变化会是怎样的呢？</p> <p>这是一个可能会发生的情况。</p> <p>状态变迁如下:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170723e219f0a415?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>在发送方给接收方发<code>SYN</code>报文的同时，接收方也给发送方发<code>SYN</code>报文，两个人刚上了!</p> <p>发完<code>SYN</code>，两者的状态都变为<code>SYN-SENT</code>(<strong>已发送</strong>)。</p> <p>在各自收到对方的<code>SYN</code>后，两者状态都变为<code>SYN-REVD</code>(<strong>已接收</strong>)。</p> <p>接着会回复对应的<code>ACK + SYN</code>，这个报文在对方接收之后，两者状态一起变为<code>ESTABLISHED</code>。</p> <p>这就是同时打开情况下的状态变迁。</p> <h2 id="_003-说说-tcp-四次挥手的过程"><a href="#_003-说说-tcp-四次挥手的过程" class="header-anchor">#</a> 003: 说说 TCP 四次挥手的过程</h2> <h3 id="过程拆解"><a href="#过程拆解" class="header-anchor">#</a> 过程拆解</h3> <p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170723e5c0e05829?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>刚开始双方处于<code>ESTABLISHED</code>状态。</p> <p>客户端要断开了，向服务器发送 <code>FIN</code> 报文，在 TCP 报文中的位置如下图:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170723e922fbc127?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>发送后客户端变成了<code>FIN-WAIT-1</code>状态。注意, 这时候客户端同时也变成了<code>half-close</code>(半关闭)状态，即无法向服务端发送报文，只能接收。</p> <p>服务端接收后向客户端确认，变成了<code>CLOSED-WAIT</code>状态。</p> <p>客户端接收到了服务端的确认，变成了<code>FIN-WAIT2</code>状态。</p> <p>随后，服务端向客户端发送 <code>FIN</code>，自己进入 <code>LAST-ACK</code> 状态，</p> <p>客户端收到服务端发来的<code>FIN</code>后，自己变成了<code>TIME-WAIT</code>状态，然后发送 <code>ACK</code> 给服务端。</p> <p>注意了，这个时候，客户端需要等待足够长的时间，具体来说，是 2 个 <code>MSL</code>(<code>Maximum Segment Lifetime</code>，<strong>报文最大生存时间</strong>), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 <code>ACK</code> 成功到达，挥手结束，否则客户端重发 <code>ACK</code>。</p> <h3 id="等待-2msl-的意义"><a href="#等待-2msl-的意义" class="header-anchor">#</a> 等待 2MSL 的意义</h3> <p>如果不等待会怎样？</p> <p>如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都<strong>死翘翘</strong>(用完)再启动新的应用。</p> <p>那，照这样说一个 <code>MSL</code> 不就不够了吗，为什么要等待 <code>2 MSL</code>?</p> <ul><li>1 个 <code>MSL</code> 确保四次挥手中主动关闭方最后的 <code>ACK</code> 报文最终能达到对端</li> <li>1 个 <code>MSL</code> 确保对端没有收到 <code>ACK</code> 重传的 <code>FIN</code> 报文可以到达</li></ul> <p>这就是等待 <code>2MSL</code> 的意义。</p> <h3 id="为什么是四次挥手而不是三次？"><a href="#为什么是四次挥手而不是三次？" class="header-anchor">#</a> 为什么是四次挥手而不是三次？</h3> <p>因为服务端在接收到 <code>FIN</code>, 往往不会立即返回 <code>FIN</code>, 必须等到服务端所有的报文都发送完毕了，才能发 <code>FIN</code>。因此先发一个 <code>ACK</code> 表示已经收到客户端的 <code>FIN</code>，延迟一段时间才发 <code>FIN</code>。这就造成了四次挥手。</p> <p>如果是三次挥手会有什么问题？</p> <p>等于说服务端将 <code>ACK</code> 和 <code>FIN</code> 的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为 <code>FIN</code> 没有到达客户端，从而让客户端不断的重发 <code>FIN</code>。</p> <h3 id="同时关闭会怎样？"><a href="#同时关闭会怎样？" class="header-anchor">#</a> 同时关闭会怎样？</h3> <p>如果客户端和服务端同时发送 <code>FIN</code> ，状态会如何变化？如图所示:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170723edeb9e8003?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <h2 id="_004-说说半连接队列和-syn-flood-攻击的关系"><a href="#_004-说说半连接队列和-syn-flood-攻击的关系" class="header-anchor">#</a> 004: 说说半连接队列和 SYN Flood 攻击的关系</h2> <p>三次握手前，服务端的状态从<code>CLOSED</code>变为<code>LISTEN</code>, 同时在内部创建了两个队列：<strong>半连接队列</strong>和<strong>全连接队列</strong>，即 <code>SYN 队列</code>和 <code>ACCEPT 队列</code>。</p> <h3 id="半连接队列"><a href="#半连接队列" class="header-anchor">#</a> 半连接队列</h3> <p>当客户端发送<code>SYN</code>到服务端，服务端收到以后回复<code>ACK</code>和<code>SYN</code>，状态由<code>LISTEN</code>变为<code>SYN_RCVD</code>，此时这个连接就被推入了<strong>SYN 队列</strong>，也就是<strong>半连接队列</strong>。</p> <h3 id="全连接队列"><a href="#全连接队列" class="header-anchor">#</a> 全连接队列</h3> <p>当客户端返回<code>ACK</code>, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 <code>TCP</code> 维护的队列，也就是<strong>全连接队列(Accept Queue)</strong>。</p> <h3 id="syn-flood-攻击原理"><a href="#syn-flood-攻击原理" class="header-anchor">#</a> SYN Flood 攻击原理</h3> <p><code>SYN Flood</code> 属于典型的 <code>DoS/DDoS</code> 攻击。其攻击的原理很简单，就是用客户端在<strong>短时间内伪造大量不存在的 <code>IP</code> 地址</strong>，并向服务端疯狂发送<code>SYN</code>。对于服务端而言，会产生两个危险的后果:</p> <ol><li>处理大量的<code>SYN</code>包并返回对应<code>ACK</code>, 势必有大量连接处于<code>SYN_RCVD</code>状态，从而占满整个<strong>半连接队列</strong>，无法处理正常的请求。</li> <li>由于是不存在的 <code>IP</code>，服务端长时间收不到客户端的 <code>ACK</code>，会导致服务端不断重发数据，直到耗尽服务端的资源。</li></ol> <h3 id="如何应对-syn-flood-攻击？"><a href="#如何应对-syn-flood-攻击？" class="header-anchor">#</a> 如何应对 SYN Flood 攻击？</h3> <ol><li>增加 <code>SYN</code> 连接，也就是增加<strong>半连接队列</strong>的容量。</li> <li>减少 <code>SYN + ACK</code> 重试次数，避免大量的超时重发。</li> <li>利用 <code>SYN Cookie</code> 技术，在服务端接收到<code>SYN</code>后不立即分配连接资源，而是根据这个<code>SYN</code>计算出一个 <code>Cookie</code>，连同第二次握手回复给客户端，在客户端回复 <code>ACK</code> 的时候带上这个 <code>Cookie</code> 值，服务端验证 <code>Cookie</code> 合法之后才分配连接资源。</li></ol> <h2 id="_005-介绍一下-tcp-报文头部的字段"><a href="#_005-介绍一下-tcp-报文头部的字段" class="header-anchor">#</a> 005: 介绍一下 TCP 报文头部的字段</h2> <p>报文头部结构如下(单位为<strong>字节</strong>):</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170723f106ff0306?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>请大家牢记这张图！</p> <h3 id="源端口、目标端口"><a href="#源端口、目标端口" class="header-anchor">#</a> 源端口、目标端口</h3> <p>如何标识唯一标识一个连接？答案是 TCP 连接的<code>四元组</code>——<strong>源 IP、源端口、目标 IP 和目标端口</strong>。</p> <p>那 <code>TCP</code> 报文怎么没有<strong>源 IP</strong> 和<strong>目标 IP</strong> 呢？这是因为在 <code>IP</code> 层就已经处理了 <code>IP</code> <code>。TCP</code> 只需要记录两者的<strong>端口</strong>即可。</p> <h3 id="序列号"><a href="#序列号" class="header-anchor">#</a> 序列号</h3> <p>即<code>Sequence number</code>, 指的是本报文段第一个字节的序列号。</p> <p>从图中可以看出，序列号是一个长为 <code>4 个字节</code>，也就是 <code>32 位</code>的<strong>无符号整数</strong>，表示范围为 <code>0 ~ 2^32 - 1</code>(<code>65535</code>)。如果到达最大值了后就循环到<code>0</code>。</p> <p>序列号在 TCP 通信的过程中有两个作用:</p> <ol><li>在 <code>SYN</code> 报文中交换彼此的<strong>初始序列号</strong>。</li> <li>保证数据包按正确的顺序组装。</li></ol> <h3 id="isn"><a href="#isn" class="header-anchor">#</a> ISN</h3> <p>即 <code>Initial Sequence Number</code>（<strong>初始序列号</strong>）,在三次握手的过程当中，双方会用过 <code>SYN</code>(<strong>发送数据状态</strong>) 报文来交换彼此的 <code>ISN</code>。</p> <p><code>ISN</code> 并<strong>不是一个固定的值</strong>，而是每 <code>4 ms</code> 加一，溢出则回到 <code>0</code>，这个算法使得猜测 <code>ISN</code> 变得很困难。那为什么要这么做？
如果 <code>ISN</code> 被攻击者预测到，要知道源 <code>IP</code> 和<strong>源端口号</strong>都是很容易<strong>伪造</strong>的，当攻击者猜测 <code>ISN</code> 之后，直接<strong>伪造</strong>一个 <code>RST</code> 后，就可以强制连接关闭的，这是非常危险的。
而<strong>动态增长</strong>的 <code>ISN</code> 大大提高了猜测 <code>ISN</code> 的难度。</p> <h3 id="确认号"><a href="#确认号" class="header-anchor">#</a> 确认号</h3> <p>即 <code>ACK</code>(<code>Acknowledgment number</code>)。用来告知对方<strong>下一个期望接收的序列号</strong>，<strong>小于 ACK</strong> 的所有字节<strong>已经全部收到</strong>。</p> <h3 id="标记位"><a href="#标记位" class="header-anchor">#</a> 标记位</h3> <p>常见的标记位有 <code>SYN,ACK,FIN,RST,PSH</code>。
<code>SYN</code> 和 <code>ACK</code> 已经在上文说过，后三个解释如下:</p> <ul><li><code>FIN</code>： 即 <code>Finish</code>，表示<strong>发送方准备断开连接</strong>。</li> <li><code>RST</code>：即 <code>Reset</code>，用来<strong>强制断开连接</strong>。</li> <li><code>PSH</code>： 即 <code>Push</code>, 告知对方这些数据包收到后应该<strong>马上交给上层的应用</strong>，<strong>不能缓存</strong>。</li></ul> <h3 id="窗口大小"><a href="#窗口大小" class="header-anchor">#</a> 窗口大小</h3> <p>占用<strong>两个字节</strong>，也就是 <strong>16 位</strong>，但实际上是不够用的。因此 <code>TCP</code> 引入了<strong>窗口缩放</strong>的选项，作为<strong>窗口缩放</strong>的<strong>比例因子</strong>，这个<strong>比例因子</strong>的范围在 <code>0 ~ 14</code>，<strong>比例因子</strong>可以将窗口的值扩大为原来的 <code>2 ^ n 次方</code>。</p> <h3 id="校验和"><a href="#校验和" class="header-anchor">#</a> 校验和</h3> <p>占用<strong>两个字节</strong>，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，<code>TCP</code> 直接丢弃之，等待<strong>重传</strong>。</p> <h3 id="可选项"><a href="#可选项" class="header-anchor">#</a> 可选项</h3> <p>可选项的格式如下:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170723f4facdfb22?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>常用的可选项有以下几个:</p> <ul><li><code>TimeStamp</code>: <code>TCP</code> 时间戳。</li> <li><code>MSS</code>: 指的是 <code>TCP</code> 允许的从对方接收的<strong>最大报文段</strong>。</li> <li><code>SACK</code>: <strong>选择确认</strong>选项。</li> <li><code>Window Scale</code>: <strong>窗口缩放选项</strong>。</li></ul> <h2 id="_006-说说-tcp-快速打开的原理-tfo"><a href="#_006-说说-tcp-快速打开的原理-tfo" class="header-anchor">#</a> 006: 说说 TCP 快速打开的原理(TFO)</h2> <p>第一节讲了 <code>TCP</code> 三次握手，可能有人会说，每次都三次握手好麻烦呀！能不能优化一点？</p> <p>可以啊。今天来说说这个优化后的 <code>TCP</code> 握手流程，也就是 <code>TCP</code> 快速打开(<code>TCP Fast Open</code>, 即 <code>TFO</code> )的原理。</p> <p>优化的过程是这样的，还记得我们说 <code>SYN Flood</code> 攻击时提到的 <code>SYN Cookie</code> 吗？这个 <code>Cookie</code> 可不是浏览器的 <code>Cookie</code>, 用它同样可以实现 <code>TFO</code> 。</p> <h3 id="tfo-流程"><a href="#tfo-流程" class="header-anchor">#</a> TFO 流程</h3> <h4 id="首轮三次握手"><a href="#首轮三次握手" class="header-anchor">#</a> 首轮三次握手</h4> <p>首先客户端发送 <code>SYN</code> 给服务端，服务端接收到。</p> <p>注意哦！现在服务端不是立即回复 <code>SYN + ACK</code>，而是通过计算得到一个 <code>SYN Cookie</code>, 将这个 <code>Cookie</code> 放到 <code>TCP</code> 报文的 <code>Fast Open</code> 选项中，然后才给客户端返回。</p> <p>客户端拿到这个 <code>Cookie</code> 的值<strong>缓存</strong>下来。后面正常完成<strong>三次握手</strong>。</p> <p>首轮<strong>三次握手</strong>就是这样的流程。而后面的<strong>三次握手</strong>就不一样啦！</p> <h4 id="后面的三次握手"><a href="#后面的三次握手" class="header-anchor">#</a> 后面的三次握手</h4> <p>在后面的三次握手中，客户端会将之前缓存的 <code>Cookie</code>、<code>SYN</code> 和 <code>HTTP 请求</code>(是的，你没看错)发送给服务端，服务端验证了 <code>Cookie</code> 的合法性，如果不合法直接丢弃；如果是合法的，那么就正常返回 <code>SYN + ACK</code>。</p> <p>重点来了，现在服务端能向客户端发 <code>HTTP</code> 响应了！这是最显著的改变，三次握手还没建立，仅仅验证了 <code>Cookie</code> 的合法性，就可以返回 <code>HTTP</code> 响应了。</p> <p>当然了，客户端的 <code>ACK</code> 还得正常传过来，不然怎么叫三次握手嘛</p> <p>具体的流程如下:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170723f9bbfc467d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p><strong>注意</strong>: 客户端最后握手的 <code>ACK</code> 不一定要等到服务端的 <code>HTTP</code> 响应到达才发送，两个过程没有任何关系。</p> <h4 id="tfo-的优势"><a href="#tfo-的优势" class="header-anchor">#</a> TFO 的优势</h4> <p><code>TFO</code> 的优势并不在与首轮三次握手，而在于后面的握手，在拿到客户端的 <code>Cookie</code> 并验证通过以后，可以<strong>直接返回 HTTP 响应</strong>，充分利用了 <strong>1 个 RTT</strong>(<code>Round-Trip Time</code>，<strong>往返时延</strong>)的时间提前进行<strong>数据传输</strong>，积累起来还是一个比较大的优势。</p> <h2 id="_007-能不能说说-tcp-报文中时间戳的作用？"><a href="#_007-能不能说说-tcp-报文中时间戳的作用？" class="header-anchor">#</a> 007: 能不能说说 TCP 报文中时间戳的作用？</h2> <p><code>timestamp</code> 是 <code>TCP</code> 报文首部的一个可选项，一共占 <code>10</code> 个字节，格式如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">kind</span><span class="token punctuation">(</span><span class="token number">1</span> 字节<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token number">1</span> 字节<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token number">8</span> 个字节<span class="token punctuation">)</span>
</code></pre></div><p>其中 <code>kind = 8， length = 10</code>， <code>info</code> 有两部分构成: <code>timestamp</code> 和 <code>timestamp echo</code>，各占 <strong>4 个字节</strong>。</p> <p>那么这些字段都是干嘛的呢？它们用来解决那些问题？</p> <p>接下来我们就来一一梳理，<code>TCP</code> 的时间戳主要解决两大问题:</p> <ul><li>计算往返时延 <code>RTT(Round-Trip Time)</code></li> <li>防止序列号的回绕问题</li></ul> <h3 id="计算往返时延-rtt"><a href="#计算往返时延-rtt" class="header-anchor">#</a> 计算往返时延 RTT</h3> <p>在没有时间戳的时候，计算 RTT 会遇到的问题如下图所示:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/23/170723fdfe450dc8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>如果以第一次发包为开始时间的话，就会出现左图的问题，<code>RTT</code> 明显偏大，开始时间应该采用第二次的；</p> <p>如果以第二次发包为开始时间的话，就会导致右图的问题，<code>RTT</code> 明显偏小，开始时间应该采用第一次发包的。</p> <p>实际上无论开始时间以第一次发包还是第二次发包为准，都是不准确的。</p> <p>那这个时候引入时间戳就很好的解决了这个问题。</p> <p>比如现在 <code>a 向 b</code> 发送一个报文 <code>s1</code>，<code>b 向 a</code> 回复一个含 <code>ACK</code> 的报文 <code>s2</code> 那么：</p> <ul><li><strong>step 1</strong>: <code>a 向 b</code> 发送的时候，<code>timestamp</code> 中存放的内容就是 <code>a 主机</code> 发送时的内核时刻 <code>ta1</code>(<code>比如10:00</code>)。</li> <li><strong>step 2</strong>: <code>b 向 a</code> 回复 <code>s2 报文</code>的时候，<code>timestamp</code> 中存放的是 <code>b 主机</code> 的时刻 <code>tb</code>(<code>比如10:05</code>), <code>timestamp echo</code>字段为从 <code>s1</code> 报文中解析出来的 <code>ta1</code>(<code>比如1000ms</code>) 。</li> <li><strong>step 3</strong>: <code>a</code> 收到 <code>b</code> 的 <code>s2 报文</code>之后，此时 <code>a 主机</code> 的内核时刻是 <code>ta2</code>(<code>比如1010ms</code>), 而在 <code>s2</code> 报文中的 <code>timestamp echo</code> 选项中可以得到 <code>ta1</code>, 也就是 <code>s2</code> 对应的报文最初的发送时刻。然后直接采用 <code>ta2 - ta1</code>(<code>1010-1000</code>) 就得到了 <code>RTT</code>(<code>10ms</code>) 的值。</li></ul> <h3 id="防止序列号回绕问题"><a href="#防止序列号回绕问题" class="header-anchor">#</a> 防止序列号回绕问题</h3> <p>现在我们来模拟一下这个问题。</p> <p>序列号的范围其实是在 <code>0 ~ 2 ^ 32 - 1</code>(<code>0 ~ 65536</code>) , 为了方便演示，我们缩小一下这个区间，假设范围是 <code>0 ~ 4</code>，那么到达 <code>4</code> 的时候会回到 <code>0</code>。</p> <table><thead><tr><th>第几次发包</th> <th>发送字节</th> <th>对应序列号</th> <th>状态</th></tr></thead> <tbody><tr><td>1</td> <td>0~1</td> <td>0~1</td> <td>成功接收</td></tr> <tr><td>2</td> <td>1~2</td> <td>1~2</td> <td>滞留在网络中</td></tr> <tr><td>3</td> <td>2~3</td> <td>2~3</td> <td>成功接收</td></tr> <tr><td>4</td> <td>3~4</td> <td>3~4</td> <td>成功接收</td></tr> <tr><td>5</td> <td>4~5</td> <td>4~5</td> <td>成功接收，序列号从 0 开始</td></tr> <tr><td>6</td> <td>5~6</td> <td>5~6</td> <td>？？</td></tr></tbody></table> <p>假设在<strong>第 6 次</strong>的时候，之前还滞留在网路中的包回来了，那么就有两个序列号为<code>1 ~ 2</code>的数据包了，怎么区分谁是谁呢？这个时候就产生了<strong>序列号回绕</strong>的问题。</p> <p>那么用 <code>timestamp</code> 就能很好地解决这个问题，因为每次发包的时候都是将发包机器当时的内核时间记录在报文中，那么两次发包序列号即使相同，时间戳也不可能相同，这样就能够区分开两个数据包了。</p> <h2 id="_008-tcp-的超时重传时间是如何计算的？"><a href="#_008-tcp-的超时重传时间是如何计算的？" class="header-anchor">#</a> 008: TCP 的超时重传时间是如何计算的？</h2> <p>TCP 具有超时重传机制，即间隔一段时间没有等到数据包的回复时，重传这个数据包。</p> <p>那么这个重传间隔是如何来计算的呢？</p> <p>我们一起来讨论下这个问题</p> <p>这个重传间隔也叫做<strong>超时重传时间</strong>(<code>Retransmission TimeOut</code>, 简称 <code>RTO</code>)，它的计算跟上一节提到的 <code>RTT</code> 密切相关。这里我们将介绍两种主要的方法，一个是<strong>经典</strong>方法，一个是<strong>标准</strong>方法。</p> <h3 id="经典方法"><a href="#经典方法" class="header-anchor">#</a> 经典方法</h3> <p>经典方法引入了一个新的概念——<code>SRTT</code>(<code>Smoothed round trip time</code>，即<strong>平滑往返时间</strong>)，每产生一次新的 <code>RTT</code>. 就根据一定的算法对 <code>SRTT</code> 进行更新，具体而言，计算方式如下(<code>SRTT</code> 初始值为<code>0</code>):</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">SRTT</span> <span class="token operator">=</span> α <span class="token operator">*</span> <span class="token constant">SRTT</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> α<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token constant">RTT</span><span class="token punctuation">;</span>
</code></pre></div><p>其中，<code>α</code> 是<strong>平滑因子</strong>，建议值是 <code>0.8</code>，范围是 <code>0.8 ~ 0.9</code>。</p> <p>拿到 <code>SRTT</code>，我们就可以计算 <code>RTO</code> 的值了:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">RTO</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ubound<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>lbound<span class="token punctuation">,</span> β <span class="token operator">*</span> <span class="token constant">SRTT</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>β</code> 是<strong>加权因子</strong>，一般为<code>1.3 ~ 2.0</code>， <code>lbound</code> 是下界，<code>ubound</code> 是上界。</p> <p>其实这个算法过程还是很简单的，但是也存在一定的局限，就是在 RTT 稳定的地方表现还可以，而在 RTT 变化较大的地方就不行了，因为<strong>平滑因子 α</strong> 的范围是<code>0.8 ~ 0.9</code>, <code>RTT</code> 对于 <code>RTO</code> 的影响太小。</p> <h3 id="标准方法"><a href="#标准方法" class="header-anchor">#</a> 标准方法</h3> <p>为了解决经典方法对于 <code>RTT</code> 变化不敏感的问题，后面又引出了标准方法，也叫<code>Jacobson / Karels</code> 算法。</p> <p>一共有三步。</p> <p><strong>第一步</strong>: 计算 <code>SRTT</code>，公式如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">SRTT</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> α<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token constant">SRTT</span> <span class="token operator">+</span> α <span class="token operator">*</span> <span class="token constant">RTT</span><span class="token punctuation">;</span>
</code></pre></div><p>注意这个时候的 <code>α</code> 跟经典方法中的<code>α</code>取值不一样了，建议值是 <code>1/8</code>，也就是 <code>0.125</code>。</p> <p><strong>第二步</strong>: 计算<code>RTTVAR</code>(<code>round-trip time variation</code>)这个中间变量。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">RTTVAR</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> β<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token constant">RTTVAR</span> <span class="token operator">+</span> β <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">|</span><span class="token constant">RTT</span> <span class="token operator">-</span> <span class="token constant">SRTT</span><span class="token operator">|</span><span class="token punctuation">)</span>
</code></pre></div><p><code>β</code> 建议值为 <code>0.25</code>。这个值是这个算法中出彩的地方，也就是说，它记录了最新的 <code>RTT</code> 与当前 <code>SRTT</code> 之间的差值，给我们在后续感知到 <code>RTT</code> 的变化提供了抓手。</p> <p><strong>第三步</strong>: 计算最终的 <code>RTO</code>:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">RTO</span> <span class="token operator">=</span> µ <span class="token operator">*</span> <span class="token constant">SRTT</span> <span class="token operator">+</span> ∂ <span class="token operator">*</span> <span class="token constant">RTTVAR</span>
</code></pre></div><p><code>µ</code>建议值取<code>1</code>, <code>∂</code>建议值取<code>4</code>。</p> <p>这个公式在 <code>SRTT</code> 的基础上加上了最新 <code>RTT</code> 与它的偏移，从而很好的感知了 <code>RTT</code> 的变化，这种算法下，<code>RTO</code> 与 <code>RTT</code> 变化的差值关系更加密切。</p> <h2 id="_009-能不能说一说-tcp-的流量控制？"><a href="#_009-能不能说一说-tcp-的流量控制？" class="header-anchor">#</a> 009: 能不能说一说 TCP 的流量控制？</h2> <p>对于发送端和接收端而言，TCP 需要把发送的数据放到<strong>发送缓存区</strong>, 将接收的数据放到<strong>接收缓存区</strong>。</p> <p>而流量控制要做的事情，就是在通过<strong>接收缓存区</strong>的大小，<strong>控制发送端的发送</strong>。如果对方的<strong>接收缓存区</strong>满了，就不能再继续发送了。</p> <p>要具体理解流量控制，首先需要了解<strong>滑动窗口</strong>的概念。</p> <h3 id="tcp-滑动窗口"><a href="#tcp-滑动窗口" class="header-anchor">#</a> TCP 滑动窗口</h3> <p>TCP 滑动窗口分为两种: <strong>发送窗口</strong>和<strong>接收窗口</strong>。</p> <h4 id="发送窗口"><a href="#发送窗口" class="header-anchor">#</a> 发送窗口</h4> <p>发送端的滑动窗口结构如下:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/23/17072401c4d59dcb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>其中包含四大部分:</p> <ul><li>已发送且已确认</li> <li>已发送但未确认</li> <li>未发送但可以发送</li> <li>未发送也不可以发送</li></ul> <p>其中有一些重要的概念，我标注在图中:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/23/17072403ff8f9bec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>发送窗口就是图中被框住的范围。<code>SND</code> 即 <code>send</code>, <code>WND</code> 即 <code>window</code>, <code>UNA</code> 即 <code>unacknowledged</code>, 表示未被确认，<code>NXT</code> 即 <code>next</code> , 表示下一个发送的位置。</p> <h4 id="接收窗口"><a href="#接收窗口" class="header-anchor">#</a> 接收窗口</h4> <p>接收端的窗口结构如下:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/23/17072406c803d2c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p><code>REV</code> 即 <code>receive</code>，<code>NXT</code> 表示<strong>下一个接收的位置</strong>，<code>WND</code> 表示<strong>接收窗口大小</strong>。</p> <h3 id="流量控制过程"><a href="#流量控制过程" class="header-anchor">#</a> 流量控制过程</h3> <p>这里我们不用太复杂的例子，以一个最简单的来回来模拟一下流量控制的过程，方便大家理解。
首先双方三次握手，初始化各自的窗口大小，均为 <code>200 个字节</code>。
假如当前发送端给接收端发送 <code>100 个字节</code>，那么此时对于发送端而言，<code>SND.NXT</code> 当然要右移 <code>100 个字节</code>，也就是说当前的<strong>可用窗口</strong>减少了 <code>100 个字节</code>，这很好理解。</p> <p>现在这 <code>100</code> 个到达了<strong>接收端</strong>，被放到<strong>接收端</strong>的<strong>缓冲队列</strong>中。不过此时由于<strong>大量负载</strong>的原因，接收端处理不了这么多字节，只能处理 <code>40 个字节</code>，剩下的 <code>60 个字节</code>被留在了<strong>缓冲队列</strong>中。</p> <p>注意了，此时接收端的情况是处理能力不够用啦，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小 <code>60 个字节</code>，由 <code>200 个字节</code>变成了 <code>140 字节</code>，因为缓冲队列还有 <code>60 个字节</code>没被应用拿走。</p> <p>因此，接收端会在 <code>ACK</code> 的报文首部带上缩小后的滑动窗口 <code>140 个字节</code>，发送端对应地调整发送窗口的大小为 <code>140 个字节</code>。</p> <p>此时对于发送端而言，已经发送且确认的部分增加 <code>40 字节</code>，也就是 <code>SND.UNA</code> <strong>右移</strong> <code>40 个字节</code>，同时<strong>发送窗口</strong>缩小为 <code>140 个字节</code>。</p> <p>这也就是<strong>流量控制</strong>的过程。尽管回合再多，整个控制的过程和原理是一样的。</p> <h2 id="_010-能不能说说-tcp-的拥塞控制？"><a href="#_010-能不能说说-tcp-的拥塞控制？" class="header-anchor">#</a> 010: 能不能说说 TCP 的拥塞控制？</h2> <p>上一节所说的流量控制发生在<strong>发送端</strong>跟<strong>接收端</strong>之间，并没有考虑到整个网络环境的影响，如果说当前网络特别差，特别<strong>容易丢包</strong>，那么发送端就应该注意一些了。而这，也正是拥塞控制需要处理的问题。</p> <p>对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态:</p> <ul><li><strong>拥塞窗口</strong>（Congestion Window，cwnd）</li> <li><strong>慢启动阈值</strong>（Slow Start Threshold，ssthresh）</li></ul> <p>涉及到的算法有这几个:</p> <ul><li>慢启动</li> <li>拥塞避免</li> <li>快速重传和快速恢复</li></ul> <p>接下来，我们就来一一拆解这些状态和算法。首先，从<strong>拥塞窗口</strong>说起。</p> <h3 id="拥塞窗口"><a href="#拥塞窗口" class="header-anchor">#</a> 拥塞窗口</h3> <p><strong>拥塞窗口</strong>（Congestion Window，cwnd）是指<strong>目前自己还能传输的数据量大小</strong>。</p> <p>那么之前介绍了接收窗口的概念，两者有什么区别呢？</p> <ul><li><strong>接收窗口</strong>(rwnd)是<strong>接收端</strong>给的限制</li> <li><strong>拥塞窗口</strong>(cwnd)是<strong>发送端</strong>给的限制</li></ul> <p>限制谁呢？</p> <p>限制的是<strong>发送窗口</strong>的大小。</p> <p>有了这两个窗口，如何来计算<strong>发送窗口</strong>？</p> <div class="language-js extra-class"><pre class="language-js"><code>发送窗口大小 <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>rwnd<span class="token punctuation">,</span> cwnd<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>取两者的<strong>较小值</strong>。而<strong>拥塞控制</strong>，就是来控制<code>cwnd</code>的变化。</p> <h3 id="慢启动"><a href="#慢启动" class="header-anchor">#</a> 慢启动</h3> <p>刚开始进入传输数据的时候，你是不知道现在的网路到底是<strong>稳定</strong>还是<strong>拥堵</strong>的，如果做的太激进，发包太急，那么疯狂丢包，造成雪崩式的网络灾难。</p> <p>因此，拥塞控制首先就是要采用一种保守的算法来慢慢地适应整个网路，这种算法叫<strong>慢启动</strong>。运作过程如下:</p> <ul><li>首先，三次握手，双方宣告自己的接收窗口大小</li> <li>双方初始化自己的<strong>拥塞窗口</strong>(cwnd)大小</li> <li>在开始传输的一段时间，发送端每收到一个 <code>ACK</code>，拥塞窗口大小<strong>加 1</strong>，也就是说，每经过一个 <code>RTT</code>，<code>cwnd</code> 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 <code>ACK</code> 后，<code>cwnd</code> 变为 <code>20</code>，第二轮变为 <code>40</code>，第三轮变为 <code>80</code>，依次类推。</li></ul> <p>难道就这么无止境地翻倍下去？当然不可能。它的阈值叫做<strong>慢启动阈值</strong>，当 <code>cwnd</code> 到达这个阈值之后，好比踩了下刹车，别涨了那么快了，老铁，先 hold 住！</p> <p>在到达阈值后，如何来控制 cwnd 的大小呢？</p> <p>这就是拥塞避免做的事情了。</p> <h3 id="拥塞避免"><a href="#拥塞避免" class="header-anchor">#</a> 拥塞避免</h3> <p>原来每收到一个 <code>ACK</code>，<code>cwnd</code> 加 1，现在到达阈值了，<code>cwnd</code> 只能加这么一点: <code>1 / cwnd</code>。那你仔细算算，一轮 <code>RTT</code> 下来，收到 <code>cwnd</code> 个 <code>ACK</code>(<code>(1 / cwnd) * cwnd = 1</code>), 那最后拥塞窗口的大小 <code>cwnd</code> 总共才增加 1。</p> <p>也就是说，以前一个 <code>RTT</code> 下来，<code>cwnd</code>翻倍，现在<code>cwnd</code>只是增加 1 而已。</p> <p>当然，<strong>慢启动</strong>和<strong>拥塞避免</strong>是一起作用的，是一体的。</p> <h3 id="快速重传和快速恢复"><a href="#快速重传和快速恢复" class="header-anchor">#</a> 快速重传和快速恢复</h3> <h4 id="快速重传"><a href="#快速重传" class="header-anchor">#</a> 快速重传</h4> <p>在 <code>TCP</code> 传输的过程中，如果发生了丢包，即<strong>接收端</strong>发现数据段不是按序到达的时候，<strong>接收端</strong>的处理是<strong>重复发送</strong>之前的 <code>ACK</code>。</p> <p>比如第 5 个包丢了，即使第 6、7 个包到达的<strong>接收端</strong>，<strong>接收端</strong>也一律返回第 4 个包的 <code>ACK</code>。当发送端收到 <code>3 个重复的 ACK</code> 时，意识到丢包了，于是马上进行<strong>重传</strong>，不用等到一个 <code>RTO</code> 的时间到了才重传。</p> <p>这就是<strong>快速重传</strong>，它解决的是是否需要重传的问题。</p> <h4 id="选择性重传"><a href="#选择性重传" class="header-anchor">#</a> 选择性重传</h4> <p>那你可能会问了，既然要重传，那么只重传第 5 个包还是第 5、6、7 个包都重传呢？</p> <p>当然第 6、7 个都已经到达了，<code>TCP</code> 的设计者也不傻，已经传过去干嘛还要传？干脆<strong>记录</strong>一下哪些包到了，哪些没到，<strong>针对性地重传</strong>。</p> <p>在收到发送端的报文后，接收端回复一个 <code>ACK</code> 报文，那么在这个报文首部的可选项中，就可以加上<code>SACK</code>这个属性，通过 <code>left edge</code> 和 <code>right edge</code> 告知发送端已经收到了哪些区间的数据报。因此，即使第 5 个包丢包了，当收到第 6、7 个包之后，接收端依然会告诉发送端，这两个包到了。剩下第 5 个包没到，就<strong>重传</strong>这个包。这个过程也叫做<strong>选择性重传</strong>(SACK，<strong>Selective Acknowledgment</strong>)，它解决的是<strong>如何重传</strong>的问题。</p> <h4 id="快速恢复"><a href="#快速恢复" class="header-anchor">#</a> 快速恢复</h4> <p>当然，发送端收到三次重复 <code>ACK</code> 之后，发现<strong>丢包</strong>，觉得现在的网络已经有些拥塞了，自己会进入<strong>快速恢复</strong>阶段。
在这个阶段，发送端如下改变：</p> <ul><li><strong>拥塞阈值</strong>降低为 <code>cwnd</code> 的一半</li> <li><code>cwnd</code> 的大小变为<strong>拥塞阈值</strong></li> <li><code>cwnd</code> <strong>线性增加</strong></li></ul> <p>以上就是 TCP 拥塞控制的经典算法: <strong>慢启动</strong>、<strong>拥塞避免</strong>、<strong>快速重传</strong>和<strong>快速恢复</strong>。</p> <h2 id="_011-能不能说说-nagle-算法和延迟确认？"><a href="#_011-能不能说说-nagle-算法和延迟确认？" class="header-anchor">#</a> 011: 能不能说说 Nagle 算法和延迟确认？</h2> <h3 id="nagle-算法"><a href="#nagle-算法" class="header-anchor">#</a> Nagle 算法</h3> <p>试想一个场景，发送端不停地给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是<strong>传输的时延消耗</strong>，<code>发送和确认</code>本身也是需要耗时的，频繁的发送接收带来了<strong>巨大的时延</strong>。</p> <p>而<code>避免小包的频繁发送</code>，这就是 <strong>Nagle 算法</strong>要做的事情。</p> <p>具体来说，<strong>Nagle 算法</strong>的规则如下:</p> <ul><li><p>当第一次发送数据时不用等待，就算是 <code>1byte</code> 的小包也立即发送</p></li> <li><p>后面发送满足下面条件之一就可以发了:</p> <ul><li>数据包大小达到最大段大小(<code>Max Segment Size</code>, 即 <code>MSS</code>)</li> <li>之前所有包的 <code>ACK</code> 都已接收到</li></ul></li></ul> <h3 id="延迟确认"><a href="#延迟确认" class="header-anchor">#</a> 延迟确认</h3> <p>试想这样一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？</p> <p><strong>延迟确认</strong>(delayed ack)所做的事情，就是后者，稍稍延迟，然后<strong>合并 ACK</strong>，最后才回复给发送端。TCP 要求这个延迟的时延必须<strong>小于 500ms</strong>，一般操作系统实现都<strong>不会超过 200ms</strong>。</p> <p>不过需要主要的是，有一些场景是不能延迟确认的，收到了就要马上回复:</p> <ul><li>接收到了大于一个 <code>frame</code> 的报文，且需要调整窗口大小</li> <li><code>TCP</code> 处于 <code>quickack</code> 模式（通过 <code>tcp_in_quickack_mode</code> 设置）</li> <li>发现了乱序包</li></ul> <h3 id="两者一起使用会怎样？"><a href="#两者一起使用会怎样？" class="header-anchor">#</a> 两者一起使用会怎样？</h3> <p>前者意味着延迟发，后者意味着延迟接收，会造成更大的延迟，产生性能问题。</p> <h2 id="_012-如何理解-tcp-的-keep-alive？"><a href="#_012-如何理解-tcp-的-keep-alive？" class="header-anchor">#</a> 012. 如何理解 TCP 的 keep-alive？</h2> <p>大家都听说过 <code>http</code> 的 <code>keep-alive</code>, 不过 <code>TCP</code> 层面也是有 <code>keep-alive</code> 机制，而且跟<strong>应用层</strong>不太一样。</p> <p>试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 <code>TCP</code> 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。</p> <p>这个时候就出现了 <code>keep-alive</code>, 它的作用就是<strong>探测对端的连接有没有失效</strong>。</p> <p>在 <code>Linux</code> 下，可以这样查看相关的配置:</p> <div class="language-js extra-class"><pre class="language-js"><code>sudo sysctl <span class="token operator">-</span>a <span class="token operator">|</span> grep keepalive

<span class="token comment">// 每隔 7200 s 检测一次</span>
net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_keepalive_time <span class="token operator">=</span> <span class="token number">7200</span>
<span class="token comment">// 一次最多重传 9 个包</span>
net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_keepalive_probes <span class="token operator">=</span> <span class="token number">9</span>
<span class="token comment">// 每个包的间隔重传间隔 75 s</span>
net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_keepalive_intvl <span class="token operator">=</span> <span class="token number">75</span>
</code></pre></div><p>不过，现状是大部分的应用并没有默认开启 <code>TCP</code> 的 <code>keep-alive</code> 选项，为什么？</p> <p>站在应用的角度:</p> <ul><li><code>7200s</code> 也就是<code>两个小时</code>检测一次，时间太长</li> <li>时间再短一些，也难以体现其设计的初衷, 即<code>检测长时间的死连接</code></li></ul> <p>因此是一个比较尴尬的设计。</p> <h2 id="最后"><a href="#最后" class="header-anchor">#</a> 最后</h2> <p>文中若有不准确或错误的地方，欢迎指出，有兴趣可以的关注下<a href="https://github.com/GolderBrother" target="_blank" rel="noopener noreferrer">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>~</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2020/9/7 下午8:45:37</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/views/network/http-interview.html" class="prev">HTTP 灵魂之问，巩固你的 HTTP 知识体系</a></span> <span class="next"><a href="/blog/views/nginx/nginx-details.html">Nginx 从入门到实践，万字详解！</a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.74817549.js" defer></script><script src="/blog/assets/js/2.f761193d.js" defer></script><script src="/blog/assets/js/167.044ce06a.js" defer></script>
  </body>
</html>
