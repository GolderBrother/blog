<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- 为了可以访问第三方图床的图片，才添加了这句代码，如果你的图片是存在本地的，去掉这句代码即可 -->
    <meta id="referrer" name="referrer" content="never" />
    <!-- <meta id="referrer" name="referrer" content="always" /> -->
    <title>HTTP 灵魂之问，巩固你的 HTTP 知识体系 | 全栈修炼</title>
    <meta name="description" content="GolderBrother的博客" />
    <link rel="icon" href="/blog/assets/favicon.ico">  <link rel="preload" href="/blog/assets/css/0.styles.2dde6c16.css" as="style"><link rel="preload" href="/blog/assets/js/app.74817549.js" as="script"><link rel="preload" href="/blog/assets/js/2.f761193d.js" as="script"><link rel="preload" href="/blog/assets/js/21.80a318b4.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.ea66aff3.js"><link rel="prefetch" href="/blog/assets/js/100.1650309e.js"><link rel="prefetch" href="/blog/assets/js/101.dd5cdc51.js"><link rel="prefetch" href="/blog/assets/js/102.81a755d8.js"><link rel="prefetch" href="/blog/assets/js/103.84d1e041.js"><link rel="prefetch" href="/blog/assets/js/104.6bb79eda.js"><link rel="prefetch" href="/blog/assets/js/105.ac0fa491.js"><link rel="prefetch" href="/blog/assets/js/106.e7f21162.js"><link rel="prefetch" href="/blog/assets/js/107.a932b9dd.js"><link rel="prefetch" href="/blog/assets/js/108.08337848.js"><link rel="prefetch" href="/blog/assets/js/109.0a8ac1ac.js"><link rel="prefetch" href="/blog/assets/js/11.2b17f742.js"><link rel="prefetch" href="/blog/assets/js/110.63f713ce.js"><link rel="prefetch" href="/blog/assets/js/111.3ded28af.js"><link rel="prefetch" href="/blog/assets/js/112.feb77183.js"><link rel="prefetch" href="/blog/assets/js/113.ca7a3dfe.js"><link rel="prefetch" href="/blog/assets/js/114.278aaabb.js"><link rel="prefetch" href="/blog/assets/js/115.3f930fa5.js"><link rel="prefetch" href="/blog/assets/js/116.0686a02f.js"><link rel="prefetch" href="/blog/assets/js/117.22090497.js"><link rel="prefetch" href="/blog/assets/js/118.d7f089fa.js"><link rel="prefetch" href="/blog/assets/js/119.3c8db627.js"><link rel="prefetch" href="/blog/assets/js/12.d4feb8d0.js"><link rel="prefetch" href="/blog/assets/js/120.e516c49a.js"><link rel="prefetch" href="/blog/assets/js/121.d702cc4d.js"><link rel="prefetch" href="/blog/assets/js/122.13d4f773.js"><link rel="prefetch" href="/blog/assets/js/123.6905c46b.js"><link rel="prefetch" href="/blog/assets/js/124.ccac9465.js"><link rel="prefetch" href="/blog/assets/js/125.3fad187d.js"><link rel="prefetch" href="/blog/assets/js/126.065c2aad.js"><link rel="prefetch" href="/blog/assets/js/127.d4aef2ae.js"><link rel="prefetch" href="/blog/assets/js/128.00766f11.js"><link rel="prefetch" href="/blog/assets/js/129.51d245ca.js"><link rel="prefetch" href="/blog/assets/js/13.21c8139a.js"><link rel="prefetch" href="/blog/assets/js/130.82b8009d.js"><link rel="prefetch" href="/blog/assets/js/131.fb8da159.js"><link rel="prefetch" href="/blog/assets/js/132.2484fde1.js"><link rel="prefetch" href="/blog/assets/js/133.177fe1b1.js"><link rel="prefetch" href="/blog/assets/js/134.5611fa2b.js"><link rel="prefetch" href="/blog/assets/js/135.4d1053c3.js"><link rel="prefetch" href="/blog/assets/js/136.2973975f.js"><link rel="prefetch" href="/blog/assets/js/137.7c44ba09.js"><link rel="prefetch" href="/blog/assets/js/138.16973a68.js"><link rel="prefetch" href="/blog/assets/js/139.2f797054.js"><link rel="prefetch" href="/blog/assets/js/14.8cf70ab3.js"><link rel="prefetch" href="/blog/assets/js/140.f94ba770.js"><link rel="prefetch" href="/blog/assets/js/141.69f9800f.js"><link rel="prefetch" href="/blog/assets/js/142.b567c447.js"><link rel="prefetch" href="/blog/assets/js/143.f1ee0ada.js"><link rel="prefetch" href="/blog/assets/js/144.138163b4.js"><link rel="prefetch" href="/blog/assets/js/145.e3bee357.js"><link rel="prefetch" href="/blog/assets/js/146.3a9fd8c7.js"><link rel="prefetch" href="/blog/assets/js/147.0b8e88a6.js"><link rel="prefetch" href="/blog/assets/js/148.81da2cf3.js"><link rel="prefetch" href="/blog/assets/js/149.d44d0121.js"><link rel="prefetch" href="/blog/assets/js/15.ea38d450.js"><link rel="prefetch" href="/blog/assets/js/150.7665d423.js"><link rel="prefetch" href="/blog/assets/js/151.1ab5f781.js"><link rel="prefetch" href="/blog/assets/js/152.620db4ac.js"><link rel="prefetch" href="/blog/assets/js/153.695d756f.js"><link rel="prefetch" href="/blog/assets/js/154.ee82e0a2.js"><link rel="prefetch" href="/blog/assets/js/155.d7bc8987.js"><link rel="prefetch" href="/blog/assets/js/156.95cf0d01.js"><link rel="prefetch" href="/blog/assets/js/157.76159f7e.js"><link rel="prefetch" href="/blog/assets/js/158.e27d7f12.js"><link rel="prefetch" href="/blog/assets/js/159.84d58dcb.js"><link rel="prefetch" href="/blog/assets/js/16.7794197c.js"><link rel="prefetch" href="/blog/assets/js/160.44f17ac0.js"><link rel="prefetch" href="/blog/assets/js/161.a9fc1420.js"><link rel="prefetch" href="/blog/assets/js/162.953ffb8f.js"><link rel="prefetch" href="/blog/assets/js/163.d4b64d04.js"><link rel="prefetch" href="/blog/assets/js/164.d718bdc2.js"><link rel="prefetch" href="/blog/assets/js/165.464562ce.js"><link rel="prefetch" href="/blog/assets/js/166.3486924a.js"><link rel="prefetch" href="/blog/assets/js/167.044ce06a.js"><link rel="prefetch" href="/blog/assets/js/168.81e22c48.js"><link rel="prefetch" href="/blog/assets/js/169.4c4a576c.js"><link rel="prefetch" href="/blog/assets/js/17.7083b50c.js"><link rel="prefetch" href="/blog/assets/js/170.4b71dfab.js"><link rel="prefetch" href="/blog/assets/js/171.d2051e87.js"><link rel="prefetch" href="/blog/assets/js/172.eeb81923.js"><link rel="prefetch" href="/blog/assets/js/173.aafb24fa.js"><link rel="prefetch" href="/blog/assets/js/174.2e261a79.js"><link rel="prefetch" href="/blog/assets/js/175.aafd75a2.js"><link rel="prefetch" href="/blog/assets/js/176.b7681070.js"><link rel="prefetch" href="/blog/assets/js/177.e9bdb5f5.js"><link rel="prefetch" href="/blog/assets/js/178.4a3ca305.js"><link rel="prefetch" href="/blog/assets/js/179.40201a86.js"><link rel="prefetch" href="/blog/assets/js/18.3dbb7741.js"><link rel="prefetch" href="/blog/assets/js/180.68c6346e.js"><link rel="prefetch" href="/blog/assets/js/181.326c1f42.js"><link rel="prefetch" href="/blog/assets/js/182.92780c32.js"><link rel="prefetch" href="/blog/assets/js/183.65f40b5a.js"><link rel="prefetch" href="/blog/assets/js/19.78fd69da.js"><link rel="prefetch" href="/blog/assets/js/20.be39648e.js"><link rel="prefetch" href="/blog/assets/js/22.4040efb3.js"><link rel="prefetch" href="/blog/assets/js/23.dbb39e0a.js"><link rel="prefetch" href="/blog/assets/js/24.f27f8467.js"><link rel="prefetch" href="/blog/assets/js/25.448302be.js"><link rel="prefetch" href="/blog/assets/js/26.78106ffa.js"><link rel="prefetch" href="/blog/assets/js/27.2a65554d.js"><link rel="prefetch" href="/blog/assets/js/28.55501022.js"><link rel="prefetch" href="/blog/assets/js/29.af733838.js"><link rel="prefetch" href="/blog/assets/js/3.df759ff3.js"><link rel="prefetch" href="/blog/assets/js/30.8ce1d72b.js"><link rel="prefetch" href="/blog/assets/js/31.7925ec43.js"><link rel="prefetch" href="/blog/assets/js/32.f9892d98.js"><link rel="prefetch" href="/blog/assets/js/33.afd7fd02.js"><link rel="prefetch" href="/blog/assets/js/34.ee49fe13.js"><link rel="prefetch" href="/blog/assets/js/35.0e4f5335.js"><link rel="prefetch" href="/blog/assets/js/36.96311e99.js"><link rel="prefetch" href="/blog/assets/js/37.fb3163b1.js"><link rel="prefetch" href="/blog/assets/js/38.778ed95b.js"><link rel="prefetch" href="/blog/assets/js/39.0531a2e1.js"><link rel="prefetch" href="/blog/assets/js/4.bb581d32.js"><link rel="prefetch" href="/blog/assets/js/40.ec9153c6.js"><link rel="prefetch" href="/blog/assets/js/41.2e9e71db.js"><link rel="prefetch" href="/blog/assets/js/42.af718b8a.js"><link rel="prefetch" href="/blog/assets/js/43.7a4efaa6.js"><link rel="prefetch" href="/blog/assets/js/44.21916db9.js"><link rel="prefetch" href="/blog/assets/js/45.c02e6427.js"><link rel="prefetch" href="/blog/assets/js/46.c95ab531.js"><link rel="prefetch" href="/blog/assets/js/47.d505fc9f.js"><link rel="prefetch" href="/blog/assets/js/48.9291572a.js"><link rel="prefetch" href="/blog/assets/js/49.79fd5fda.js"><link rel="prefetch" href="/blog/assets/js/5.cc289552.js"><link rel="prefetch" href="/blog/assets/js/50.40ff6888.js"><link rel="prefetch" href="/blog/assets/js/51.d16aa2b4.js"><link rel="prefetch" href="/blog/assets/js/52.4528f49d.js"><link rel="prefetch" href="/blog/assets/js/53.b16b42d4.js"><link rel="prefetch" href="/blog/assets/js/54.4fff7e01.js"><link rel="prefetch" href="/blog/assets/js/55.6832b1c5.js"><link rel="prefetch" href="/blog/assets/js/56.d16f1707.js"><link rel="prefetch" href="/blog/assets/js/57.de08e9ba.js"><link rel="prefetch" href="/blog/assets/js/58.6ca6f21b.js"><link rel="prefetch" href="/blog/assets/js/59.e518317a.js"><link rel="prefetch" href="/blog/assets/js/6.4efa9fa4.js"><link rel="prefetch" href="/blog/assets/js/60.935521f1.js"><link rel="prefetch" href="/blog/assets/js/61.ce9eda13.js"><link rel="prefetch" href="/blog/assets/js/62.e6c745bf.js"><link rel="prefetch" href="/blog/assets/js/63.647fd8d7.js"><link rel="prefetch" href="/blog/assets/js/64.4c9b4781.js"><link rel="prefetch" href="/blog/assets/js/65.80857907.js"><link rel="prefetch" href="/blog/assets/js/66.b89b796a.js"><link rel="prefetch" href="/blog/assets/js/67.b9798c32.js"><link rel="prefetch" href="/blog/assets/js/68.49b67f24.js"><link rel="prefetch" href="/blog/assets/js/69.665837ff.js"><link rel="prefetch" href="/blog/assets/js/7.b94332e9.js"><link rel="prefetch" href="/blog/assets/js/70.ce57ed8e.js"><link rel="prefetch" href="/blog/assets/js/71.71ae5067.js"><link rel="prefetch" href="/blog/assets/js/72.69c7c32d.js"><link rel="prefetch" href="/blog/assets/js/73.6b47b8f7.js"><link rel="prefetch" href="/blog/assets/js/74.bd6cd299.js"><link rel="prefetch" href="/blog/assets/js/75.297a83bc.js"><link rel="prefetch" href="/blog/assets/js/76.e49268ee.js"><link rel="prefetch" href="/blog/assets/js/77.6efa828f.js"><link rel="prefetch" href="/blog/assets/js/78.c38cb032.js"><link rel="prefetch" href="/blog/assets/js/79.478e1642.js"><link rel="prefetch" href="/blog/assets/js/8.80c6038b.js"><link rel="prefetch" href="/blog/assets/js/80.ff9e57e9.js"><link rel="prefetch" href="/blog/assets/js/81.e3dbf4d0.js"><link rel="prefetch" href="/blog/assets/js/82.270df640.js"><link rel="prefetch" href="/blog/assets/js/83.3bc7036f.js"><link rel="prefetch" href="/blog/assets/js/84.a3ccc99e.js"><link rel="prefetch" href="/blog/assets/js/85.7cdab723.js"><link rel="prefetch" href="/blog/assets/js/86.9f0c2ccd.js"><link rel="prefetch" href="/blog/assets/js/87.b7e93260.js"><link rel="prefetch" href="/blog/assets/js/88.557a99bb.js"><link rel="prefetch" href="/blog/assets/js/89.16a0d8d1.js"><link rel="prefetch" href="/blog/assets/js/9.4fbaf7a8.js"><link rel="prefetch" href="/blog/assets/js/90.52190781.js"><link rel="prefetch" href="/blog/assets/js/91.b9507740.js"><link rel="prefetch" href="/blog/assets/js/92.c0eb92c0.js"><link rel="prefetch" href="/blog/assets/js/93.ca3ba1d1.js"><link rel="prefetch" href="/blog/assets/js/94.a8ffcee7.js"><link rel="prefetch" href="/blog/assets/js/95.23fe688e.js"><link rel="prefetch" href="/blog/assets/js/96.b5d64bc6.js"><link rel="prefetch" href="/blog/assets/js/97.c41d4d64.js"><link rel="prefetch" href="/blog/assets/js/98.c415501d.js"><link rel="prefetch" href="/blog/assets/js/99.ab069b22.js"> <link rel="stylesheet" href="/blog/assets/css/0.styles.2dde6c16.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/assets/logo.jpg" alt="全栈修炼" class="logo"> <span class="site-name can-hide">全栈修炼</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/guide/" class="nav-link">主页</a></div><div class="nav-item"><a href="/blog/views/" class="nav-link router-link-active">大前端</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Select language" class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/views/network/http-interview.html" class="nav-link router-link-exact-active router-link-active">zh-CN</a></li><li class="dropdown-item"><!----> <a href="/blog/en/" class="nav-link">en-US</a></li></ul></div></div> <a href="https://github.com/GolderBrother/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/guide/" class="nav-link">主页</a></div><div class="nav-item"><a href="/blog/views/" class="nav-link router-link-active">大前端</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Select language" class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/views/network/http-interview.html" class="nav-link router-link-exact-active router-link-active">zh-CN</a></li><li class="dropdown-item"><!----> <a href="/blog/en/" class="nav-link">en-US</a></li></ul></div></div> <a href="https://github.com/GolderBrother/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/blog/views/" class="sidebar-link">大前端知识大集合</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>GitHub 软技能</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/github/follow.html" class="sidebar-link">GitHub 挖宝技巧</a></li><li><a href="/blog/views/github/star.html" class="sidebar-link">GitHub 吸星大法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器工作原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/browser/input-url-course.html" class="sidebar-link">导航流程：从输入 URL 到页面展示，这中间发生了什么</a></li><li><a href="/blog/views/browser/dom-bind-event.html" class="sidebar-link">一个DOM元素绑定多个事件时，先执行冒泡还是捕获</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>css</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/css/css-skills1.html" class="sidebar-link">10 个让你受益匪浅的 css 使用技巧</a></li><li><a href="/blog/views/css/css-knowledge.html" class="sidebar-link">你未必知道的 49 个 CSS 知识点</a></li><li><a href="/blog/views/css/css-knowledge2.html" class="sidebar-link">你未必知道的 49 个 CSS 知识点二~</a></li><li><a href="/blog/views/css/css-center.html" class="sidebar-link">一起搞懂 CSS 水平居中与垂直居中的 16 个方法</a></li><li><a href="/blog/views/css/css-flex.html" class="sidebar-link">弹性盒子中 flex: 0 1 auto 表示什么意思</a></li><li><a href="/blog/views/css/css-BFC.html" class="sidebar-link">CSS 中的 BFC 详解</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>移动端h5</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/h5/h5-demo1.html" class="sidebar-link">移动端 H5 和 Hybrid 相关基础技术概览</a></li><li><a href="/blog/views/mobile/mobile-skill.html" class="sidebar-link">总结移动端 H5 开发常用技巧</a></li><li><a href="/blog/views/mobile/mobile-optmization.html" class="sidebar-link">关于移动端体验优化经验总结</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Javascript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/javascript/js-skills.html" class="sidebar-link">你可能不知道的 JS 开发技巧</a></li><li><a href="/blog/views/javascript/js-skills2.html" class="sidebar-link">一个合格的中级前端er需要掌握的 28 个 JavaScript 技巧</a></li><li><a href="/blog/views/javascript/js-utils.html" class="sidebar-link">书到用时方恨少，一大波 JS 开发工具函数来了</a></li><li><a href="/blog/views/javascript/js-utils2.html" class="sidebar-link">前端常用的 60 余种工具方法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Typescript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/typescript/ts-demo.html" class="sidebar-link">TypeScript 高级用法详解</a></li><li><a href="/blog/views/typescript/ts-difficult.html" class="sidebar-link">TypeScript 重难点梳理</a></li><li><a href="/blog/views/typescript/ts-problem.html" class="sidebar-link">TS 常见问题整理（60 多个）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue.js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/vue/vue-ts.html" class="sidebar-link">Vue + TS + El 搭建博客及踩坑记</a></li><li><a href="/blog/views/vue/vue-lazyload.html" class="sidebar-link">vue 路由懒加载及组件懒加载</a></li><li><a href="/blog/views/vue/vue-skills-36.html" class="sidebar-link">Vue 开发必须知道的 36 个技巧</a></li><li><a href="/blog/views/vue/vue-interview.html" class="sidebar-link">30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度）</a></li><li><a href="/blog/views/vue/vue-interview/part-one/note.html" class="sidebar-link">Vue 面试题汇总</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React.js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/react/react-hooks.html" class="sidebar-link">React Hooks 相关 API 总结</a></li><li><a href="/blog/views/react/react-lifecycle.html" class="sidebar-link">React v16.0 前的生命周期</a></li><li><a href="/blog/views/react/react-skill.html" class="sidebar-link">5 个技巧助你编写更好的 React 代码</a></li><li><a href="/blog/views/react/react-nice-library.html" class="sidebar-link">5 个很棒的 React.js 库，值得你亲手试试！</a></li><li><a href="/blog/views/react/react-interview.html" class="sidebar-link">35 道咱们必须要清楚的 React 面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React-Native</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/react-native/RN&amp;Native-message.html" class="sidebar-link">React Native 跟原生之间的通信</a></li><li><a href="/blog/views/react-native/ReactNative&amp;Flutter&amp;uni-app.html" class="sidebar-link">一、技术学习成本和难度</a></li><li><a href="/blog/views/react-native/ReactNative&amp;Flutter&amp;uni-app.html" class="sidebar-link">一、技术学习成本和难度</a></li><li><a href="/blog/views/react-native/codepush-config.html" class="sidebar-link">RN 配置热更新+使用文档</a></li><li><a href="/blog/views/react-native/codepush-deploy.html" class="sidebar-link">React Native + 热更新(Code Push) 部署文档</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/webpack/webpack1.html" class="sidebar-link">一大波 Webpack 面试题来啦~</a></li><li><a href="/blog/views/webpack/webpack-optimize.html" class="sidebar-link">webpack 优化篇</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端跨域相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/cors/corssOrigin-pro.html" class="sidebar-link">10 种跨域解决方案（附终极方案）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>vite</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/vite/vite-study.html" class="sidebar-link">vite原理剖析</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>cli</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/cli/james-cli.html" class="sidebar-link">手撸一个自己的前端脚手架</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Node.js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/node/node1.html" class="sidebar-link">/views/node/node1.html</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端设计模式之美</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/fe-design/fe-design-9.html" class="sidebar-link">前端应知应会的 9 种设计模式(详细篇)</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端数据结构之美</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/data-structure/data-structure.html" class="sidebar-link">前端数据结构之美</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端算法学习指南</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/algorithms/sort.html" class="sidebar-link">十大经典算法</a></li><li><a href="/blog/views/algorithms/interview.html" class="sidebar-link">面试必刷-《剑指 offer》刷题小结</a></li><li><a href="/blog/views/algorithms/string.html" class="sidebar-link">字符串相关算法</a></li><li><a href="/blog/views/algorithms/array.html" class="sidebar-link">数组串相关算法</a></li><li><a href="/blog/views/algorithms/linklist.html" class="sidebar-link">链表相关算法题</a></li><li><a href="/blog/views/algorithms/tree.html" class="sidebar-link">二叉树相关算法</a></li><li><a href="/blog/views/algorithms/tencent/array&amp;string.html" class="sidebar-link">腾讯算法题-数组与字符串</a></li><li><a href="/blog/views/algorithms/tencent/number.html" class="sidebar-link">腾讯算法题-数学与数字</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端面试集锦</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/fe-interview/alibaba.html" class="sidebar-link">阿里面试题</a></li><li><a href="/blog/views/fe-interview/bytedance.html" class="sidebar-link">字节跳动面试题</a></li><li><a href="/blog/views/fe-interview/bytedance-algorithms.html" class="sidebar-link">字节跳动算法题</a></li><li><a href="/blog/views/fe-interview/tencent.html" class="sidebar-link">微信面试题</a></li><li><a href="/blog/views/fe-interview/classic-layout.html" class="sidebar-link">掌握两大经典布局方案</a></li><li><a href="/blog/views/fe-interview/web-safe.html" class="sidebar-link">谈谈 web 安全问题及解决方案</a></li><li><a href="/blog/views/fe-interview/http&amp;https.html" class="sidebar-link">http2/http3 协议有什么优劣</a></li><li><a href="/blog/views/fe-interview/webpack-performance-optimization.html" class="sidebar-link">Webpack 性能优化你知道哪些</a></li><li><a href="/blog/views/fe-interview/webpack-principle.html" class="sidebar-link">说说 webpack 打包的原理</a></li><li><a href="/blog/views/fe-interview/webpack-HMR.html" class="sidebar-link">HMR 的原理是什么</a></li><li><a href="/blog/views/fe-interview/chrome-start-process.html" class="sidebar-link">Chrome 打开一个页面需要启动多少进程？分别有哪些进程</a></li><li><a href="/blog/views/fe-interview/dns-prefetch.html" class="sidebar-link">谈谈你对 dns-prefetch 的理解</a></li><li><a href="/blog/views/fe-interview/browser-cache.html" class="sidebar-link">浏览器缓存一探究竟~</a></li><li><a href="/blog/views/fe-interview/send-content-to-browser.html" class="sidebar-link">如何保证页面文件能被完整送达浏览器</a></li><li><a href="/blog/views/fe-interview/browser-render.html" class="sidebar-link">浏览器渲染过程是怎样的</a></li><li><a href="/blog/views/fe-interview/browser-reflow&amp;repain.html" class="sidebar-link">如何理解回流和重绘</a></li><li><a href="/blog/views/fe-interview/renderEngine-createNewLayer.html" class="sidebar-link">渲染引擎什么情况下才会为特定的节点创建新的图层</a></li><li><a href="/blog/views/fe-interview/UDP&amp;TCP-different.html" class="sidebar-link">UDP 和 TCP 有什么区别</a></li><li><a href="/blog/views/fe-interview/js-modules.html" class="sidebar-link">说说 js 的模块化</a></li><li><a href="/blog/views/fe-interview/lazyMan.html" class="sidebar-link">实现一个 LazyMan，可以按照以下方式调用</a></li><li><a href="/blog/views/fe-interview/handwriting-promise.html" class="sidebar-link">少年，来，手写一个 Promise 吧</a></li><li><a href="/blog/views/fe-interview/fetch&amp;ajax-diference.html" class="sidebar-link">请说下 fetch 和 ajax 的区别吧</a></li><li><a href="/blog/views/fe-interview/browser-input-url.html" class="sidebar-link">细说浏览器输入 URL 后发生了什么</a></li><li><a href="/blog/views/fe-interview/picture-optimization.html" class="sidebar-link">前端的图片优化方案你知道多少</a></li><li><a href="/blog/views/fe-interview/node-eventLoop.html" class="sidebar-link">来，说说 node 的事件循环机制吧</a></li><li><a href="/blog/views/fe-interview/browser-eventLoop.html" class="sidebar-link">小伙子，谈谈浏览器端的事件循环吧</a></li><li><a href="/blog/views/fe-interview/setTimeout&amp;setImmediate.html" class="sidebar-link">node中的setTimeout 和 setImmediate有什么区别</a></li><li><a href="/blog/views/fe-interview/js-interview.html" class="sidebar-link">收集一些 javascript 相关的面试题</a></li><li><a href="/blog/views/fe-interview/fuck-interview.html" class="sidebar-link">那些恶心的面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端必知必会的网络基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/network/http-interview.html" class="active sidebar-link">HTTP 灵魂之问，巩固你的 HTTP 知识体系</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#_001-http-报文结构是怎样的？" class="sidebar-link">001. HTTP 报文结构是怎样的？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#_002-如何理解-http-的请求方法？" class="sidebar-link">002. 如何理解 HTTP 的请求方法？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#_004-如何理解-http-状态码？" class="sidebar-link">004: 如何理解 HTTP 状态码？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#_005-简要概括一下-http-的特点？http-有哪些缺点？" class="sidebar-link">005: 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#_006-对-accept-系列字段了解多少？" class="sidebar-link">006: 对 Accept 系列字段了解多少？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#_007-对于定长和不定长的数据，http-是怎么传输的？" class="sidebar-link">007: 对于定长和不定长的数据，HTTP 是怎么传输的？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#_008-http-如何处理大文件的传输？" class="sidebar-link">008: HTTP 如何处理大文件的传输？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#_009-http-中如何处理表单数据的提交？" class="sidebar-link">009: HTTP 中如何处理表单数据的提交？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#_010-http1-1-如何解决-http-的队头阻塞问题？" class="sidebar-link">010: HTTP1.1 如何解决 HTTP 的队头阻塞问题？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#_011-对-cookie-了解多少？" class="sidebar-link">011: 对 Cookie 了解多少？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#cookie-的缺点" class="sidebar-link">Cookie 的缺点</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#_014-什么是跨域？浏览器如何拦截响应？如何解决？" class="sidebar-link">014: 什么是跨域？浏览器如何拦截响应？如何解决？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#_015-tls1-2-握手的过程是怎样的？" class="sidebar-link">015: TLS1.2 握手的过程是怎样的？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#_017-http-2-有哪些改进？" class="sidebar-link">017: HTTP/2 有哪些改进？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#_018-http-2-中的二进制帧是如何设计的？" class="sidebar-link">018: HTTP/2 中的二进制帧是如何设计的？</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#http-3-新特性" class="sidebar-link">HTTP/3 新特性</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#参考资料" class="sidebar-link">参考资料</a></li><li class="sidebar-sub-header"><a href="/blog/views/network/http-interview.html#最后" class="sidebar-link">最后</a></li></ul></li><li><a href="/blog/views/network/tcp-interview.html" class="sidebar-link">TCP 协议灵魂之问，巩固你的网络底层基础</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端应知应会的Nginx知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/nginx/nginx-details.html" class="sidebar-link">Nginx 从入门到实践，万字详解！</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端必不可少的git知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/git/git-command-animation.html" class="sidebar-link">相见恨晚的 Git 命令动画演示，一看就懂！</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端性能优化专题，让你的网站飞起来吧</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/performance/code-split.html" class="sidebar-link">项目不知道如何做性能优化？不妨试试代码分割吧</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端高手进阶专题，告别小菜鸟</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/fe-advanced/ad1.html" class="sidebar-link">你真的熟悉 HTML 标签吗？</a></li><li><a href="/blog/views/fe-advanced/ad2.html" class="sidebar-link">如何高效操作 DOM 元素？</a></li><li><a href="/blog/views/fe-advanced/ad3.html" class="sidebar-link">3 个使用场景助你用好 DOM 事件</a></li><li><a href="/blog/views/fe-advanced/ad6.html" class="sidebar-link">浏览器如何渲染页面？</a></li><li><a href="/blog/views/fe-advanced/ad7.html" class="sidebar-link">关于 JavaScript 的数据类型，你知多少</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="http-灵魂之问，巩固你的-http-知识体系"><a href="#http-灵魂之问，巩固你的-http-知识体系" class="header-anchor">#</a> HTTP 灵魂之问，巩固你的 HTTP 知识体系</h1> <p>为了帮助大家树立完整的 HTTP 知识体系，并达到一定的深度，从容地应对各种灵魂之问，也同时提升自己作为一个 web 开发的专业素养吧。这是本文的思维导图</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/23/17104ea1fdee5669?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <h2 id="_001-http-报文结构是怎样的？"><a href="#_001-http-报文结构是怎样的？" class="header-anchor">#</a> 001. HTTP 报文结构是怎样的？</h2> <p>对于 <strong>TCP</strong> 而言，在传输的时候分为两个部分:<strong>TCP 头</strong>和<strong>数据部分</strong>。</p> <p>而 <strong>HTTP</strong> 类似，也是<code>header + body</code>的结构，具体而言:</p> <div class="language- extra-class"><pre class="language-text"><code>起始行 + 头部 + 空行 + 实体
</code></pre></div><p>由于 http <strong>请求报文</strong>和<strong>响应报文</strong>是有一定区别，因此我们分开介绍。</p> <h3 id="起始行"><a href="#起始行" class="header-anchor">#</a> 起始行</h3> <p>对于请求报文来说，起始行类似下面这样:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">GET</span> <span class="token operator">/</span>home <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
</code></pre></div><p>也就是<strong>方法 + 路径 + http 版本</strong>。</p> <p>对于响应报文来说，起始行一般长这个样:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> <span class="token constant">OK</span>
</code></pre></div><p>响应报文的起始行也叫做<strong>状态行</strong>。由<strong>http 协议版本、状态码和描述</strong>三部分组成。
其中协议版本<code>HTTP/1.1</code>或者<code>HTTP/1.0</code>，<code>200</code>就是它的<strong>状态码</strong>，<code>OK</code>则为它的<strong>描述</strong>。</p> <p>值得注意的是，在起始行中，每两个部分之间用<strong>空格</strong>隔开，最后一个部分后面应该接一个<strong>换行</strong>，严格遵循<code>ABNF</code>语法规范。</p> <h3 id="头部"><a href="#头部" class="header-anchor">#</a> 头部</h3> <p>展示一下请求头和响应头在报文中的位置:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffd6012e2fc88?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到<code>http</code>非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：</p> <ul><li>字段名不区分大小写</li> <li>字段名不允许出现<strong>空格</strong>，不可以出现下划线<code>_</code></li> <li>字段名后面必须紧接着<code>:</code></li></ul> <h3 id="空行"><a href="#空行" class="header-anchor">#</a> 空行</h3> <p>很重要，用来区分开<strong>头部</strong>和<strong>实体</strong>。</p> <p>问: 如果说在头部中间故意加一个空行会怎么样？</p> <p>那么空行后的内容全部被视为<strong>实体</strong>。</p> <h3 id="实体"><a href="#实体" class="header-anchor">#</a> 实体</h3> <p>就是具体的数据了，也就是<code>body</code>部分。请求报文对应<strong>请求体</strong>, 响应报文对应<strong>响应体</strong>。</p> <h2 id="_002-如何理解-http-的请求方法？"><a href="#_002-如何理解-http-的请求方法？" class="header-anchor">#</a> 002. 如何理解 HTTP 的请求方法？</h2> <h3 id="有哪些请求方法？"><a href="#有哪些请求方法？" class="header-anchor">#</a> 有哪些请求方法？</h3> <p><code>http/1.1</code>规定了以下请求方法(注意，都是<strong>大写</strong>):</p> <ul><li><code>GET</code>: 通常用来获取资源</li> <li><code>HEAD</code>: 获取资源的元信息</li> <li><code>POST</code>: 提交数据，即上传数据</li> <li><code>PUT</code>: 修改数据</li> <li><code>DELETE</code>: 删除资源(几乎用不到)</li> <li><code>CONNECT</code>: 建立连接隧道，用于代理服务器</li> <li><code>OPTIONS</code>: 列出可对资源实行的请求方法，用于客户端试探服务端是否能接受真正的请求</li> <li><code>TRACE</code>: 追踪请求-响应的传输路径</li> <li><code>PATCH</code>: 是对 PUT 方法的补充，用来对已知资源进行局部更新 。</li></ul> <h3 id="get-和-post-有什么区别？"><a href="#get-和-post-有什么区别？" class="header-anchor">#</a> GET 和 POST 有什么区别？</h3> <p>首先最直观的是<strong>语义</strong>上的区别。</p> <p>而后又有这样一些具体的差别:</p> <ul><li>从<strong>缓存</strong>的角度:
<ul><li>GET 请求会被浏览器主动缓存下来，留下历史记录，而 <code>POST</code> 默认不会。</li> <li>GET 请求参数会被保留在浏览器历史记录里，而 POST 中的参数不会被保留。</li></ul></li> <li>从<strong>编码</strong>的角度，GET 只能进行 <code>URL</code> 编码，只能接收 <code>ASCII</code> 字符，而 <code>POST</code> 没有限制, 支持多种编码方式。</li> <li>从<strong>参数</strong>的角度
<ul><li>GET 一般放在 <code>URL</code> 中，因此不安全，<code>POST</code> 放在请求体中，更适合传输敏感信息。</li> <li>GET 请求在<code>URL</code> 中传送的参数是有长度限制的，而<code>POST</code>没有, 实际上是大部分浏览器都会限制<code>url</code>长度在<code>2K</code>个字节</li></ul></li> <li>从<strong>幂等性</strong>的角度，GET 是幂等的，而<code>POST</code>不是。(幂等表示执行相同的操作，结果也是相同的)</li> <li>从<strong>TCP</strong>的角度，GET 请求会把请求报文一次性发出去，而 <code>POST</code> 会分为两个 <code>TCP</code> 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 <code>body</code> 部分。(火狐浏览器除外，它的 POST 请求只发一个 <code>TCP</code> 包)</li></ul> <h3 id="_003-如何理解-uri？"><a href="#_003-如何理解-uri？" class="header-anchor">#</a> 003: 如何理解 URI？</h3> <p><strong>URI</strong>, 全称为(<code>Uniform Resource Identifier</code>), 也就是<strong>统一资源标识符</strong>，它的作用很简单，就是区分<strong>互联网上不同的资源</strong>。</p> <p>但是，它并不是我们常说的网址, 网址指的是<code>URL</code>, 实际上<code>URI</code>包含了<code>URN</code>和<code>URL</code>两个部分，由于 <code>URL</code> 过于普及，就默认将 <code>URI</code> 视为 <code>URL</code> 了。</p> <h4 id="uri-的结构"><a href="#uri-的结构" class="header-anchor">#</a> URI 的结构</h4> <p>URI 真正最完整的结构是这样的。</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffd677629b70d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>我们来一一拆解分析这个结构</p> <p><code>scheme</code> 表示<strong>协议名</strong>，比如<code>http, https, file, rtsp, rtmp</code>等等。后面必须和<code>://</code>连在一起。</p> <p><code>user:passwd@</code> 表示登录主机时的<strong>用户信息</strong>，不过很不安全，不推荐使用，也不常用。</p> <p><code>host:port</code>表示<strong>主机名</strong>和<strong>端口</strong>。</p> <p><code>path</code>表示<strong>请求路径</strong>，标记资源所在位置。</p> <p><code>query</code>表示<strong>查询参数</strong>，为 <code>key=val</code> 这种形式，多个键值对之间用<code>&amp;</code>隔开。比如 <code>wd=http&amp;rsv_spt=1&amp;rsv_iqid=0xe4c8526f0004bf6d&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2</code></p> <p><code>fragment</code>表示 <code>URI</code> 所定位的资源内的一个<strong>锚点</strong>，浏览器可以根据这个<strong>锚点</strong>跳转到对应的位置。</p> <p>举个栗子:</p> <div class="language-js extra-class"><pre class="language-js"><code>https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token operator">/</span>s<span class="token operator">?</span>wd<span class="token operator">=</span>http<span class="token operator">&amp;</span>rsv_spt<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>rsv_iqid<span class="token operator">=</span><span class="token number">0xe4c8526f0004bf6d</span><span class="token operator">&amp;</span>issp<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>f<span class="token operator">=</span><span class="token number">8</span><span class="token operator">&amp;</span>rsv_bp<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&amp;</span>rsv_idx<span class="token operator">=</span><span class="token number">2</span>
</code></pre></div><p>上面这个 <code>URI</code> 中，<code>https</code>即<code>scheme</code>(<strong>协议</strong>)部分，<code>www.baidu.com</code>为<code>host:port</code>(<strong>主机名:端口</strong>)部分（注意，<code>http</code> 和 <code>https</code> 的默认端口分别为<code>80、443</code>），<code>/s</code>为<code>path</code>(<strong>请求路径</strong>)部分，而<code>wd=http&amp;rsv_spt=1&amp;rsv_iqid=0xe4c8526f0004bf6d&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2</code>就是<code>query</code>(<strong>查询参数</strong>)部分。</p> <h3 id="uri-编码"><a href="#uri-编码" class="header-anchor">#</a> URI 编码</h3> <p><code>URI</code> 只能使用<code>ASCII</code>, <code>ASCII</code> 之外的字符是不支持显示的，而且还有一部分符号是<strong>界定符</strong>，如果不加以处理就会导致解析出错。</p> <p>因此，<code>URI</code> 引入了<strong>编码</strong>机制，将所有非 <code>ASCII</code> 码字符和<strong>界定符</strong>转为<strong>十六进制字节值</strong>，然后在前面加个<code>%</code>。</p> <p>如，<strong>空格</strong>被转义成了<code>%20</code>，<strong>神哥</strong>被转义成了<code>%E7%A5%9E%E5%93%A5</code>。</p> <p>可以直接使用<code>encodeURI</code>或者<code>encodeURIComponent</code>方法对<strong>整个 URI</strong>或者<strong>URI 中的某一段</strong>进行<strong>编码</strong></p> <p>我们来看下面的栗子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> uri <span class="token operator">=</span> <span class="token string">'https://www.baidu.com/s?wd=http&amp;rsv_spt=1&amp;rsv_iqid=0xdca1d90b00033d32 '</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">encodeURI</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// https://www.baidu.com/s?wd=http&amp;rsv_spt=1&amp;rsv_iqid=0xdca1d90b00033d32%20</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// https%3A%2F%2Fwww.baidu.com%2Fs%3Fwd%3Dhttp%26rsv_spt%3D1%26rsv_iqid%3D0xdca1d90b00033d32%20</span>
</code></pre></div><p><code>encodeURI</code>和<code>encodeURIComponent</code>的区别</p> <ul><li><code>encodeURI()</code>不会对本身属于<code>URI</code>的特殊字符进行编码，例如<code>冒号、正斜杠、问号和井字号</code>；而<code>encodeURIComponent()</code>则会对它发现的<strong>任何非标准字符</strong>进行编码</li> <li>使用<code>encodeURI()</code>编码后的结果是<strong>除了空格之外的其他字符</strong>都原封不动，只有空格被替换成了<code>%20</code>。而<code>encodeURIComponent()</code>方法则会使用对应的编码替换<strong>所有非字母数字字符</strong></li></ul> <p>这也正是可以对整个<code>URI</code>使用<code>encodeURI()</code>，而只能对附加在现有 URI 后面的字符串使用<code>encodeURIComponent()</code>的原因所在。一般来说,我们使用<code>encodeURIComponent()</code>方法的时候要比使用<code>encodeURI()</code>更多,因为在实践中更常见的是对查询字符串参数而不是对基础 URL 进行编码.
经我的观测，很多网站的<code>cookie</code>在进行编码的时候，是<code>encodeURIComponent</code>格式的，所以应该使用<code>decodeURIComponent</code>进行解码</p> <h2 id="_004-如何理解-http-状态码？"><a href="#_004-如何理解-http-状态码？" class="header-anchor">#</a> 004: 如何理解 HTTP 状态码？</h2> <p><code>RFC</code> 规定 <code>HTTP</code> 的状态码为<strong>三位数</strong>，被分为五类:</p> <ul><li>1xx: 表示目前是协议处理的<strong>中间状态</strong>，还<strong>需要后续</strong>操作。</li> <li>2xx: 表示<strong>请求成功</strong>状态。</li> <li>3xx: <strong>重定向</strong>状态，资源位置发生变动，需要重新请求。</li> <li>4xx: <strong>请求报文有误</strong>。</li> <li>5xx: <strong>服务器发生错误</strong>。</li></ul> <p>接下来我们就一一分析这里面具体的状态码。</p> <h3 id="_1xx"><a href="#_1xx" class="header-anchor">#</a> 1xx</h3> <p><strong>101 Switching Protocols</strong>。切换到新的 HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。比如在<code>HTTP</code>升级为<code>WebSocket</code>的时候，如果服务器同意变更，就会发送状态码 101。</p> <h3 id="_2xx"><a href="#_2xx" class="header-anchor">#</a> 2xx</h3> <p><strong>200 OK</strong> 是见得最多的成功状态码。通常在响应体中放有数据。</p> <p><strong>204 No Content</strong>: 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息, 含义与 <code>200</code> 相同，但响应头后没有 <strong>body</strong> 数据。</p> <p><strong>206 Partial Content</strong>: 顾名思义，表示部分内容，它的使用场景为 <strong>HTTP 分块下载</strong>和<strong>断点续传</strong>，当然也会带上相应的响应头字段<code>Content-Range</code>。</p> <h3 id="_3xx"><a href="#_3xx" class="header-anchor">#</a> 3xx</h3> <p><strong>301 Moved Permanently</strong>: 被请求的资源已永久移动到新位置，即<strong>永久重定向</strong>，对应着<code>302 Found</code>，即<strong>临时重定向</strong>。</p> <p>比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回 301，这个时候浏览器默认会做<strong>缓存优化</strong>，在第二次访问的时候自动访问重定向的那个地址。
而如果只是暂时不可用，那么直接返回 302 即可，和 301 不同的是，浏览器并不会做缓存优化。</p> <p><strong>304 Not Modified</strong>: 当<strong>协商缓存命中</strong>时会返回这个状态码。详见<a href="https://golderbrother.github.io/blog/views/fe-interview/browser-cache.html" target="_blank" rel="noopener noreferrer">浏览器缓存一探究竟~<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_4xx"><a href="#_4xx" class="header-anchor">#</a> 4xx</h3> <p><strong>400 Bad Request</strong>: <strong>语义有误</strong>或者<strong>请求参数有误</strong>, 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。</p> <p><strong>401 Unauthorized</strong>: 当前请求<strong>需要用户验证</strong>, 表示发送的请求需要有通过 <strong>HTTP 认证</strong>的认证信息</p> <p><strong>403 Forbidden</strong>: 服务器已经理解请求，但是拒绝执行它, 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。</p> <p><strong>404 Not Found</strong>: 资源未找到，表示没在服务器上找到相应的资源。</p> <p><strong>405 Method Not Allowed</strong>: 请求行中指定的请求方法不能被用于请求相应的资源，请求方法不被服务器端允许。</p> <p><strong>406 Not Acceptable</strong>: 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，资源无法满足客户端的条件。</p> <p><strong>408 Request Timeout</strong>: 客户端请求超时，服务器等待了太长时间。</p> <p><strong>409 Conflict</strong>: 由于和被请求的资源的当前状态之间存在冲突，请求无法完成，相当于多个请求发生了冲突。</p> <p><strong>413 Request Entity Too Large</strong>: 请求体的数据过大, 服务器拒绝处理当前请求。</p> <p><strong>414 Request-URI Too Long</strong>: 请求行里的 <code>URI</code> 太大，长度超过了服务器能够解释的长度。</p> <p><strong>429 Too Many Request</strong>: 客户端发送的请求过多。</p> <p><strong>431 Request Header Fields Too Large</strong>：请求头的字段内容太大。</p> <h3 id="_5xx"><a href="#_5xx" class="header-anchor">#</a> 5xx</h3> <p><strong>500 Internal Server Error</strong>: 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现，但是出了啥错咱也不知道。</p> <p><strong>501 Not Implemented</strong>: 表示客户端请求的功能服务器还不支持。</p> <p><strong>502 Bad Gateway</strong>: 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应，服务器自身是正常的，但访问的时候出错了。</p> <p><strong>503 Service Unavailable</strong>: 由于临时的服务器维护或者过载，服务器当前无法处理请求。表示服务器当前很忙，暂时无法响应服务。</p> <h2 id="_005-简要概括一下-http-的特点？http-有哪些缺点？"><a href="#_005-简要概括一下-http-的特点？http-有哪些缺点？" class="header-anchor">#</a> 005: 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</h2> <p>HTTP 的特点概括如下:</p> <ol><li><p>灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</p></li> <li><p>可靠传输。<code>HTTP</code> 基于 <code>TCP/IP</code>，因此把这一特性继承了下来。这属于 <code>TCP</code> 的特性，不具体介绍了。</p></li> <li><p>请求-应答。也就是<strong>一发一收、有来有回</strong>， 当然这个请求方和应答方不单单指<strong>客户端</strong>和<strong>服务器</strong>之间，如果某台服务器作为<strong>代理</strong>来<strong>连接后端</strong>的服务端，那么这台服务器也会扮演<strong>请求方</strong>的角色。</p></li> <li><p>无状态。这里的状态是指<strong>通信过程的上下文信息</strong>，而每次 <code>http</code> 请求都是<strong>独立、无关</strong>的，默认不需要保留状态信息。</p></li></ol> <h3 id="http-缺点"><a href="#http-缺点" class="header-anchor">#</a> HTTP 缺点</h3> <h4 id="无状态"><a href="#无状态" class="header-anchor">#</a> 无状态</h4> <p>所谓的优点和缺点还是要分场景来看的，对于 <code>HTTP</code> 而言，最具争议的地方在于它的<strong>无状态</strong>。</p> <p>在需要<strong>长连接</strong>的场景中，需要保存大量的<strong>上下文信息</strong>，以免传输大量重复的信息，那么这时候<strong>无状态</strong>就是 <code>http</code> 的缺点了。</p> <p>但与此同时，另外一些应用仅仅只是为了获取一些数据，<strong>不需要保存连接上下文信息</strong>，<strong>无状态</strong>反而减少了网络开销，成为了 <code>http</code> 的优点。</p> <h4 id="明文传输"><a href="#明文传输" class="header-anchor">#</a> 明文传输</h4> <p>即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。</p> <p>这当然对于调试提供了便利，但同时也让 <code>HTTP</code> 的报文信息暴露给了外界，给攻击者也提供了便利。<code>WIFI陷阱</code>就是利用 <code>HTTP</code> <strong>明文传输</strong>的缺点，诱导你连上热点，然后<strong>疯狂抓你所有的流量</strong>，从而拿到你的敏感信息。</p> <h4 id="队头阻塞问题"><a href="#队头阻塞问题" class="header-anchor">#</a> 队头阻塞问题</h4> <p>当 <code>http</code> 开启<strong>长连接</strong>时，共用一个 <code>TCP</code> 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的<strong>队头阻塞</strong>问题。接下来会有一小节讨论这个问题。</p> <h2 id="_006-对-accept-系列字段了解多少？"><a href="#_006-对-accept-系列字段了解多少？" class="header-anchor">#</a> 006: 对 Accept 系列字段了解多少？</h2> <p>对于 Accept 系列字段的介绍分为四个部分: <strong>数据格式、压缩方式、支持语言和字符集</strong>。</p> <h3 id="数据格式"><a href="#数据格式" class="header-anchor">#</a> 数据格式</h3> <p>上一节谈到 HTTP 灵活的特性，它支持非常多的数据格式，那么这么多格式的数据一起到达客户端，客户端怎么知道它的格式呢？</p> <p>当然，最低效的方式是直接猜，有没有更好的方式呢？直接指定可以吗？</p> <p>答案是肯定的。不过首先需要介绍一个标准——<strong>MIME</strong>(Multipurpose Internet Mail Extensions, <strong>多用途互联网邮件扩展</strong>)。它首先用在电子邮件系统中，让邮件可以发任意类型的数据，这对于 <code>HTTP</code> 来说也是通用的。</p> <p>具体而言，这两个字段的取值可以分为下面几类:</p> <ul><li>text：<code>text/html, text/plain, text/css</code> 等</li> <li>image: <code>image/gif, image/jpeg, image/png</code> 等</li> <li>audio/video: <code>audio/mpeg, video/mp4</code> 等</li> <li>application: <code>application/json(最常用), application/javascript, application/pdf, application/octet-stream</code></li></ul> <h3 id="压缩方式"><a href="#压缩方式" class="header-anchor">#</a> 压缩方式</h3> <p>当然一般这些数据都是会进行编码压缩的，采取什么样的压缩方式就体现在了发送方的<code>Content-Encoding</code>字段上， 同样的，接收什么样的压缩方式体现在了接受方的<code>Accept-Encoding</code>字段上。这个字段的取值有下面几种：</p> <ul><li><code>gzip</code>: 当今最流行的压缩格式</li> <li><code>deflate</code>: 另外一种著名的压缩格式</li> <li><code>br</code>: 一种专门为 <code>HTTP</code> 发明的压缩算法</li></ul> <p>比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 发送端</span>
Content<span class="token operator">-</span>Encoding<span class="token operator">:</span> gzip
<span class="token comment">// 接收端</span>
Accept<span class="token operator">-</span>Encoding<span class="token operator">:</span> gzip
</code></pre></div><h3 id="支持语言"><a href="#支持语言" class="header-anchor">#</a> 支持语言</h3> <p>对于发送方而言，还有一个 <code>Content-Language</code> 字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为 <code>Accept-Language</code>。如:</p> <div class="language-js extra-class"><pre class="language-js"><code>Accept<span class="token operator">-</span>Language<span class="token operator">:</span> zh<span class="token operator">-</span><span class="token constant">CN</span><span class="token punctuation">,</span>zh<span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">,</span>en<span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token number">0.8</span><span class="token punctuation">,</span>en<span class="token operator">-</span><span class="token constant">US</span><span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token number">0.7</span><span class="token punctuation">,</span>zh<span class="token operator">-</span><span class="token constant">TW</span><span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token number">0.6</span><span class="token punctuation">,</span>ko<span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token number">0.5</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 发送端</span>
Content<span class="token operator">-</span>Language<span class="token operator">:</span> zh<span class="token operator">-</span><span class="token constant">CN</span><span class="token punctuation">,</span> zh<span class="token punctuation">,</span> en
<span class="token comment">// 接收端</span>
Accept<span class="token operator">-</span>Language<span class="token operator">:</span> zh<span class="token operator">-</span><span class="token constant">CN</span><span class="token punctuation">,</span> zh<span class="token punctuation">,</span> en

</code></pre></div><h3 id="字符集"><a href="#字符集" class="header-anchor">#</a> 字符集</h3> <p>最后是一个比较特殊的字段, 在接收端对应为<code>Accept-Charset</code>，指定可以接受的字符集，而在发送端并没有对应的<code>Content-Charset</code>, 而是直接放在了<code>Content-Type</code>中，以<code>charset</code>属性指定。如:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 发送端</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> application<span class="token operator">/</span>json<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span>
<span class="token comment">// 接收端</span>
Accept<span class="token operator">-</span>Charset<span class="token operator">:</span> charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span>

</code></pre></div><p>最后以一张图来总结一下吧:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffd6bb6d09c2d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <h2 id="_007-对于定长和不定长的数据，http-是怎么传输的？"><a href="#_007-对于定长和不定长的数据，http-是怎么传输的？" class="header-anchor">#</a> 007: 对于定长和不定长的数据，HTTP 是怎么传输的？</h2> <h3 id="定长包体"><a href="#定长包体" class="header-anchor">#</a> 定长包体</h3> <p>对于定长包体而言，发送端在传输的时候一般会带上 <code>Content-Length</code>, 来指明包体的长度。</p> <p>我们用一个 <code>nodejs</code> 服务器来模拟一下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'request'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Length'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'helloworld'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8081</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'成功启动'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>启动后访问: <code>localhost:8081</code>。</p> <p>浏览器中显示如下:</p> <p><code>helloworld</code></p> <p>这是长度正确的情况，那不正确的情况是如何处理的呢？</p> <p>我们可以试着把这个长度设置的小一些:</p> <div class="language-js extra-class"><pre class="language-js"><code>res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Length'</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>重启服务，再次访问，现在浏览器中内容如下:</p> <p><code>hellowor</code></p> <p>那后面的 ld 哪里去了呢？实际上在 <code>http</code> 的响应体中直接被截掉了。</p> <p>然后我们试着将这个长度设置得大一些:</p> <div class="language-js extra-class"><pre class="language-js"><code>res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Length'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>此时浏览器显示如下:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffd6f598bea62?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>直接无法显示了。可以看到<code>Content-Length</code>对于 <code>http</code> 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输失败。</p> <h3 id="不定长包体"><a href="#不定长包体" class="header-anchor">#</a> 不定长包体</h3> <p>上述是针对于<code>定长包体</code>，那么对于<code>不定长包体</code>而言是如何传输的呢？</p> <p>这里就必须介绍另外一个 http 头部字段了:</p> <div class="language-js extra-class"><pre class="language-js"><code>Transfer<span class="token operator">-</span>Encoding<span class="token operator">:</span> chunked
</code></pre></div><p>表示<strong>分块传输数据</strong>，设置这个字段后会自动产生两个效果:</p> <ul><li><code>Content-Length</code> 字段会被<strong>忽略</strong></li> <li>基于长连接<strong>持续推送动态内容</strong></li></ul> <p>我们依然以一个实际的例子来模拟分块传输，nodejs 程序如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'request'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/html; charset=utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Length'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Transfer-Encoding'</span><span class="token punctuation">,</span> <span class="token string">'chunked'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'&lt;p&gt;来啦&lt;/p&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'第一次传输&lt;br/&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'第二次传输&lt;br/&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8009</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'成功启动'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>访问效果入下:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffd78332368a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>注意，<code>Connection: keep-alive</code>及之前的为<strong>响应行</strong>(HTTP/1.1 200 OK)和<strong>响应头</strong>(响应行下面的那部分)，后面的内容为响应体，这两部分用<strong>换行符</strong>隔开。</p> <p>响应体的结构比较有意思，如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>chunk长度(16进制的数)
第一个chunk的内容
chunk长度(16进制的数)
第二个chunk的内容
......
0

</code></pre></div><p>最后是留有有一个<strong>空行</strong>的，这一点请大家注意。</p> <p>以上便是 <code>http</code> 对于定长数据和不定长数据的传输方式。</p> <h2 id="_008-http-如何处理大文件的传输？"><a href="#_008-http-如何处理大文件的传输？" class="header-anchor">#</a> 008: HTTP 如何处理大文件的传输？</h2> <p>对于几百 <code>M</code> 甚至上 <code>G</code> 的大文件来说，如果要一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。因此，<code>HTTP</code> 针对这一场景，采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分。</p> <h3 id="如何支持"><a href="#如何支持" class="header-anchor">#</a> 如何支持</h3> <p>当然，前提是服务器要支持范围请求，要支持这个功能，就必须加上这样一个响应头:</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Accept-Ranges:</span> none
</code></pre></div><p>用来告知客户端这边是支持范围请求的。</p> <h3 id="range-字段拆解"><a href="#range-字段拆解" class="header-anchor">#</a> Range 字段拆解</h3> <p>而对于客户端而言，它需要指定请求哪一部分，通过 <code>Range</code> 这个请求头字段确定，格式为<code>bytes=x-y</code>。接下来就来讨论一下这个 <code>Range</code> 的书写格式:</p> <ul><li><code>0-499</code> 表示从开始到第 499 个字节。</li> <li><code>500-</code> 表示从第 500 字节到文件终点。</li> <li><code>-100</code> 表示文件的最后 100 个字节。</li></ul> <p>服务器收到请求之后，首先验证范围<strong>是否合法</strong>，如果越界了那么返回<code>416</code>错误码，否则读取相应片段，返回<code>206</code>状态码(上面说过的服务端<strong>返回部分内容</strong>)。</p> <p>同时，服务器需要添加<code>Content-Range</code>字段，这个字段的格式根据请求头中<code>Range</code>字段的不同而有所差异。</p> <p>具体来说，请求<code>单段数据</code>和请求<code>多段数据</code>，响应头是不一样的。</p> <p>举个例子:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 单段数据</span>
Range<span class="token operator">:</span> bytes <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> <span class="token number">9</span><span class="token punctuation">;</span>
<span class="token comment">// 多段数据</span>
Range<span class="token operator">:</span> <span class="token punctuation">(</span>bytes <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">30</span> <span class="token operator">-</span> <span class="token number">39</span><span class="token punctuation">;</span>
</code></pre></div><p>接下来我们就分别来讨论着两种情况。</p> <h3 id="单段数据"><a href="#单段数据" class="header-anchor">#</a> 单段数据</h3> <p>对于<code>单段数据</code>的请求，返回的响应如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">206</span> Partial Content
Content<span class="token operator">-</span>Length<span class="token operator">:</span> <span class="token number">10</span>
Accept<span class="token operator">-</span>Ranges<span class="token operator">:</span> bytes
Content<span class="token operator">-</span>Range<span class="token operator">:</span> bytes <span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token operator">/</span><span class="token number">100</span>

i am xxxxx

</code></pre></div><p>值得注意的是<code>Content-Range</code>字段，<code>0-9</code>表示请求的返回，<code>100</code>表示资源的总大小，很好理解。</p> <h3 id="多段数据"><a href="#多段数据" class="header-anchor">#</a> 多段数据</h3> <p>接下来我们看看多段请求的情况。得到的响应会是下面这个形式:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">206</span> Partial Content
<span class="token comment">// 非常关键的字段</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> multipart<span class="token operator">/</span>byteranges<span class="token punctuation">;</span> boundary<span class="token operator">=</span><span class="token number">00000010101</span>
Content<span class="token operator">-</span>Length<span class="token operator">:</span> <span class="token number">189</span>
Connection<span class="token operator">:</span> keep<span class="token operator">-</span>alive
Accept<span class="token operator">-</span>Ranges<span class="token operator">:</span> bytes


<span class="token operator">--</span><span class="token number">00000010101</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>plain
Content<span class="token operator">-</span>Range<span class="token operator">:</span> bytes <span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token operator">/</span><span class="token number">96</span>

i am xxxxx
<span class="token operator">--</span><span class="token number">00000010101</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>plain
Content<span class="token operator">-</span>Range<span class="token operator">:</span> bytes <span class="token number">20</span><span class="token operator">-</span><span class="token number">29</span><span class="token operator">/</span><span class="token number">96</span>

eex jspy e
<span class="token operator">--</span><span class="token number">00000010101</span><span class="token operator">--</span>

</code></pre></div><p>这个时候出现了一个非常关键的字段<code>Content-Type: multipart/byteranges;boundary=00000010101</code>，它代表了信息量是这样的:</p> <ul><li>请求一定是多段数据请求</li> <li>响应体中的分隔符是 00000010101</li></ul> <p>因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上<code>--</code>表示结束。</p> <p>以上就是 http 针对大文件传输所采用的手段。</p> <h2 id="_009-http-中如何处理表单数据的提交？"><a href="#_009-http-中如何处理表单数据的提交？" class="header-anchor">#</a> 009: HTTP 中如何处理表单数据的提交？</h2> <p>在 http 中，有两种主要的表单提交的方式，体现在两种不同的<code>Content-Type</code>取值:</p> <div class="language-js extra-class"><pre class="language-js"><code>application <span class="token operator">/</span> x <span class="token operator">-</span> www <span class="token operator">-</span> form <span class="token operator">-</span> urlencoded<span class="token punctuation">;</span>
multipart <span class="token operator">/</span> form <span class="token operator">-</span> data<span class="token punctuation">;</span>
</code></pre></div><p>由于表单提交一般是<code>POST</code>请求，很少考虑<code>GET</code>，因此这里我们将默认提交的数据放在请求体中。</p> <h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="header-anchor">#</a> application/x-www-form-urlencoded</h3> <p>对于<code>application/x-www-form-urlencoded</code>格式的表单内容，有以下特点:</p> <ul><li>其中的数据会被编码成以<code>&amp;</code>分隔的键值对</li> <li>字符以<code>URL</code>编码方式编码。</li></ul> <p>如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 转换过程: {a: 1, b: 2} -&gt; a=1&amp;b=2 -&gt; 如下(最终形式)</span>
<span class="token string">'a%3D1%26b%3D2'</span><span class="token punctuation">;</span>

<span class="token comment">// 相当于如下URI编码</span>
<span class="token function">encodeURIComponent</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">a=1&amp;b=2</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a%3D1%26b%3D2</span>
</code></pre></div><h3 id="multipart-form-data"><a href="#multipart-form-data" class="header-anchor">#</a> multipart/form-data</h3> <p>对于<code>multipart/form-data</code>而言:</p> <ul><li><p>请求头中的<code>Content-Type</code>字段会包含<code>boundary</code>，且<code>boundary</code>的值有浏览器默认指定。例: <code>Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe</code>。</p></li> <li><p>数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 <code>HTTP</code> 头部描述子包体，如<code>Content-Type</code>，在最后的分隔符会加上<code>--</code>表示结束。</p></li></ul> <p>相应的<code>请求体</code>是下面这样:</p> <div class="language-js extra-class"><pre class="language-js"><code>Content<span class="token operator">-</span>Disposition<span class="token operator">:</span> form<span class="token operator">-</span>data<span class="token punctuation">;</span>name<span class="token operator">=</span><span class="token string">&quot;data1&quot;</span><span class="token punctuation">;</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>plain
data1
<span class="token operator">--</span><span class="token operator">--</span>WebkitFormBoundaryRRJKeWfHPGrS4LKe
Content<span class="token operator">-</span>Disposition<span class="token operator">:</span> form<span class="token operator">-</span>data<span class="token punctuation">;</span>name<span class="token operator">=</span><span class="token string">&quot;data2&quot;</span><span class="token punctuation">;</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>plain
data2
<span class="token operator">--</span><span class="token operator">--</span>WebkitFormBoundaryRRJKeWfHPGrS4LKe<span class="token operator">--</span>

</code></pre></div><h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h3> <p>值得一提的是，<code>multipart/form-data</code> 格式最大的特点在于:<strong>每一个表单元素都是独立的资源表述</strong>。另外，你可能在写业务的过程中，并没有注意到其中还有<code>boundary</code>的存在，
如果你打开抓包工具，确实可以看到不同的表单元素被拆分开了，之所以在平时感觉不到，是以为浏览器和 <code>HTTP</code> 给你封装了这一系列操作。</p> <p>而且，在实际的场景中，对于<strong>图片等文件的上传</strong>，基本采用<strong>multipart/form-data</strong>而不用<code>application/x-www-form-urlencoded</code>，因为没有必要做 <code>URL</code> 编码，带来<strong>巨大耗时</strong>的同时也<strong>占用了更多的空间</strong>。</p> <h2 id="_010-http1-1-如何解决-http-的队头阻塞问题？"><a href="#_010-http1-1-如何解决-http-的队头阻塞问题？" class="header-anchor">#</a> 010: HTTP1.1 如何解决 HTTP 的队头阻塞问题？</h2> <h3 id="什么是-http-队头阻塞？"><a href="#什么是-http-队头阻塞？" class="header-anchor">#</a> 什么是 HTTP 队头阻塞？</h3> <p>从前面的小节可以知道，<code>HTTP</code> 传输是基于<strong>请求-应答</strong>的模式进行的，报文必须是<strong>一发一收</strong>，但值得注意的是，里面的任务被放在一个<strong>任务队列</strong>中<strong>串行执行</strong>，一旦队首的请求处理太慢，就会<strong>阻塞</strong>后面请求的处理。这就是著名的<strong>HTTP 队头阻塞</strong>问题。</p> <h3 id="并发连接"><a href="#并发连接" class="header-anchor">#</a> 并发连接</h3> <p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在<code>RFC2616</code>规定过客户端最多<strong>并发 2 个连接</strong>，不过事实上在现在的浏览器标准中，这个上限要多很多，<code>Chrome</code> 中是 <code>6</code> 个。</p> <p>但其实，即使是提高了<strong>并发连接</strong>，还是不能满足人们对性能的需求。</p> <h3 id="域名分片"><a href="#域名分片" class="header-anchor">#</a> 域名分片</h3> <p>一个域名不是可以并发 <code>6</code> 个<strong>长连接</strong>吗？那我们就可以多分几个域名。</p> <p>比如 <code>content1.golderbrother.com 、content2.golderbrother.com</code></p> <p>这样一个<code>golderbrother.com</code>域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p> <h2 id="_011-对-cookie-了解多少？"><a href="#_011-对-cookie-了解多少？" class="header-anchor">#</a> 011: 对 Cookie 了解多少？</h2> <h3 id="cookie-简介"><a href="#cookie-简介" class="header-anchor">#</a> Cookie 简介</h3> <p>前面说到了 <code>HTTP</code> 是一个无状态的协议，每次 <code>http</code> 请求都是<strong>独立、无关</strong>的，默认不需要保留状态信息。但有时候需要保存一些状态，怎么办呢？</p> <p><code>HTTP</code> 为此引入了 <code>Cookie</code>。<code>Cookie</code> 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在<code>chrome</code>开发者面板的<code>Application</code>这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 <code>Cookie</code>，服务器拿到 <code>Cookie</code> 进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的<code>Set-Cookie</code>字段来对客户端写入<code>Cookie</code>。举例如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 请求头</span>
Cookie<span class="token operator">:</span> a<span class="token operator">=</span>xxx<span class="token punctuation">;</span>b<span class="token operator">=</span>xxx
<span class="token comment">// 响应头</span>
Set<span class="token operator">-</span>Cookie<span class="token operator">:</span> a<span class="token operator">=</span>xxx
<span class="token keyword">set</span><span class="token operator">-</span>Cookie<span class="token operator">:</span> b<span class="token operator">=</span>xxx

</code></pre></div><p><code>Cookie</code> 的有效期可以通过<code>Expires</code>和<code>Max-Age</code>两个属性来设置。</p> <p><code>Expires</code>即过期时间, 比如 <code>2020-04-01T02:04:24.377Z</code> <code>Max-Age</code>用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。</p> <p>若 <code>Cookie</code> 过期，则这个 <code>Cookie</code> 会被删除，并不会发送给服务端。</p> <h3 id="cookie-属性"><a href="#cookie-属性" class="header-anchor">#</a> Cookie 属性</h3> <h4 id="生存周期"><a href="#生存周期" class="header-anchor">#</a> 生存周期</h4> <h3 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h3> <p>关于作用域也有两个属性: <code>Domain</code>和<code>path</code>, 给 <code>Cookie</code> 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 <code>Cookie</code>。值得注意的是，对于路径来说，<code>/</code>表示域名下的任意路径都允许使用 Cookie。</p> <h3 id="安全相关"><a href="#安全相关" class="header-anchor">#</a> 安全相关</h3> <p>如果带上 <code>Secure</code>，说明只能通过 <code>HTTPS</code> 传输 <code>cookie</code>。</p> <p>如果 <code>cookie</code> 字段带上 <code>HttpOnly</code> ，那么说明只能通过 <code>HTTP</code> 协议传输，不能通过 <code>JS</code> 访问，这也是预防 <code>XSS</code> 攻击的重要手段。</p> <p>相应的，对于 <code>CSRF</code> 攻击的预防，也有 <code>SameSite</code> 属性。</p> <p><code>SameSite</code> 可以设置为三个值，<code>Strict、Lax和None</code>。</p> <p>a. 在 <code>Strict</code> 模式下，浏览器完全禁止第三方请求携带 <code>Cookie</code> 。比如请求 <code>golderbrother.cn</code> 网站只能在<code>golderbrother.cn</code>域名当中请求才能携带 <code>Cookie</code> ，在其他网站请求都不能。</p> <p>b. 在 <code>Lax</code> 模式，就宽松一点了，但是只能在 <code>get</code> 方法<strong>提交表单</strong>或者 <code>a 标签</code> 发送 <code>get</code> 请求的情况下可以携带 <code>Cookie</code>，其他情况均不能。</p> <p>c. 在 <code>None</code> 模式下，也就是默认模式，请求会自动携带上 <code>Cookie</code> 。</p> <h2 id="cookie-的缺点"><a href="#cookie-的缺点" class="header-anchor">#</a> Cookie 的缺点</h2> <ol><li><p><strong>容量缺陷</strong>。<code>Cookie</code> 的体积上限只有<code>4KB</code>，只能用来存储少量的信息。</p></li> <li><p><strong>性能缺陷</strong>。<code>Cookie</code> 紧跟域名，不管域名下面的某一个地址需不需要这个 <code>Cookie</code> ，请求都会携带上完整的 <code>Cookie</code>，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求<strong>携带了很多不必要的内容</strong>。但可以通过<code>Domain</code>和<code>Path</code>指定作用域来解决。</p></li> <li><p><strong>安全缺陷</strong>。由于 <code>Cookie</code> 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 <code>Cookie</code> 的有效期内重新发送给服务器，这是相当危险的。另外，在 <code>HttpOnly</code> 为 <code>false</code> 的情况下，<code>Cookie</code> 信息能直接通过前端 <code>JS 脚本</code>来<strong>读取</strong>。</p></li></ol> <h3 id="_012-如何理解-http-代理？"><a href="#_012-如何理解-http-代理？" class="header-anchor">#</a> 012: 如何理解 HTTP 代理？</h3> <p>我们知道在 HTTP 是基于请求-响应模型的协议，一般由<strong>客户端发请求</strong>，<strong>服务器来进行响应</strong>。</p> <p>当然，也有特殊情况，就是<strong>代理服务器</strong>的情况。引入代理之后，作为代理的服务器相当于一个<strong>中间人</strong>的角色，<strong>对于客户端而言，表现为服务器进行响应</strong>；而对于<strong>源服务器，表现为客户端发起请求</strong>，具有<strong>双重身份</strong>。
比如我们在日常工作中，会使用 <code>NodeJS</code> 作为中间端来<strong>转发客户端请求到</strong>真正的服务端，接收到响应体后再经过我们自己的数据处理，最终返回给客户端。</p> <p>那代理服务器仅仅只是做个<strong>中间商</strong>吗？还能用来做什么的呢？</p> <h3 id="功能"><a href="#功能" class="header-anchor">#</a> 功能</h3> <h4 id="_1-负载均衡"><a href="#_1-负载均衡" class="header-anchor">#</a> 1. 负载均衡</h4> <p>客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括<strong>随机算法</strong>、<strong>轮询</strong>、<strong>一致性 hash</strong>、<strong>LRU</strong>(<code>最近最少使用</code>)等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。</p> <h4 id="_2-保障安全"><a href="#_2-保障安全" class="header-anchor">#</a> 2. 保障安全</h4> <p>利用<strong>心跳</strong>机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。</p> <h4 id="_3-缓存代理"><a href="#_3-缓存代理" class="header-anchor">#</a> 3. 缓存代理</h4> <p>将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。下一节详细拆解。</p> <h3 id="相关头部字段"><a href="#相关头部字段" class="header-anchor">#</a> 相关头部字段</h3> <h4 id="via"><a href="#via" class="header-anchor">#</a> Via</h4> <p>如果代理服务器需要标明自己的身份，在 HTTP 传输中留下自己的痕迹，那怎么办呢？</p> <p>我们可以通过<code>Via</code>字段来记录。举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程:</p> <div class="language-js extra-class"><pre class="language-js"><code>客户端 <span class="token operator">-</span><span class="token operator">&gt;</span> 代理<span class="token number">1</span> <span class="token operator">-</span><span class="token operator">&gt;</span> 代理<span class="token number">2</span> <span class="token operator">-</span><span class="token operator">&gt;</span> 源服务器
</code></pre></div><p>在源服务器收到请求后，我们会在<strong>请求头</strong>拿到这个字段:</p> <div class="language-js extra-class"><pre class="language-js"><code>Via<span class="token operator">:</span> proxy_server1<span class="token punctuation">,</span> proxy_server2<span class="token punctuation">;</span>
</code></pre></div><p>而源服务器响应时，最终在客户端会拿到这样的<strong>响应头</strong>:</p> <div class="language-js extra-class"><pre class="language-js"><code>Via<span class="token operator">:</span> proxy_server2<span class="token punctuation">,</span> proxy_server1<span class="token punctuation">;</span>
</code></pre></div><p>可以看到，<code>Via</code>中代理的顺序即为在 <code>HTTP</code> 传输中<strong>报文传达</strong>的顺序(proxy_server1 -&gt; proxy_server2 -&gt; source)。</p> <h4 id="x-forwarded-for"><a href="#x-forwarded-for" class="header-anchor">#</a> X-Forwarded-For</h4> <p>字面意思就是<strong>为谁转发</strong>, 它记录的是<strong>请求方</strong>的<code>IP</code>地址(注意，和<code>Via</code>区分开，<code>X-Forwarded-For</code>记录的是请求方这一个<code>IP</code>)。</p> <h4 id="x-real-ip"><a href="#x-real-ip" class="header-anchor">#</a> X-Real-IP</h4> <p>是一种获取用户真实 <code>IP</code> 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的<code>IP</code>。</p> <p>相应的，还有 <code>X-Forwarded-Host</code> 和 <code>X-Forwarded-Proto</code> ，分别记录客户端(注意哦，不包括代理)的<strong>域名</strong>和<strong>协议名</strong>。</p> <h4 id="x-forwarded-for-产生的问题"><a href="#x-forwarded-for-产生的问题" class="header-anchor">#</a> X-Forwarded-For 产生的问题</h4> <p>前面可以看到，<code>X-Forwarded-For</code>这个字段记录的是请求方的 <code>IP</code>，这意味着每经过一个不同的代理，这个字段的名字都要变，从<code>客户端</code>到<code>代理1</code>，这个字段是客户端的 <code>IP</code>，从<code>代理1</code>到<code>代理2</code>，这个字段就变为了<code>代理1</code>的 <code>IP</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code>客户端 <span class="token operator">-</span><span class="token operator">&gt;</span> 代理<span class="token number">1</span> <span class="token operator">-</span><span class="token operator">&gt;</span> 代理<span class="token number">2</span>
  客户端 <span class="token constant">IP</span> <span class="token operator">-</span><span class="token operator">&gt;</span> 代理<span class="token number">1</span> <span class="token constant">IP</span>
</code></pre></div><p>但是这会产生两个问题:</p> <ol><li><p>意味着代理必须解析 <code>HTTP</code> 请求头，然后修改，比直接转发数据性能下降。</p></li> <li><p>在 <code>HTTPS</code> 通信加密的过程中，原始报文是不允许修改的。</p></li></ol> <p>由此产生了<code>代理协议</code>，一般使用明文版本，只需要在 <code>HTTP</code> 请求行上面加上这样格式的文本即可:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// PROXY + TCP4/TCP6 + 请求方地址(0.0.0.1) + 接收方地址(0.0.0.2) + 请求端口(1111) + 接收端口(2222)</span>
<span class="token constant">PROXY</span> <span class="token constant">TCP4</span> <span class="token number">0.0</span><span class="token number">.0</span><span class="token number">.1</span> <span class="token number">0.0</span><span class="token number">.0</span><span class="token number">.2</span> <span class="token number">1111</span> <span class="token number">2222</span>
<span class="token constant">GET</span> <span class="token operator">/</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
<span class="token operator">...</span>

</code></pre></div><p>这样就可以解决<code>X-Forwarded-For</code>带来的问题了。</p> <h3 id="_013-如何理解-http-缓存及缓存代理？"><a href="#_013-如何理解-http-缓存及缓存代理？" class="header-anchor">#</a> 013: 如何理解 HTTP 缓存及缓存代理？</h3> <p>关于强缓存和协商缓存的内容，我已经在<a href="https://golderbrother.github.io/blog/views/fe-interview/browser-cache.html" target="_blank" rel="noopener noreferrer">浏览器缓存一探究竟~<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>做了详细分析，小结如下:</p> <p>首先通过 <code>Cache-Control</code> <strong>验证强缓存</strong>是否可用</p> <ul><li>如果强缓存可用，直接使用</li> <li>否则进入<strong>协商缓存</strong>即发送 HTTP 请求，服务器通过请求头中的<code>If-Modified-Since</code>或者<code>If-None-Match</code>这些条件请求字段检查资源是否更新
<ul><li>若资源更新，返回资源和<code>200</code>状态码</li> <li>否则，返回<code>304</code>，告诉浏览器直接<strong>从缓存获取资源</strong></li></ul></li></ul> <p>这一节我们主要来说说另外一种缓存方式: <strong>代理缓存</strong>。</p> <h4 id="为什么产生代理缓存？"><a href="#为什么产生代理缓存？" class="header-anchor">#</a> 为什么产生代理缓存？</h4> <p>对于源服务器来说，它也是有缓存的，比如<code>Redis, Memcache</code>，但对于 <code>HTTP 缓存</code>来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的。</p> <p>由此引入了<strong>缓存代理</strong>的机制。让代理服务器<strong>接管</strong>一部分的<strong>服务端 HTTP 缓存</strong>，客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候能明显降低源服务器的压力。</p> <p>那缓存代理究竟是如何做到的呢？</p> <p>总的来说，缓存代理的控制分为两部分，一部分是<strong>源服务器端</strong>的控制，一部分是<strong>客户端</strong>的控制。</p> <h4 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="header-anchor">#</a> 源服务器的缓存控制</h4> <h5 id="private-和-public"><a href="#private-和-public" class="header-anchor">#</a> private 和 public</h5> <p>在源服务器的响应头中，会加上<code>Cache-Control</code>这个字段进行缓存控制字段，那么它的值当中可以加入<code>private</code>或者<code>public</code>表示是否允许代理服务器缓存，前者<strong>禁止</strong>，后者为<strong>允许</strong>。</p> <p>比如对于一些非常私密的数据，如果缓存到代理服务器，别人直接访问代理就可以拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头部的<code>Cache-Control</code>设为<code>private</code>，而不是<code>public</code>。</p> <p>就像下面这样:</p> <div class="language-js extra-class"><pre class="language-js"><code>Cache<span class="token operator">-</span>control<span class="token operator">:</span> <span class="token keyword">private</span>
</code></pre></div><h5 id="proxy-revalidate"><a href="#proxy-revalidate" class="header-anchor">#</a> proxy-revalidate</h5> <p><code>must-revalidate</code>的意思是<strong>客户端</strong>缓存过期就去源服务器获取，而<code>proxy-revalidate</code>则表示<strong>代理服务器</strong>的缓存过期后到源服务器获取。</p> <h5 id="s-maxage"><a href="#s-maxage" class="header-anchor">#</a> s-maxage</h5> <p><code>s</code>是<code>share</code>的意思，限定了缓存在<strong>代理服务器</strong>中可以<strong>存放多久</strong>(缓存时间)，和限制客户端缓存时间的<code>max-age</code>并不冲突。</p> <p>讲了这几个字段，我们不妨来举个小例子，源服务器在响应头中加入这样一个字段:</p> <div class="language-js extra-class"><pre class="language-js"><code>Cache<span class="token operator">-</span>Control<span class="token operator">:</span> <span class="token keyword">public</span><span class="token punctuation">,</span> max<span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">,</span> s<span class="token operator">-</span>maxage<span class="token operator">=</span><span class="token number">2000</span>

</code></pre></div><p>相当于源服务器说: 我这个响应是允许<strong>代理服务器缓存</strong>的，客户端缓存过期了到代理中拿，并且在客户端的<strong>缓存时间</strong>为 <code>1000 s</code>，在代理服务器中的<strong>缓存时间</strong>为 <code>2000 s</code>。</p> <h4 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="header-anchor">#</a> 客户端的缓存控制</h4> <h5 id="max-stale-和-min-fresh"><a href="#max-stale-和-min-fresh" class="header-anchor">#</a> max-stale 和 min-fresh</h5> <p>在客户端的请求头中，可以加入这两个字段，来对代理服务器上的缓存进行<strong>宽容</strong>和<strong>限制</strong>操作。比如：</p> <div class="language-js extra-class"><pre class="language-js"><code>max<span class="token operator">-</span>stale<span class="token operator">:</span> <span class="token number">5</span>

</code></pre></div><p>表示客户端到代理服务器上拿缓存的时候，即使代理<strong>缓存过期了也不要紧</strong>，只要<strong>过期时间在 5 秒之内</strong>，还是可以从代理中获取的。</p> <p>又比如:</p> <div class="language-js extra-class"><pre class="language-js"><code>min<span class="token operator">-</span>fresh<span class="token operator">:</span> <span class="token number">5</span>

</code></pre></div><p>表示代理缓存需要一定的<strong>新鲜度</strong>，不要等到缓存刚好到期再拿，一定要在<strong>到期前 5 秒之前</strong>的时间拿，否则拿不到。</p> <h5 id="only-if-cached"><a href="#only-if-cached" class="header-anchor">#</a> only-if-cached</h5> <p>这个字段加上后表示客户端只会接受<strong>代理缓存</strong>，而不会接受源服务器的响应。如果<strong>代理缓存</strong>无效，则直接返回<code>504（Gateway Timeout）</code>。</p> <p>以上便是缓存代理的内容，涉及的字段比较多，希望能好好回顾一下，加深理解。</p> <h2 id="_014-什么是跨域？浏览器如何拦截响应？如何解决？"><a href="#_014-什么是跨域？浏览器如何拦截响应？如何解决？" class="header-anchor">#</a> 014: 什么是跨域？浏览器如何拦截响应？如何解决？</h2> <p>在前后端分离的开发模式中，经常会遇到跨域问题，即 Ajax 请求发出去了，服务器也成功响应了，前端就是拿不到这个响应。接下来我们就来好好讨论一下这个问题。</p> <h3 id="那什么是跨域"><a href="#那什么是跨域" class="header-anchor">#</a> 那什么是跨域</h3> <p>咱们来回顾一下 <code>URI</code> 的组成:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffd7ac23846fe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>浏览器遵循<strong>同源政策</strong>(<code>scheme(协议)</code>、<code>host(主机)</code>和<code>port(端口)</code>都相同则为同源)。非同源站点有这样一些限制:</p> <ul><li>不能读取和修改对方的 DOM</li> <li>不读访问对方的 Cookie、IndexDB 和 LocalStorage</li> <li>限制 XMLHttpRequest 请求。(后面的话题着重围绕这个)</li></ul> <p>当浏览器向目标 <code>URI</code> 发 <code>Ajax</code> 请求时，只要当前 <code>URL</code> 和目标 <code>URL</code> <strong>不同源</strong>，则产生<strong>跨域</strong>，被称为<code>跨域请求</code>。</p> <p>跨域请求的响应一般会被浏览器所拦截，注意，是<strong>被浏览器拦截</strong>，<strong>响应其实是成功到达客户端</strong>了。那这个拦截是如何发生呢？</p> <p>首先要知道的是，浏览器是多进程的，以 <code>Chrome</code> 为例，进程组成如下：</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffd8131a4628f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p><strong>WebKit 渲染引擎</strong>和<strong>V8 引擎</strong>都在渲染进程当中。</p> <p>当<code>xhr.send</code>被调用，即 <code>Ajax</code> 请求准备发送的时候，其实还只是在渲染进程的处理。为了防止黑客通过脚本触碰到系统资源，浏览器将每一个渲染进程装进了沙箱，并且为了防止 CPU 芯片一直存在的 <code>Spectre</code> 和 <code>Meltdown</code> 漏洞，采取了<code>站点隔离</code>的手段，给每一个不同的站点(一级域名不同)分配了沙箱，互不干扰。
具体见<a href="https://www.youtube.com/watch?v=dBuykrdhK-A&amp;feature=emb_logo" target="_blank" rel="noopener noreferrer">YouTube 上 Chromium 安全团队的演讲视频<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>在沙箱当中的渲染进程是没有办法发送网络请求的，那怎么办？只能通过网络进程来发送。那这样就涉及到进程间通信(<code>IPC，Inter Process Communication</code>)了。接下来我们看看 chromium 当中进程间通信是如何完成的，在 chromium 源码中调用顺序如下:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffd924eaecb41?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>可能看了你会比较懵，如果想深入了解可以去看看 chromium 最新的源代码, <a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/master/ipc/" target="_blank" rel="noopener noreferrer">IPC 源码地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>及<a href="https://blog.csdn.net/Luoshengyang/article/details/47822689" target="_blank" rel="noopener noreferrer">Chromium IPC 源码解析文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>总的来说就是利用<code>Unix Domain Socket</code>套接字，配合事件驱动的高性能网络并发库<code>libevent</code>完成进程的 <code>IPC 过程</code>。</p> <p>好，现在数据传递给了浏览器主进程，主进程接收到后，才真正地发出相应的网络请求。</p> <p>在服务端处理完数据后，将响应返回，主进程检查到跨域，且没有<code>cors</code>(跨域资源共享)响应头，将响应体<strong>全部丢掉</strong>，并不会发送给渲染进程。这就达到了<strong>拦截数据</strong>的目的。</p> <p>接下来我们来说一说解决跨域问题的几种方案。</p> <h3 id="浏览器限制跨域请求一般有两种方式"><a href="#浏览器限制跨域请求一般有两种方式" class="header-anchor">#</a> 浏览器限制跨域请求一般有两种方式</h3> <ul><li>浏览器限制发起跨域请求</li> <li>跨域请求可以正常发起，但是返回的结果被浏览器拦截了</li></ul> <h3 id="cors"><a href="#cors" class="header-anchor">#</a> CORS</h3> <p><code>CORS</code> 其实是 <code>W3C</code> 的一个标准，全称是<strong>跨域资源共享</strong>。它需要浏览器和服务器的共同支持，具体来说，<strong>非 IE 和 IE10 以上</strong>支持<code>CORS</code>，服务器需要附加特定的<code>响应头</code>，后面具体拆解。不过在弄清楚 <code>CORS</code> 的原理之前，我们需要清楚两个概念: <strong>简单请求</strong>和<strong>非简单请求</strong>。</p> <p>浏览器根据请求方法和请求头的特定字段，将请求做了一下分类，具体来说规则是这样，凡是满足下面条件的属于<strong>简单请求</strong>:</p> <ul><li>请求方法为 <code>GET、POST</code> 或者 <code>HEAD</code></li> <li>请求头的取值范围: <code>Accept、Accept-Language、Content-Language、Content-Type</code>(只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 表单提交</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> application<span class="token operator">/</span>x<span class="token operator">-</span>www<span class="token operator">-</span>form<span class="token operator">-</span>urlencoded
<span class="token comment">// 文件上传</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> multipart<span class="token operator">/</span>form<span class="token operator">-</span>data
<span class="token comment">// 纯文本</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>plain
</code></pre></div><p>浏览器画了这样一个圈，在这个<strong>圈里面</strong>的就是<strong>简单请求</strong>, <strong>圈外面</strong>的就是<strong>非简单请求</strong>，然后针对这两种不同的请求进行不同的处理。</p> <h3 id="简单请求"><a href="#简单请求" class="header-anchor">#</a> 简单请求</h3> <p>请求发出去之前，浏览器做了什么？</p> <p>它会自动在请求头当中，添加一个<code>Origin</code>字段，用来说明请求来自哪个源。服务器拿到请求之后，在回应时对应地添加<code>Access-Control-Allow-Origin</code>字段，如果<code>Origin</code>不在这个字段的范围中，那么浏览器就会将响应拦截。</p> <p>因此，<code>Access-Control-Allow-Origin</code>字段是服务器用来决定浏览器是否拦截这个响应，这是必需的字段。与此同时，其它一些可选的功能性的字段，用来描述如果不会拦截，这些字段将会发挥各自的作用。</p> <p>比方说访问掘金网站，我们打开控制台随便查看一条请求信息</p> <div class="language-js extra-class"><pre class="language-js"><code>access<span class="token operator">-</span>control<span class="token operator">-</span>allow<span class="token operator">-</span>origin<span class="token operator">:</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>juejin<span class="token punctuation">.</span>im
</code></pre></div><p><code>Access-Control-Allow-Credentials</code>。这个字段是一个布尔值，表示是否允许发送 <code>Cookie</code>，对于跨域请求，浏览器对这个字段默认值设为 <code>false</code>，而如果需要拿到浏览器的 <code>Cookie</code>，需要添加这个响应头并设为<code>true</code>, 并且在前端也需要设置<code>withCredentials</code>属性:</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">access-control-allow-credentials:</span> true
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre></div><p><code>Access-Control-Expose-Headers</code>。这个字段是给 <code>XMLHttpRequest</code> 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括<code>Cache-Control、Content-Language、Content-Type、Expires、Last-Modified和Pragma</code>）, 还能拿到这个字段声明的响应头字段。比如这样设置:</p> <div class="language-js extra-class"><pre class="language-js"><code>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Expose<span class="token operator">-</span>Headers<span class="token operator">:</span> aaa
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>access<span class="token operator">-</span>control<span class="token operator">-</span>allow<span class="token operator">-</span>headers<span class="token operator">:</span> x<span class="token operator">-</span>requested<span class="token operator">-</span><span class="token keyword">with</span><span class="token punctuation">,</span>content<span class="token operator">-</span>type<span class="token punctuation">,</span>Cache<span class="token operator">-</span>Control<span class="token punctuation">,</span>Pragma<span class="token punctuation">,</span>Date<span class="token punctuation">,</span>x<span class="token operator">-</span>timestamp
</code></pre></div><p>那么在前端可以通过 <code>XMLHttpRequest.getResponseHeader('aaa')</code> 拿到 <code>aaa</code> 这个字段的值。</p> <h3 id="非简单请求"><a href="#非简单请求" class="header-anchor">#</a> 非简单请求</h3> <p>非简单请求相对而言会有些不同，体现在两个方面: <strong>预检请求</strong>和<strong>响应字段</strong></p> <p>我们以 <code>PUT</code> 方法为例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">'http://xxx.com'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'PUT'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'X-Custom-Header'</span><span class="token punctuation">,</span> <span class="token string">'xxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当这段代码执行后，首先会发送<strong>预检请求</strong>(<code>preflight request</code>)。这个<strong>预检请求</strong>的请求行和请求体是下面这个格式:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">OPTIONS</span> <span class="token operator">/</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
Origin<span class="token operator">:</span> 当前地址
Host<span class="token operator">:</span> xxx<span class="token punctuation">.</span>com
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Request<span class="token operator">-</span>Method<span class="token operator">:</span> <span class="token constant">PUT</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Request<span class="token operator">-</span>Headers<span class="token operator">:</span> <span class="token constant">X</span><span class="token operator">-</span>Custom<span class="token operator">-</span>Header

</code></pre></div><p>预检请求的方法是<code>OPTIONS</code>，同时会加上<code>Origin源地址</code>和<code>Host目标地址</code>，这很简单。同时也会加上两个关键的字段:</p> <ul><li><code>Access-Control-Request-Method</code>, 列出 <code>CORS</code> 请求用到哪个<strong>HTTP 方法</strong></li> <li><code>Access-Control-Request-Headers</code>，指定 <code>CORS</code> 请求将要加上什么<strong>请求头</strong></li></ul> <p>预检请求的响应。如下面的格式:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> <span class="token constant">OK</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span> <span class="token operator">*</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Methods<span class="token operator">:</span> <span class="token constant">GET</span><span class="token punctuation">,</span> <span class="token constant">POST</span><span class="token punctuation">,</span> <span class="token constant">PUT</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Headers<span class="token operator">:</span> <span class="token constant">X</span><span class="token operator">-</span>Custom<span class="token operator">-</span>Header
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials<span class="token operator">:</span> <span class="token boolean">true</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Max<span class="token operator">-</span>Age<span class="token operator">:</span> <span class="token number">1728000</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>html<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span>
Content<span class="token operator">-</span>Encoding<span class="token operator">:</span> gzip
Content<span class="token operator">-</span>Length<span class="token operator">:</span> <span class="token number">0</span>

</code></pre></div><p>其中有这样几个关键的<strong>响应头字段</strong>:</p> <ul><li><code>Access-Control-Allow-Origin</code>: 表示可以允许<strong>请求的源</strong>，可以填具体的源名，也可以填<code>*</code>表示<strong>允许任意源请求</strong>。</li> <li><code>Access-Control-Allow-Methods</code>: 表示允许的<strong>请求方法列表</strong>。</li> <li><code>Access-Control-Allow-Credentials</code>: 是否允许携带<code>cookie</code>。</li> <li><code>Access-Control-Allow-Headers</code>: 表示允许发送的<strong>请求头字段</strong></li> <li><code>Access-Control-Max-Age</code>: 预检请求的<strong>有效期</strong>，在此期间，不用发出另外一条预检请求。</li></ul> <p>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发<code>XMLHttpRequest</code>的<code>onerror</code>方法，当然后面真正的<code>CORS请求</code>也不会发出去了。</p> <p><strong>CORS 请求的响应</strong>。绕了这么一大转，到了真正的 <code>CORS</code> 请求就容易多了，现在它和简单请求的情况是一样的。浏览器自动加上<code>Origin</code>字段，服务端响应头返回<code>Access-Control-Allow-Origin</code>。可以参考以上简单请求部分的内容。</p> <h3 id="jsonp"><a href="#jsonp" class="header-anchor">#</a> JSONP</h3> <p>虽然<code>XMLHttpRequest</code>对象遵循同源政策，但是<code>script</code>标签不一样，它可以通过 <code>src</code> 填上<strong>目标地址</strong>从而发出 <code>GET</code> 请求，<strong>实现跨域请求并拿到响应</strong>。这也就是 <code>JSONP</code> 的原理，接下来我们就来封装一个 <code>JSONP</code>:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">jsonp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> callbackName <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">generateURL</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> dataStr <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      dataStr <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&amp;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    dataStr <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">callback=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callbackName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">?</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">''</span> <span class="token operator">:</span> <span class="token string">'?'</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dataStr<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 初始化回调函数名称</span>
    callbackName <span class="token operator">=</span> callbackName <span class="token operator">||</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建 script 元素并加入到当前文档中</span>
    <span class="token keyword">const</span> scriptEle <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    scriptEle<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token function">generateURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>scriptEle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 绑定到 window 上，为了后面调用</span>
    window<span class="token punctuation">[</span>callbackName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// script 执行完了，成为无用元素，需要清除</span>
      document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>scriptEle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>当然在服务端也会有响应的操作, 以 <code>express</code> 为例:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> callback <span class="token punctuation">}</span> <span class="token operator">=</span> req<span class="token punctuation">.</span>query<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
  <span class="token comment">// 注意哦，返回给script标签，浏览器直接把这部分&quot;字符串回调函数&quot;执行</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callback<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">('数据包xxx')</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>然后前端这样简单地调用一下就好了:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 请求地址</span>
  url<span class="token operator">:</span> <span class="token string">'http://localhost:3000'</span><span class="token punctuation">,</span>
  params<span class="token operator">:</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    b<span class="token operator">:</span> <span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拿到数据进行处理</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 数据包</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>和<code>CORS</code>相比，<code>JSONP</code> 最大的优势在于兼容性好，IE 低版本不能使用 <code>CORS</code> 但可以使用 <code>JSONP</code>，缺点也很明显，请求方法单一，<strong>只支持 GET 请求</strong>。</p> <h3 id="nginx"><a href="#nginx" class="header-anchor">#</a> Nginx</h3> <p><code>Nginx</code> 是一种高性能的<strong>反向代理服务器</strong>，可以用来轻松<strong>解决跨域问题</strong>。</p> <p><code>what</code>？反向代理？我给你看一张图你就懂了。</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffd97d0b1cf15?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p><strong>正向代理</strong>帮助客户端<strong>访问</strong>客户端<strong>自己访问不到</strong>的服务器，然后将结果返回给客户端。</p> <p>反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的<strong>负载均衡</strong>，换句话说，<strong>反向代理帮其它的服务器拿到请求</strong>，然后<strong>选择一个合适的服务器</strong>，将<strong>请求转交</strong>给它。</p> <p>比如我们去银行办理业务，首先我们会去找个取号机，然后取出我们的号码以及对应的办理柜台，这个取号机就相当于上面说的<code>nginx</code>，它可以帮我们将业务分配到<strong>合适的柜台</strong>(当前最少人的，有空闲时间的)办理，这也就相当于<strong>负载均衡</strong>的作用。</p> <p>好了，那 Nginx 是如何来解决跨域的呢？</p> <p>比如说现在客户端的域名为<code>client.com</code>，服务器的域名为<code>server.com</code>，客户端向服务器发送 <code>Ajax</code> 请求，当然会跨域了，那这个时候让 Nginx 登场了，通过下面这个配置:</p> <div class="language-js extra-class"><pre class="language-js"><code>server <span class="token punctuation">{</span>
  listen  <span class="token number">80</span><span class="token punctuation">;</span>
  server_name  client<span class="token punctuation">.</span>com<span class="token punctuation">;</span>
  location <span class="token operator">/</span>api <span class="token punctuation">{</span>
    proxy_pass server<span class="token punctuation">.</span>com<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Nginx 相当于起了一个<strong>跳板机</strong>，这个<strong>跳板机</strong>的域名也是<code>client.com</code>，让客户端首先访问 <code>client.com/api</code>，这当然没有跨域，然后 <code>Nginx</code> 服务器作为反向代理，将<strong>请求转发</strong>给<code>server.com</code>，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。</p> <p>其实还有一些不太常用的方式，大家了解即可，比如 postMessage，当然 WebSocket 也是一种方式，但是已经不属于 HTTP 的范畴，另外一些奇技淫巧就不建议大家去死记硬背了，一方面从来不用，名字都难得记住，另一方面临时背下来，面试官也不会对你印象加分，因为看得出来是背的。当然没有背并不代表减分，把跨域原理和<strong>前面三种主要的跨域方式</strong>理解清楚，经得起更深一步的推敲，反而会让别人觉得你是一个靠谱的人。</p> <h2 id="_015-tls1-2-握手的过程是怎样的？"><a href="#_015-tls1-2-握手的过程是怎样的？" class="header-anchor">#</a> 015: TLS1.2 握手的过程是怎样的？</h2> <p>之前谈到了 HTTP 是明文传输的协议，传输保文对外完全透明，非常不安全，那如何进一步保证安全性呢？</p> <p>由此产生了 <code>HTTPS</code>，其实它并不是一个新的协议，而是在 HTTP 下面增加了一层 <code>SSL/TLS</code> 协议，简单的讲，<code>HTTPS = HTTP + SSL/TLS</code>。</p> <p>那什么是 <code>SSL/TLS</code> 呢？</p> <p>实际上以前是称为 <code>SSL</code>, 现在是<code>TLS</code></p> <p><code>SSL</code> 即<code>安全套接层（Secure Sockets Layer）</code>，在 <code>OSI</code> 七层模型中处于会话层(第 5 层)。之前 <code>SSL</code> 出过三个大版本，当它发展到<strong>第三个大版本</strong>的时候才被标准化，成为 <code>TLS</code>（传输层安全，<code>Transport Layer Security</code>），并被当做 <code>TLS1.0</code> 的版本，准确地说，<code>TLS1.0 = SSL3.1</code>。</p> <p>现在主流的版本是 <code>TLS/1.2</code>, 之前的 <code>TLS1.0、TLS1.1</code> 都被认为是不安全的，在不久的将来会被完全淘汰。因此我们接下来主要讨论的是 <code>TLS1.2</code>, 当然在 <code>2018</code> 年推出了更加优秀的 <code>TLS1.3</code>，大大优化了 <code>TLS</code> 握手过程，这个我们放在下一节再去说。</p> <p>TLS 握手的过程比较复杂，写文章之前我查阅了大量的资料，发现对 <code>TLS</code> 初学者非常不友好，也有很多知识点说的含糊不清，可以说这个整理的过程是相当痛苦了。希望我下面的拆解能够帮你理解得更顺畅些吧!</p> <h3 id="传统-rsa-握手"><a href="#传统-rsa-握手" class="header-anchor">#</a> 传统 RSA 握手</h3> <p>先来说说传统的 <code>TLS</code> 握手，也是大家在网上经常看到的。可以参考这篇文章，<a href="http://47.98.159.95/my_blog/browser-security/003.html" target="_blank" rel="noopener noreferrer">(传统 RSA 版本)<code>HTTPS</code>为什么让数据传输更安全<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，其中也介绍到了对称加密和非对称加密的概念，建议大家去读一读，不再赘述。之所以称它为 <code>RSA</code> 版本，是因为它在<code>加解密pre_random</code>的时候采用的是 <code>RSA</code> 算法。</p> <h4 id="tls-1-2-握手过程"><a href="#tls-1-2-握手过程" class="header-anchor">#</a> TLS 1.2 握手过程</h4> <p>现在我们来讲讲主流的 TLS 1.2 版本所采用的方式。</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffd9b35c7a81b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>刚开始你可能会比较懵，先别着急，过一遍下面的流程再来看会豁然开朗。</p> <h5 id="step-1-client-hello"><a href="#step-1-client-hello" class="header-anchor">#</a> step 1: Client Hello</h5> <p>首先，浏览器发送 <code>client_random、TLS版本、加密套件列表</code>。</p> <p><code>client_random</code> 是什么？用来最终 <code>secret</code> 的一个参数。</p> <p>加密套件列表是什么？我举个例子，加密套件列表一般长这样子:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">TLS_ECDHE_WITH_AES_128_GCM_SHA256</span><span class="token punctuation">;</span>
</code></pre></div><p>意思是<code>TLS</code>握手过程中，使用<code>ECDHE</code>算法生成<code>pre_random</code>(<strong>预随机数</strong>，这个数后面会介绍)，128 位的 AES 算法进行对称加密，在对称加密的过程中使用主流的 GCM 分组模式，因为对称加密中很重要的一个问题就是如何分组。最后一个是<strong>哈希摘要</strong>算法，采用 SHA256 算法。</p> <p>其中值得解释一下的是这个<strong>哈希摘要</strong>算法，试想一个这样的场景，服务端现在给客户端发消息来了，客户端并不知道此时的消息到底是服务端发的，还是中间人伪造的消息呢？现在引入这个哈希摘要算法，将服务端的证书信息通过<strong>这个算法</strong>生成一个摘要(可以理解为<strong>比较短的字符串</strong>)，用来<strong>标识</strong>这个服务端的<strong>身份</strong>，用私钥加密后把<strong>加密后的标识</strong>和<strong>自己的公钥</strong>传给客户端。客户端拿到这个<strong>公钥来解密</strong>，生成另外一份摘要。<strong>两个摘要进行对比</strong>，如果相同则能确认服务端的身份。这也就是所谓<strong>数字签名</strong>的原理。其中除了<strong>哈希算法</strong>，最重要的过程是<strong>私钥加密，公钥解密</strong>。</p> <h5 id="step-2-server-hello"><a href="#step-2-server-hello" class="header-anchor">#</a> step 2: Server Hello</h5> <p>可以看到服务器一口气给客户端回复了非常多的内容。</p> <p><code>server_random</code>也是最后生成<code>secret</code>的一个参数, 同时确认 <code>TLS</code> 版本、需要使用的<strong>加密套件</strong>和<strong>自己的证书</strong>，这都不难理解。那剩下的<code>server_params</code>是干嘛的呢？</p> <p>我们先埋个伏笔，现在你只需要知道，<code>server_random</code>到达了客户端。</p> <h5 id="step-3-client-验证证书，生成-secret"><a href="#step-3-client-验证证书，生成-secret" class="header-anchor">#</a> step 3: Client 验证证书，生成 secret</h5> <p>客户端验证服务端传来的<code>证书</code>和<code>签名</code>是否通过，如果验证通过，则传递<code>client_params</code>这个参数给服务器。</p> <p>接着客户端通过<code>ECDHE</code>算法计算出<code>pre_random</code>，其中传入两个参数:<code>server_params</code>和<code>client_params</code>。现在你应该清楚这个两个参数的作用了吧，由于<code>ECDHE</code>基于<code>椭圆曲线离散对数</code>，这两个参数也称作<code>椭圆曲线的公钥</code>。</p> <p>客户端现在拥有了<code>client_random、server_random</code>和<code>pre_random</code>，接下来将这三个数通过一个伪随机数函数来计算出最终的<code>secret</code>。</p> <h5 id="step4-server-生成-secret"><a href="#step4-server-生成-secret" class="header-anchor">#</a> step4: Server 生成 secret</h5> <p>刚刚客户端不是传了<code>client_params</code>过来了吗？</p> <p>现在服务端开始用<code>ECDHE</code>算法生成<code>pre_random</code>，接着用和客户端同样的伪随机数函数生成最后的<code>secret</code>。</p> <h4 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项</h4> <p>TLS 的过程基本上讲完了，但还有两点需要注意。</p> <p><strong>第一</strong>、实际上 <code>TLS</code> 握手是一个<strong>双向认证</strong>的过程，从 <code>step1</code> 中可以看到，客户端有能力验证服务器的身份，那服务器能不能验证客户端的身份呢？</p> <p>当然是可以的。具体来说，在 <code>step3</code> 中，客户端传送 <code>client_params</code> ，实际上给服务器传一个<strong>验证消息</strong>，让服务器将相同的验证流程(<code>哈希摘要 + 私钥加密 + 公钥解密</code>)走一遍，确认客户端的身份。</p> <p><strong>第二</strong>、当客户端生成 <code>secret</code> 后，会给服务端发送一个收尾的消息，告诉服务器之后的都用<strong>对称加密</strong>，<strong>对称加密</strong>的算法就用第一次约定的。服务器生成完<code>secret</code>也会向客户端发送一个收尾的消息，告诉客户端以后就直接用<strong>对称加密</strong>来通信。</p> <p>这个收尾的消息包括两部分，一部分是<code>Change Cipher Spec</code>，意味着后面加密传输了，另一个是<code>Finished</code>消息，这个消息是对之前所有发送的数据做的<strong>摘要</strong>，对摘要进行加密，让对方验证一下。</p> <p>当双方都验证通过之后，握手才正式结束。后面的 HTTP 正式开始传输加密报文。</p> <h4 id="rsa-和-ecdhe-握手过程的区别"><a href="#rsa-和-ecdhe-握手过程的区别" class="header-anchor">#</a> RSA 和 ECDHE 握手过程的区别</h4> <ol><li><p><code>ECDHE</code> 握手，也就是主流的 <code>TLS1.2</code> 握手中，使用<code>ECDHE</code>实现<code>pre_random</code>的加密解密，没有用到 <code>RSA</code>。</p></li> <li><p>使用 <code>ECDHE</code> 还有一个特点，就是客户端发送完收尾消息后可以提前<code>抢跑</code>，<strong>直接发送</strong> <code>HTTP 报文</code>，节省了一个 <code>RTT</code> ，不必等到收尾消息到达服务器，然后等服务器返回收尾消息给自己，<strong>直接开始发请求</strong>。这也叫<code>TLS False Start</code>。</p></li></ol> <h3 id="_016-tls-1-3-做了哪些改进"><a href="#_016-tls-1-3-做了哪些改进" class="header-anchor">#</a> 016: TLS 1.3 做了哪些改进</h3> <p>TLS 1.2 虽然存在了 10 多年，经历了无数的考验，但历史的车轮总是不断向前的，为了获得<strong>更强的安全、更优秀的性能</strong>，在 2018 年就推出了 <code>TLS1.3</code>，对于 <code>TLS1.2</code> 做了一系列的改进，主要分为这几个部分:<strong>强化安全、提高性能</strong>。</p> <h4 id="强化安全"><a href="#强化安全" class="header-anchor">#</a> 强化安全</h4> <p>在 TLS1.3 中废除了非常多的加密算法，最后只保留五个加密套件:</p> <ul><li>TLS_AES_128_GCM_SHA256</li> <li>TLS_AES_256_GCM_SHA384</li> <li>TLS_CHACHA20_POLY1305_SHA256</li> <li>TLS_AES_128_GCM_SHA256</li> <li>TLS_AES_128_GCM_8_SHA256</li></ul> <p>可以看到，最后剩下的对称加密算法只有 <code>AES</code> 和 <code>CHACHA20</code>，之前主流的也用这两种。<strong>分组模式</strong>也只剩下 <code>GCM</code> 和 <code>POLY1305</code>, <strong>哈希摘要算法</strong>只剩下了 <code>SHA256</code> 和 <code>SHA384</code> 了。</p> <p>那你可能会问了, 之前<code>RSA</code>这么重要的<strong>非对称加密算法</strong>怎么不在了？</p> <p>我觉得有两方面的原因:</p> <p><strong>第一</strong>、2015 年发现了<code>FREAK</code>攻击，即已经有人发现了 RSA 的漏洞，能够进行破解了。</p> <p><strong>第二</strong>、一旦私钥泄露，那么中间人可以通过私钥计算出之前所有报文的<code>secret</code>，破解之前所有的密文。</p> <p>为什么？
回到 <code>RSA</code> 握手的过程中，客户端拿到服务器的证书后，提取出服务器的公钥，然后生成<code>pre_random</code>并用<strong>公钥加密</strong>传给服务器，服务器通过<strong>私钥解密</strong>，从而拿到真实的<code>pre_random</code>。当中间人拿到了<strong>服务器私钥</strong>，并且截获之前所有报文的时候，那么就能拿到<code>pre_random、server_random</code>和<code>client_random</code>并根据对应的<strong>随机数函数</strong>生成<code>secret</code>，也就是拿到了 <code>TLS</code> 最终的<strong>会话密钥</strong>，每一个历史报文都能通过这样的方式进行破解。</p> <p>但<code>ECDHE</code>在每次握手时都会生成临时的密钥对，即使私钥被破解，之前的历史消息并不会收到影响。这种一次破解并不影响历史信息的性质也叫前向安全性。</p> <p><code>RSA</code> 算法不具备<strong>前向安全性</strong>，而 <code>ECDHE</code> 具备，因此在 <code>TLS1.3</code> 中彻底取代了<code>RSA</code>。</p> <h4 id="提升性能"><a href="#提升性能" class="header-anchor">#</a> 提升性能</h4> <h5 id="握手改进"><a href="#握手改进" class="header-anchor">#</a> 握手改进</h5> <p>流程如下:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffda75857d404?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>大体的方式和 <code>TLS1.2</code> 差不多，不过和 <code>TLS1.2</code> 相比少了一个 <code>RTT</code>(<code>Round-Trip Time</code>往返时间)， 服务端不必等待对方验证证书之后才拿到<code>client_params</code>，而是直接在第一次握手的时候就能够拿到, 拿到之后立即计算<code>secret</code>，节省了之前不必要的等待时间。同时，这也意味着在第一次握手的时候客户端需要传送更多的信息，一口气给传完。</p> <p>这种 <code>TLS 1.3</code> 握手方式也被叫做<code>1-RTT</code>握手。但其实这种<code>1-RTT</code>的握手方式还是有一些优化的空间的，接下来我们来一一介绍这些优化方式。</p> <h5 id="会话复用"><a href="#会话复用" class="header-anchor">#</a> 会话复用</h5> <p>会话复用有两种方式: <code>Session ID</code>和<code>Session Ticket</code>。</p> <p>先说说最早出现的<code>Seesion ID</code>，具体做法是客户端和服务器首次连接后<strong>各自保存会话的 ID</strong>，并<strong>存储</strong>会话密钥，当再次连接时，客户端发送<code>ID</code>过来，服务器查找这个 <code>ID</code> 是否存在，如果找到了就直接复用之前的会话状态，会话密钥不用重新生成，直接用原来的那份。</p> <p>但这种方式也存在一个弊端，就是当客户端数量庞大的时候，对服务端的<strong>存储压力</strong>非常大。</p> <p>因而出现了第二种方式——<code>Session Ticket</code>。它的思路就是: 服务端的压力大，那就把压力<strong>分摊</strong>给客户端呗。具体来说，双方连接成功后，服务器<strong>加密会话信息</strong>，用<code>Session Ticket</code>消息发给客户端，让客户端<strong>保存</strong>下来。下次<strong>重连</strong>的时候，就把这个 <code>Ticket</code> 进行解密，验证它过没过期，如果没过期那就直接恢复之前的会话状态。</p> <p>这种方式虽然减小了服务端的存储压力，但与带来了安全问题，即每次用一个<strong>固定的密钥</strong>来解密 <code>Ticket</code> 数据，一旦黑客拿到这个密钥，之前所有的历史记录也被破解了。因此为了尽量避免这样的问题，密钥需要<strong>定期进行更换</strong>。</p> <p>总的来说，这些会话复用的技术在保证<code>1-RTT</code>的同时，也<strong>节省</strong>了生成会话密钥这些算法所消耗的<strong>时间</strong>，是一笔可观的性能提升。</p> <h5 id="psk"><a href="#psk" class="header-anchor">#</a> PSK</h5> <p>刚刚说的都是<code>1-RTT</code>情况下的优化，那能不能优化到<code>0-RTT</code>呢？</p> <p>答案是可以的。做法其实也很简单，在发送<code>Session Ticket</code>的同时<strong>带上应用数据</strong>，不用等到服务端确认，这种方式被称为<code>Pre-Shared Key</code>，即 <code>PSK</code>。</p> <p>这种方式虽然方便，但也带来了安全问题。中间人截获<code>PSK</code>的数据，不断向服务器重复发，类似于 TCP 第一次握手携带数据，增加了服务器被攻击的风险。</p> <h4 id="总结下"><a href="#总结下" class="header-anchor">#</a> 总结下</h4> <p><code>TLS1.3</code> 在 <code>TLS1.2</code> 的基础上废除了大量的算法，提升了安全性。同时利用<strong>会话复用</strong>节省了重新生成密钥的时间，利用 <code>PSK</code> 做到了 <code>0-RTT</code> 连接。</p> <h2 id="_017-http-2-有哪些改进？"><a href="#_017-http-2-有哪些改进？" class="header-anchor">#</a> 017: HTTP/2 有哪些改进？</h2> <p>由于 HTTPS 在<strong>安全</strong>方面已经做的非常好了，HTTP 改进的关注点放在了<strong>性能</strong>方面。对于 HTTP/2 而言，它对于性能的提升主要在于两点:</p> <ul><li><strong>头部压缩</strong></li> <li><strong>多路复用</strong></li></ul> <p>当然还有一些颠覆性的功能实现:</p> <ul><li><strong>设置请求优先级</strong></li> <li><strong>服务器推送</strong></li></ul> <p>这些重大的提升本质上也是为了解决 <code>HTTP</code> 本身的问题而产生的。接下来我们来看看 <code>HTTP/2</code> 解决了哪些问题，以及解决方式具体是如何的。</p> <h3 id="头部压缩"><a href="#头部压缩" class="header-anchor">#</a> 头部压缩</h3> <p>在 <code>HTTP/1.1</code> 及之前的时代，请求体一般会有相应的压缩编码过程，通过<code>Content-Encoding</code>头部字段来指定，但你有没有想过头部字段本身的压缩呢？当请求字段非常复杂的时候，尤其对于 GET 请求，请求报文几乎全是请求头，这个时候还是存在非常大的优化空间的。HTTP/2 针对头部字段，也采用了对应的压缩算法——<code>HPACK</code>，<strong>对请求头进行压缩</strong>。</p> <p><code>HPACK</code> 算法是专门为 <code>HTTP/2</code> 服务的，它主要的亮点有两个：</p> <ul><li>首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把索引(比如 0，1，2，...)传给对方即可，对方拿到索引查表就行了。这种传索引的方式，可以说让请求头字段得到极大程度的精简和复用。</li></ul> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffdaa6f41c004?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <blockquote><p>HTTP/2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个&quot;:&quot;前缀，用来和其它请求头区分开。</p></blockquote> <ul><li>其次是对于整数和字符串进行<strong>哈夫曼编码</strong>，<strong>哈夫曼编码</strong>的原理就是先将所有出现的字符建立一张<strong>索引表</strong>，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong>索引序列</strong>，可以达到非常高的压缩率。</li></ul> <h3 id="多路复用"><a href="#多路复用" class="header-anchor">#</a> 多路复用</h3> <h4 id="http-队头阻塞"><a href="#http-队头阻塞" class="header-anchor">#</a> HTTP 队头阻塞</h4> <p>我们之前讨论了 <code>HTTP</code> 队头阻塞的问题，其根本原因在于 <code>HTTP</code> 基于<strong>请求-响应</strong>的模型，在同一个 <code>TCP 长连接</code>中，前面的请求没有得到响应，后面的请求就会被阻塞。</p> <p>后面我们又讨论到用<strong>并发连接</strong>和<strong>域名分片</strong>的方式来解决这个问题，但这并没有真正从 <code>HTTP</code> 本身的层面解决问题，只是增加了 <code>TCP</code> 连接，<strong>分摊风险</strong>而已。而且这么做也有弊端，多条 <code>TCP</code> 连接会竞争有限的带宽，让真正优先级高的请求不能优先处理。</p> <p>而 <code>HTTP/2</code> 便从 <code>HTTP</code> 协议本身解决了队头阻塞问题。注意，这里并不是指的<code>TCP队头阻塞</code>，而是<code>HTTP队头阻塞</code>，两者并不是一回事。TCP 的队头阻塞是在数据包层面，单位是<strong>数据包</strong>，前一个报文没有收到便不会将后面收到的报文上传给 <code>HTTP</code>，而<code>HTTP</code> 的队头阻塞是在 <code>HTTP</code> <strong>请求-响应</strong>层面，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。</p> <p>那么 HTTP/2 如何来解决所谓的队头阻塞呢？</p> <h4 id="二进制分帧"><a href="#二进制分帧" class="header-anchor">#</a> 二进制分帧</h4> <p>首先，<code>HTTP/2</code> 认为明文传输对机器而言太麻烦了，不方便计算机的解析，因为对于文本而言会有多义性的字符，比如回车换行到底是内容还是分隔符，在内部需要用到状态机去识别，效率比较低。于是 <code>HTTP/2</code> 干脆把报文全部换成二进制格式，全部传输 01 串，方便了机器的解析。</p> <p>原来<code>Headers + Body</code>的报文格式如今被拆分成了一个个二进制的帧，用 Headers 帧存放头部字段，Data 帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。</p> <p>通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流(<code>Stream</code>)。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信，这就是多路复用的概念。</p> <p>可能你会有一个疑问，既然是乱序首发，那最后如何来处理这些乱序的数据帧呢？</p> <p>首先要声明的是，所谓的乱序，指的是不同 <code>ID</code> 的 <code>Stream</code> 是乱序的，但同一个 <code>Stream ID</code> 的帧一定是按顺序传输的。二进制帧到达后对方会将 <code>Stream ID</code> 相同的二进制帧组装成完整的请求报文和响应报文。当然，在二进制帧当中还有其他的一些字段，实现了优先级和流量控制等功能，我们放到下一节再来介绍。</p> <h4 id="服务器推送"><a href="#服务器推送" class="header-anchor">#</a> 服务器推送</h4> <p>另外值得一说的是 <code>HTTP/2</code> 的服务器推送(Server Push)。在 <code>HTTP/2</code> 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 <code>stream</code> 来给客户端发送消息，当 <code>TCP</code> 连接建立之后，比如浏览器请求一个 <code>HTML</code> 文件，服务器就可以在返回 <code>HTML</code> 的基础上，将 <code>HTML</code> 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。</p> <p><strong>总结</strong>:</p> <p>当然，<code>HTTP/2</code> 新增那么多的特性，是不是 <code>HTTP</code> 的语法要重新学呢？不需要，<code>HTTP/2</code> 完全兼容之前 <code>HTTP</code> 的语法和语义，如请求头、<code>URI</code>、状态码、头部字段都没有改变，完全不用担心。同时，在安全方面，<code>HTTP/2</code> 也支持 <code>TLS</code>，并且现在主流的浏览器都公开只支持加密的 <code>HTTP/2</code>, 因此你现在能看到的 <code>HTTP/2</code> 也基本上都是跑在 <code>TLS</code> 上面的了。最后放一张分层图给大家参考:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffdc6783132a5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <h2 id="_018-http-2-中的二进制帧是如何设计的？"><a href="#_018-http-2-中的二进制帧是如何设计的？" class="header-anchor">#</a> 018: HTTP/2 中的二进制帧是如何设计的？</h2> <h3 id="帧结构"><a href="#帧结构" class="header-anchor">#</a> 帧结构</h3> <p>HTTP/2 中传输的帧结构如下图所示:</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffdc9e9c25e93?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>接下来的一个字节是帧标志，里面一共有 <code>8</code> 个标志位，常用的有 <code>END_HEADERS</code> 表示头数据结束，<code>END_STREAM</code> 表示单方向数据发送结束。</p> <p>后 4 个字节是<code>Stream ID</code>, 也就是流标识符，有了它，接收方就能从乱序的<strong>二进制帧</strong>中选择出 <code>ID</code> 相同的帧，按顺序组装成<strong>请求/响应报文</strong>。</p> <h3 id="流的状态变化"><a href="#流的状态变化" class="header-anchor">#</a> 流的状态变化</h3> <p>从前面可以知道，在 <code>HTTP/2</code> 中，所谓的流，其实就是<strong>二进制帧</strong>的<strong>双向传输的序列</strong>。那么在 <code>HTTP/2</code> 请求和响应的过程中，流的状态是如何变化的呢？</p> <p><code>HTTP/2</code> 其实也是借鉴了 <code>TCP</code> 状态变化的思想，根据帧的标志位来实现具体的状态改变。这里我们以一个普通的<strong>请求-响应</strong>过程为例来说明：</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/22/170ffdcd0abdd1ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>最开始两者都是空闲状态，当客户端发送<code>Headers</code>帧后，开始分配<code>Stream ID</code>, 此时客户端的<strong>流</strong>打开, 服务端接收之后服务端的<strong>流</strong>也打开，两端的<strong>流</strong>都打开之后，就可以互相传递<strong>数据帧</strong>和<strong>控制帧</strong>了。</p> <p>当客户端要关闭时，向服务端发送<code>END_STREAM</code>帧，进入<strong>半关闭状态</strong>, 这个时候客户端只能接收数据，而不能发送数据。</p> <p>服务端收到这个<code>END_STREAM</code>帧后也进入<strong>半关闭状态</strong>，不过此时服务端的情况是只能发送数据，而不能接收数据。随后服务端也向客户端发送<code>END_STREAM</code>帧，表示数据发送完毕，双方进入关闭状态。</p> <p>如果下次要开启新的<code>流</code>，<code>流</code> ID 需要自增，直到上限为止，到达上限后开一个新的 TCP 连接<strong>重头开始计数</strong>。由于流 ID 字段长度为 4 个字节，最高位又被保留，因此范围是 <code>0 ~ 2的 31 次方</code>，大约 <code>21 亿个</code>。</p> <h3 id="流的特性"><a href="#流的特性" class="header-anchor">#</a> 流的特性</h3> <p>刚刚谈到了流的状态变化过程，这里顺便就来总结一下<code>流</code>传输的特性:</p> <ul><li>并发性。一个 <code>HTTP/2</code> 连接上可以<strong>同时发多个帧</strong>，这一点和 <code>HTTP/1</code> 不同。这也是实现多路复用的基础。</li> <li>自增性。流 <code>ID</code> 是不可重用的，而是会按顺序递增，达到上限之后又新开 <code>TCP</code> 连接从头开始。</li> <li>双向性。客户端和服务端都可以创建流，互不干扰，双方都可以作为<code>发送方</code>或者<code>接收方</code>。</li> <li>可设置优先级。可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li></ul> <h2 id="http-3-新特性"><a href="#http-3-新特性" class="header-anchor">#</a> HTTP/3 新特性</h2> <h3 id="_1-http-2-的缺点"><a href="#_1-http-2-的缺点" class="header-anchor">#</a> 1.HTTP/2 的缺点</h3> <p>虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，<strong>主要是底层支撑的 TCP 协议造成的</strong>。HTTP/2 的缺点主要有以下几点：</p> <ul><li>TCP 以及 TCP+TLS 建立连接的延时</li></ul> <p>HTTP/2 使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，<strong>这样就需要有两个握手延迟过程</strong>：</p> <p>① 在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。</p> <p>② 进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1~2 个 RTT。</p> <p>总之，在传输数据之前，我们需要花掉 3 ～ 4 个 RTT。</p> <ul><li>TCP 的队头阻塞并没有彻底解决</li></ul> <p>上文我们提到在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的。但当出现了丢包时，HTTP/2 的表现反倒不如 HTTP/1 了。因为 TCP 为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP/2 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP 连接中的所有请求（如下图）。而对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。</p> <p><img src="/blog/assets/img/http3-1.9dd45930.png" alt="http3-1.png"></p> <p>读到这里，可能就会有人考虑为什么不直接去修改 TCP 协议？其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。</p> <h3 id="_2-http-3-简介"><a href="#_2-http-3-简介" class="header-anchor">#</a> 2.HTTP/3 简介</h3> <p>Google 在推 <code>SPDY</code> 的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 <code>UDP</code> 协议的 <code>QUIC</code> 协议，让 <code>HTTP</code> 跑在 <code>QUIC</code> 上而不是 <code>TCP</code> 上。
而这个<code>HTTP over QUIC</code>就是 <code>HTTP</code> 协议的下一个大版本，<code>HTTP/3</code>。它在 <code>HTTP/2</code> 的基础上又实现了质的飞跃，真正<code>完美</code>地解决了<code>队头阻塞</code>问题。</p> <p><img src="/blog/assets/img/http3-2.1f41f7e1.png" alt="http3-2.png"></p> <p><code>QUIC</code> 虽然基于 <code>UDP</code>，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个 <code>QUIC</code> 新功能。不过 <code>HTTP/3</code> 目前还处于草案阶段，正式发布前可能会有变动，所以本文尽量不涉及那些不稳定的细节</p> <h3 id="_3-quic-新功能"><a href="#_3-quic-新功能" class="header-anchor">#</a> 3.QUIC 新功能</h3> <p>上面我们提到 QUIC 基于 UDP，而 UDP 是“无连接”的，根本就不需要“握手”和“挥手”，所以就比 TCP 来得快。此外 QUIC 也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似 HTTP/2 的“流”和“多路复用”，单个“流&quot;是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说 QUIC 协议有以下特点：</p> <ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。</li></ul> <p>虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</p> <ul><li>实现了快速握手功能。</li></ul> <p>由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。<strong>0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势</strong>。</p> <ul><li>集成了 TLS 加密功能。</li></ul> <p>目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</p> <ul><li>多路复用，彻底解决 TCP 中队头阻塞的问题</li></ul> <p>和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</p> <p><img src="/blog/assets/img/http3-3.6bd0e234.png" alt="http3-3.png"></p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ul><li><code>HTTP/1.1</code> 有两个主要的缺点：安全不足和性能不高。</li> <li><code>HTTP/2</code> 完全兼容 <code>HTTP/1</code>，是<strong>更安全的 HTTP、更快的 HTTPS</strong>，<strong>头部压缩、多路复用</strong>等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；</li> <li><code>QUIC</code> 基于 <code>UDP</code> 实现，是 <code>HTTP/3</code> 中的底层支撑协议，该协议基于 <code>UDP</code>，又取了 <code>TCP</code> 中的精华，实现了即快又可靠的协议</li></ul> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li><a href="https://blog.csdn.net/qq_34629352/article/details/78959707" target="_blank" rel="noopener noreferrer">encodeURI()和 encodeURIComponent() 区别<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="最后"><a href="#最后" class="header-anchor">#</a> 最后</h2> <p>文中若有不准确或错误的地方，欢迎指出，有兴趣可以的关注下<a href="https://github.com/GolderBrother" target="_blank" rel="noopener noreferrer">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>~</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2020/9/7 下午8:45:37</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/views/fe-interview/fuck-interview.html" class="prev">那些恶心的面试题</a></span> <span class="next"><a href="/blog/views/network/tcp-interview.html">TCP 协议灵魂之问，巩固你的网络底层基础</a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.74817549.js" defer></script><script src="/blog/assets/js/2.f761193d.js" defer></script><script src="/blog/assets/js/21.80a318b4.js" defer></script>
  </body>
</html>
