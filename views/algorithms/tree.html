<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- 为了可以访问第三方图床的图片，才添加了这句代码，如果你的图片是存在本地的，去掉这句代码即可 -->
    <meta id="referrer" name="referrer" content="never" />
    <!-- <meta id="referrer" name="referrer" content="always" /> -->
    <title>二叉树相关算法 | 全栈修炼</title>
    <meta name="description" content="GolderBrother的博客" />
    <link rel="icon" href="/blog/assets/favicon.ico">  <link rel="preload" href="/blog/assets/css/0.styles.2dde6c16.css" as="style"><link rel="preload" href="/blog/assets/js/app.74817549.js" as="script"><link rel="preload" href="/blog/assets/js/2.f761193d.js" as="script"><link rel="preload" href="/blog/assets/js/46.c95ab531.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.ea66aff3.js"><link rel="prefetch" href="/blog/assets/js/100.1650309e.js"><link rel="prefetch" href="/blog/assets/js/101.dd5cdc51.js"><link rel="prefetch" href="/blog/assets/js/102.81a755d8.js"><link rel="prefetch" href="/blog/assets/js/103.84d1e041.js"><link rel="prefetch" href="/blog/assets/js/104.6bb79eda.js"><link rel="prefetch" href="/blog/assets/js/105.ac0fa491.js"><link rel="prefetch" href="/blog/assets/js/106.e7f21162.js"><link rel="prefetch" href="/blog/assets/js/107.a932b9dd.js"><link rel="prefetch" href="/blog/assets/js/108.08337848.js"><link rel="prefetch" href="/blog/assets/js/109.0a8ac1ac.js"><link rel="prefetch" href="/blog/assets/js/11.2b17f742.js"><link rel="prefetch" href="/blog/assets/js/110.63f713ce.js"><link rel="prefetch" href="/blog/assets/js/111.3ded28af.js"><link rel="prefetch" href="/blog/assets/js/112.feb77183.js"><link rel="prefetch" href="/blog/assets/js/113.ca7a3dfe.js"><link rel="prefetch" href="/blog/assets/js/114.278aaabb.js"><link rel="prefetch" href="/blog/assets/js/115.3f930fa5.js"><link rel="prefetch" href="/blog/assets/js/116.0686a02f.js"><link rel="prefetch" href="/blog/assets/js/117.22090497.js"><link rel="prefetch" href="/blog/assets/js/118.d7f089fa.js"><link rel="prefetch" href="/blog/assets/js/119.3c8db627.js"><link rel="prefetch" href="/blog/assets/js/12.d4feb8d0.js"><link rel="prefetch" href="/blog/assets/js/120.e516c49a.js"><link rel="prefetch" href="/blog/assets/js/121.d702cc4d.js"><link rel="prefetch" href="/blog/assets/js/122.13d4f773.js"><link rel="prefetch" href="/blog/assets/js/123.6905c46b.js"><link rel="prefetch" href="/blog/assets/js/124.ccac9465.js"><link rel="prefetch" href="/blog/assets/js/125.3fad187d.js"><link rel="prefetch" href="/blog/assets/js/126.065c2aad.js"><link rel="prefetch" href="/blog/assets/js/127.d4aef2ae.js"><link rel="prefetch" href="/blog/assets/js/128.00766f11.js"><link rel="prefetch" href="/blog/assets/js/129.51d245ca.js"><link rel="prefetch" href="/blog/assets/js/13.21c8139a.js"><link rel="prefetch" href="/blog/assets/js/130.82b8009d.js"><link rel="prefetch" href="/blog/assets/js/131.fb8da159.js"><link rel="prefetch" href="/blog/assets/js/132.2484fde1.js"><link rel="prefetch" href="/blog/assets/js/133.177fe1b1.js"><link rel="prefetch" href="/blog/assets/js/134.5611fa2b.js"><link rel="prefetch" href="/blog/assets/js/135.4d1053c3.js"><link rel="prefetch" href="/blog/assets/js/136.2973975f.js"><link rel="prefetch" href="/blog/assets/js/137.7c44ba09.js"><link rel="prefetch" href="/blog/assets/js/138.16973a68.js"><link rel="prefetch" href="/blog/assets/js/139.2f797054.js"><link rel="prefetch" href="/blog/assets/js/14.8cf70ab3.js"><link rel="prefetch" href="/blog/assets/js/140.f94ba770.js"><link rel="prefetch" href="/blog/assets/js/141.69f9800f.js"><link rel="prefetch" href="/blog/assets/js/142.b567c447.js"><link rel="prefetch" href="/blog/assets/js/143.f1ee0ada.js"><link rel="prefetch" href="/blog/assets/js/144.138163b4.js"><link rel="prefetch" href="/blog/assets/js/145.e3bee357.js"><link rel="prefetch" href="/blog/assets/js/146.3a9fd8c7.js"><link rel="prefetch" href="/blog/assets/js/147.0b8e88a6.js"><link rel="prefetch" href="/blog/assets/js/148.81da2cf3.js"><link rel="prefetch" href="/blog/assets/js/149.d44d0121.js"><link rel="prefetch" href="/blog/assets/js/15.ea38d450.js"><link rel="prefetch" href="/blog/assets/js/150.7665d423.js"><link rel="prefetch" href="/blog/assets/js/151.1ab5f781.js"><link rel="prefetch" href="/blog/assets/js/152.620db4ac.js"><link rel="prefetch" href="/blog/assets/js/153.695d756f.js"><link rel="prefetch" href="/blog/assets/js/154.ee82e0a2.js"><link rel="prefetch" href="/blog/assets/js/155.d7bc8987.js"><link rel="prefetch" href="/blog/assets/js/156.95cf0d01.js"><link rel="prefetch" href="/blog/assets/js/157.76159f7e.js"><link rel="prefetch" href="/blog/assets/js/158.e27d7f12.js"><link rel="prefetch" href="/blog/assets/js/159.84d58dcb.js"><link rel="prefetch" href="/blog/assets/js/16.7794197c.js"><link rel="prefetch" href="/blog/assets/js/160.44f17ac0.js"><link rel="prefetch" href="/blog/assets/js/161.a9fc1420.js"><link rel="prefetch" href="/blog/assets/js/162.953ffb8f.js"><link rel="prefetch" href="/blog/assets/js/163.d4b64d04.js"><link rel="prefetch" href="/blog/assets/js/164.d718bdc2.js"><link rel="prefetch" href="/blog/assets/js/165.464562ce.js"><link rel="prefetch" href="/blog/assets/js/166.3486924a.js"><link rel="prefetch" href="/blog/assets/js/167.044ce06a.js"><link rel="prefetch" href="/blog/assets/js/168.81e22c48.js"><link rel="prefetch" href="/blog/assets/js/169.4c4a576c.js"><link rel="prefetch" href="/blog/assets/js/17.7083b50c.js"><link rel="prefetch" href="/blog/assets/js/170.4b71dfab.js"><link rel="prefetch" href="/blog/assets/js/171.d2051e87.js"><link rel="prefetch" href="/blog/assets/js/172.eeb81923.js"><link rel="prefetch" href="/blog/assets/js/173.aafb24fa.js"><link rel="prefetch" href="/blog/assets/js/174.2e261a79.js"><link rel="prefetch" href="/blog/assets/js/175.aafd75a2.js"><link rel="prefetch" href="/blog/assets/js/176.b7681070.js"><link rel="prefetch" href="/blog/assets/js/177.e9bdb5f5.js"><link rel="prefetch" href="/blog/assets/js/178.4a3ca305.js"><link rel="prefetch" href="/blog/assets/js/179.40201a86.js"><link rel="prefetch" href="/blog/assets/js/18.3dbb7741.js"><link rel="prefetch" href="/blog/assets/js/180.68c6346e.js"><link rel="prefetch" href="/blog/assets/js/181.326c1f42.js"><link rel="prefetch" href="/blog/assets/js/182.92780c32.js"><link rel="prefetch" href="/blog/assets/js/183.65f40b5a.js"><link rel="prefetch" href="/blog/assets/js/19.78fd69da.js"><link rel="prefetch" href="/blog/assets/js/20.be39648e.js"><link rel="prefetch" href="/blog/assets/js/21.80a318b4.js"><link rel="prefetch" href="/blog/assets/js/22.4040efb3.js"><link rel="prefetch" href="/blog/assets/js/23.dbb39e0a.js"><link rel="prefetch" href="/blog/assets/js/24.f27f8467.js"><link rel="prefetch" href="/blog/assets/js/25.448302be.js"><link rel="prefetch" href="/blog/assets/js/26.78106ffa.js"><link rel="prefetch" href="/blog/assets/js/27.2a65554d.js"><link rel="prefetch" href="/blog/assets/js/28.55501022.js"><link rel="prefetch" href="/blog/assets/js/29.af733838.js"><link rel="prefetch" href="/blog/assets/js/3.df759ff3.js"><link rel="prefetch" href="/blog/assets/js/30.8ce1d72b.js"><link rel="prefetch" href="/blog/assets/js/31.7925ec43.js"><link rel="prefetch" href="/blog/assets/js/32.f9892d98.js"><link rel="prefetch" href="/blog/assets/js/33.afd7fd02.js"><link rel="prefetch" href="/blog/assets/js/34.ee49fe13.js"><link rel="prefetch" href="/blog/assets/js/35.0e4f5335.js"><link rel="prefetch" href="/blog/assets/js/36.96311e99.js"><link rel="prefetch" href="/blog/assets/js/37.fb3163b1.js"><link rel="prefetch" href="/blog/assets/js/38.778ed95b.js"><link rel="prefetch" href="/blog/assets/js/39.0531a2e1.js"><link rel="prefetch" href="/blog/assets/js/4.bb581d32.js"><link rel="prefetch" href="/blog/assets/js/40.ec9153c6.js"><link rel="prefetch" href="/blog/assets/js/41.2e9e71db.js"><link rel="prefetch" href="/blog/assets/js/42.af718b8a.js"><link rel="prefetch" href="/blog/assets/js/43.7a4efaa6.js"><link rel="prefetch" href="/blog/assets/js/44.21916db9.js"><link rel="prefetch" href="/blog/assets/js/45.c02e6427.js"><link rel="prefetch" href="/blog/assets/js/47.d505fc9f.js"><link rel="prefetch" href="/blog/assets/js/48.9291572a.js"><link rel="prefetch" href="/blog/assets/js/49.79fd5fda.js"><link rel="prefetch" href="/blog/assets/js/5.cc289552.js"><link rel="prefetch" href="/blog/assets/js/50.40ff6888.js"><link rel="prefetch" href="/blog/assets/js/51.d16aa2b4.js"><link rel="prefetch" href="/blog/assets/js/52.4528f49d.js"><link rel="prefetch" href="/blog/assets/js/53.b16b42d4.js"><link rel="prefetch" href="/blog/assets/js/54.4fff7e01.js"><link rel="prefetch" href="/blog/assets/js/55.6832b1c5.js"><link rel="prefetch" href="/blog/assets/js/56.d16f1707.js"><link rel="prefetch" href="/blog/assets/js/57.de08e9ba.js"><link rel="prefetch" href="/blog/assets/js/58.6ca6f21b.js"><link rel="prefetch" href="/blog/assets/js/59.e518317a.js"><link rel="prefetch" href="/blog/assets/js/6.4efa9fa4.js"><link rel="prefetch" href="/blog/assets/js/60.935521f1.js"><link rel="prefetch" href="/blog/assets/js/61.ce9eda13.js"><link rel="prefetch" href="/blog/assets/js/62.e6c745bf.js"><link rel="prefetch" href="/blog/assets/js/63.647fd8d7.js"><link rel="prefetch" href="/blog/assets/js/64.4c9b4781.js"><link rel="prefetch" href="/blog/assets/js/65.80857907.js"><link rel="prefetch" href="/blog/assets/js/66.b89b796a.js"><link rel="prefetch" href="/blog/assets/js/67.b9798c32.js"><link rel="prefetch" href="/blog/assets/js/68.49b67f24.js"><link rel="prefetch" href="/blog/assets/js/69.665837ff.js"><link rel="prefetch" href="/blog/assets/js/7.b94332e9.js"><link rel="prefetch" href="/blog/assets/js/70.ce57ed8e.js"><link rel="prefetch" href="/blog/assets/js/71.71ae5067.js"><link rel="prefetch" href="/blog/assets/js/72.69c7c32d.js"><link rel="prefetch" href="/blog/assets/js/73.6b47b8f7.js"><link rel="prefetch" href="/blog/assets/js/74.bd6cd299.js"><link rel="prefetch" href="/blog/assets/js/75.297a83bc.js"><link rel="prefetch" href="/blog/assets/js/76.e49268ee.js"><link rel="prefetch" href="/blog/assets/js/77.6efa828f.js"><link rel="prefetch" href="/blog/assets/js/78.c38cb032.js"><link rel="prefetch" href="/blog/assets/js/79.478e1642.js"><link rel="prefetch" href="/blog/assets/js/8.80c6038b.js"><link rel="prefetch" href="/blog/assets/js/80.ff9e57e9.js"><link rel="prefetch" href="/blog/assets/js/81.e3dbf4d0.js"><link rel="prefetch" href="/blog/assets/js/82.270df640.js"><link rel="prefetch" href="/blog/assets/js/83.3bc7036f.js"><link rel="prefetch" href="/blog/assets/js/84.a3ccc99e.js"><link rel="prefetch" href="/blog/assets/js/85.7cdab723.js"><link rel="prefetch" href="/blog/assets/js/86.9f0c2ccd.js"><link rel="prefetch" href="/blog/assets/js/87.b7e93260.js"><link rel="prefetch" href="/blog/assets/js/88.557a99bb.js"><link rel="prefetch" href="/blog/assets/js/89.16a0d8d1.js"><link rel="prefetch" href="/blog/assets/js/9.4fbaf7a8.js"><link rel="prefetch" href="/blog/assets/js/90.52190781.js"><link rel="prefetch" href="/blog/assets/js/91.b9507740.js"><link rel="prefetch" href="/blog/assets/js/92.c0eb92c0.js"><link rel="prefetch" href="/blog/assets/js/93.ca3ba1d1.js"><link rel="prefetch" href="/blog/assets/js/94.a8ffcee7.js"><link rel="prefetch" href="/blog/assets/js/95.23fe688e.js"><link rel="prefetch" href="/blog/assets/js/96.b5d64bc6.js"><link rel="prefetch" href="/blog/assets/js/97.c41d4d64.js"><link rel="prefetch" href="/blog/assets/js/98.c415501d.js"><link rel="prefetch" href="/blog/assets/js/99.ab069b22.js"> <link rel="stylesheet" href="/blog/assets/css/0.styles.2dde6c16.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/assets/logo.jpg" alt="全栈修炼" class="logo"> <span class="site-name can-hide">全栈修炼</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/guide/" class="nav-link">主页</a></div><div class="nav-item"><a href="/blog/views/" class="nav-link router-link-active">大前端</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Select language" class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/views/algorithms/tree.html" class="nav-link router-link-exact-active router-link-active">zh-CN</a></li><li class="dropdown-item"><!----> <a href="/blog/en/" class="nav-link">en-US</a></li></ul></div></div> <a href="https://github.com/GolderBrother/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/guide/" class="nav-link">主页</a></div><div class="nav-item"><a href="/blog/views/" class="nav-link router-link-active">大前端</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Select language" class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/views/algorithms/tree.html" class="nav-link router-link-exact-active router-link-active">zh-CN</a></li><li class="dropdown-item"><!----> <a href="/blog/en/" class="nav-link">en-US</a></li></ul></div></div> <a href="https://github.com/GolderBrother/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/blog/views/" class="sidebar-link">大前端知识大集合</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>GitHub 软技能</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/github/follow.html" class="sidebar-link">GitHub 挖宝技巧</a></li><li><a href="/blog/views/github/star.html" class="sidebar-link">GitHub 吸星大法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器工作原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/browser/input-url-course.html" class="sidebar-link">导航流程：从输入 URL 到页面展示，这中间发生了什么</a></li><li><a href="/blog/views/browser/dom-bind-event.html" class="sidebar-link">一个DOM元素绑定多个事件时，先执行冒泡还是捕获</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>css</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/css/css-skills1.html" class="sidebar-link">10 个让你受益匪浅的 css 使用技巧</a></li><li><a href="/blog/views/css/css-knowledge.html" class="sidebar-link">你未必知道的 49 个 CSS 知识点</a></li><li><a href="/blog/views/css/css-knowledge2.html" class="sidebar-link">你未必知道的 49 个 CSS 知识点二~</a></li><li><a href="/blog/views/css/css-center.html" class="sidebar-link">一起搞懂 CSS 水平居中与垂直居中的 16 个方法</a></li><li><a href="/blog/views/css/css-flex.html" class="sidebar-link">弹性盒子中 flex: 0 1 auto 表示什么意思</a></li><li><a href="/blog/views/css/css-BFC.html" class="sidebar-link">CSS 中的 BFC 详解</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>移动端h5</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/h5/h5-demo1.html" class="sidebar-link">移动端 H5 和 Hybrid 相关基础技术概览</a></li><li><a href="/blog/views/mobile/mobile-skill.html" class="sidebar-link">总结移动端 H5 开发常用技巧</a></li><li><a href="/blog/views/mobile/mobile-optmization.html" class="sidebar-link">关于移动端体验优化经验总结</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Javascript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/javascript/js-skills.html" class="sidebar-link">你可能不知道的 JS 开发技巧</a></li><li><a href="/blog/views/javascript/js-skills2.html" class="sidebar-link">一个合格的中级前端er需要掌握的 28 个 JavaScript 技巧</a></li><li><a href="/blog/views/javascript/js-utils.html" class="sidebar-link">书到用时方恨少，一大波 JS 开发工具函数来了</a></li><li><a href="/blog/views/javascript/js-utils2.html" class="sidebar-link">前端常用的 60 余种工具方法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Typescript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/typescript/ts-demo.html" class="sidebar-link">TypeScript 高级用法详解</a></li><li><a href="/blog/views/typescript/ts-difficult.html" class="sidebar-link">TypeScript 重难点梳理</a></li><li><a href="/blog/views/typescript/ts-problem.html" class="sidebar-link">TS 常见问题整理（60 多个）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue.js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/vue/vue-ts.html" class="sidebar-link">Vue + TS + El 搭建博客及踩坑记</a></li><li><a href="/blog/views/vue/vue-lazyload.html" class="sidebar-link">vue 路由懒加载及组件懒加载</a></li><li><a href="/blog/views/vue/vue-skills-36.html" class="sidebar-link">Vue 开发必须知道的 36 个技巧</a></li><li><a href="/blog/views/vue/vue-interview.html" class="sidebar-link">30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度）</a></li><li><a href="/blog/views/vue/vue-interview/part-one/note.html" class="sidebar-link">Vue 面试题汇总</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React.js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/react/react-hooks.html" class="sidebar-link">React Hooks 相关 API 总结</a></li><li><a href="/blog/views/react/react-lifecycle.html" class="sidebar-link">React v16.0 前的生命周期</a></li><li><a href="/blog/views/react/react-skill.html" class="sidebar-link">5 个技巧助你编写更好的 React 代码</a></li><li><a href="/blog/views/react/react-nice-library.html" class="sidebar-link">5 个很棒的 React.js 库，值得你亲手试试！</a></li><li><a href="/blog/views/react/react-interview.html" class="sidebar-link">35 道咱们必须要清楚的 React 面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React-Native</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/react-native/RN&amp;Native-message.html" class="sidebar-link">React Native 跟原生之间的通信</a></li><li><a href="/blog/views/react-native/ReactNative&amp;Flutter&amp;uni-app.html" class="sidebar-link">一、技术学习成本和难度</a></li><li><a href="/blog/views/react-native/ReactNative&amp;Flutter&amp;uni-app.html" class="sidebar-link">一、技术学习成本和难度</a></li><li><a href="/blog/views/react-native/codepush-config.html" class="sidebar-link">RN 配置热更新+使用文档</a></li><li><a href="/blog/views/react-native/codepush-deploy.html" class="sidebar-link">React Native + 热更新(Code Push) 部署文档</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/webpack/webpack1.html" class="sidebar-link">一大波 Webpack 面试题来啦~</a></li><li><a href="/blog/views/webpack/webpack-optimize.html" class="sidebar-link">webpack 优化篇</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端跨域相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/cors/corssOrigin-pro.html" class="sidebar-link">10 种跨域解决方案（附终极方案）</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>vite</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/vite/vite-study.html" class="sidebar-link">vite原理剖析</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>cli</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/cli/james-cli.html" class="sidebar-link">手撸一个自己的前端脚手架</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Node.js</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/node/node1.html" class="sidebar-link">/views/node/node1.html</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端设计模式之美</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/fe-design/fe-design-9.html" class="sidebar-link">前端应知应会的 9 种设计模式(详细篇)</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端数据结构之美</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/data-structure/data-structure.html" class="sidebar-link">前端数据结构之美</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端算法学习指南</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/algorithms/sort.html" class="sidebar-link">十大经典算法</a></li><li><a href="/blog/views/algorithms/interview.html" class="sidebar-link">面试必刷-《剑指 offer》刷题小结</a></li><li><a href="/blog/views/algorithms/string.html" class="sidebar-link">字符串相关算法</a></li><li><a href="/blog/views/algorithms/array.html" class="sidebar-link">数组串相关算法</a></li><li><a href="/blog/views/algorithms/linklist.html" class="sidebar-link">链表相关算法题</a></li><li><a href="/blog/views/algorithms/tree.html" class="active sidebar-link">二叉树相关算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#_1-剑指-offer-07-重建二叉树" class="sidebar-link">1. 剑指 Offer 07. 重建二叉树</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#_98-验证二叉搜索树" class="sidebar-link">98. 验证二叉搜索树</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#剑指-offer-28-对称的二叉树" class="sidebar-link">剑指 Offer 28. 对称的二叉树</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#剑指-offer-55-ii-平衡二叉树" class="sidebar-link">剑指 Offer 55 - II. 平衡二叉树</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#剑指-offer-27-二叉树的镜像" class="sidebar-link">剑指 Offer 27. 二叉树的镜像</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#剑指-offer-55-i-二叉树的深度" class="sidebar-link">剑指 Offer 55 - I. 二叉树的深度</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#_236-二叉树的最近公共祖先" class="sidebar-link">236. 二叉树的最近公共祖先</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#_144-二叉树的前序遍历" class="sidebar-link">144. 二叉树的前序遍历</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#_94-二叉树的中序遍历" class="sidebar-link">94. 二叉树的中序遍历</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#_145-二叉树的后序遍历" class="sidebar-link">145. 二叉树的后序遍历</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#_102-二叉树的层序遍历" class="sidebar-link">102. 二叉树的层序遍历</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#剑指-offer-32-i-从上到下打印二叉树" class="sidebar-link">剑指 Offer 32 - I. 从上到下打印二叉树</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#剑指-offer-32-ii-从上到下打印二叉树-ii" class="sidebar-link">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#剑指-offer-32-iii-从上到下打印二叉树-iii" class="sidebar-link">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#剑指-offer-54-二叉搜索树的第k大节点" class="sidebar-link">剑指 Offer 54. 二叉搜索树的第k大节点</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#剑指-offer-33-二叉搜索树的后序遍历序列" class="sidebar-link">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#剑指-offer-34-二叉树中和为某一值的路径" class="sidebar-link">剑指 Offer 34. 二叉树中和为某一值的路径</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#_559-n叉树的最大深度" class="sidebar-link">559. N叉树的最大深度</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#_590-n叉树的后序遍历" class="sidebar-link">590. N叉树的后序遍历</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#_429-n叉树的层序遍历" class="sidebar-link">429. N叉树的层序遍历</a></li><li class="sidebar-sub-header"><a href="/blog/views/algorithms/tree.html#最后" class="sidebar-link">最后</a></li></ul></li><li><a href="/blog/views/algorithms/tencent/array&amp;string.html" class="sidebar-link">腾讯算法题-数组与字符串</a></li><li><a href="/blog/views/algorithms/tencent/number.html" class="sidebar-link">腾讯算法题-数学与数字</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端面试集锦</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/fe-interview/alibaba.html" class="sidebar-link">阿里面试题</a></li><li><a href="/blog/views/fe-interview/bytedance.html" class="sidebar-link">字节跳动面试题</a></li><li><a href="/blog/views/fe-interview/bytedance-algorithms.html" class="sidebar-link">字节跳动算法题</a></li><li><a href="/blog/views/fe-interview/tencent.html" class="sidebar-link">微信面试题</a></li><li><a href="/blog/views/fe-interview/classic-layout.html" class="sidebar-link">掌握两大经典布局方案</a></li><li><a href="/blog/views/fe-interview/web-safe.html" class="sidebar-link">谈谈 web 安全问题及解决方案</a></li><li><a href="/blog/views/fe-interview/http&amp;https.html" class="sidebar-link">http2/http3 协议有什么优劣</a></li><li><a href="/blog/views/fe-interview/webpack-performance-optimization.html" class="sidebar-link">Webpack 性能优化你知道哪些</a></li><li><a href="/blog/views/fe-interview/webpack-principle.html" class="sidebar-link">说说 webpack 打包的原理</a></li><li><a href="/blog/views/fe-interview/webpack-HMR.html" class="sidebar-link">HMR 的原理是什么</a></li><li><a href="/blog/views/fe-interview/chrome-start-process.html" class="sidebar-link">Chrome 打开一个页面需要启动多少进程？分别有哪些进程</a></li><li><a href="/blog/views/fe-interview/dns-prefetch.html" class="sidebar-link">谈谈你对 dns-prefetch 的理解</a></li><li><a href="/blog/views/fe-interview/browser-cache.html" class="sidebar-link">浏览器缓存一探究竟~</a></li><li><a href="/blog/views/fe-interview/send-content-to-browser.html" class="sidebar-link">如何保证页面文件能被完整送达浏览器</a></li><li><a href="/blog/views/fe-interview/browser-render.html" class="sidebar-link">浏览器渲染过程是怎样的</a></li><li><a href="/blog/views/fe-interview/browser-reflow&amp;repain.html" class="sidebar-link">如何理解回流和重绘</a></li><li><a href="/blog/views/fe-interview/renderEngine-createNewLayer.html" class="sidebar-link">渲染引擎什么情况下才会为特定的节点创建新的图层</a></li><li><a href="/blog/views/fe-interview/UDP&amp;TCP-different.html" class="sidebar-link">UDP 和 TCP 有什么区别</a></li><li><a href="/blog/views/fe-interview/js-modules.html" class="sidebar-link">说说 js 的模块化</a></li><li><a href="/blog/views/fe-interview/lazyMan.html" class="sidebar-link">实现一个 LazyMan，可以按照以下方式调用</a></li><li><a href="/blog/views/fe-interview/handwriting-promise.html" class="sidebar-link">少年，来，手写一个 Promise 吧</a></li><li><a href="/blog/views/fe-interview/fetch&amp;ajax-diference.html" class="sidebar-link">请说下 fetch 和 ajax 的区别吧</a></li><li><a href="/blog/views/fe-interview/browser-input-url.html" class="sidebar-link">细说浏览器输入 URL 后发生了什么</a></li><li><a href="/blog/views/fe-interview/picture-optimization.html" class="sidebar-link">前端的图片优化方案你知道多少</a></li><li><a href="/blog/views/fe-interview/node-eventLoop.html" class="sidebar-link">来，说说 node 的事件循环机制吧</a></li><li><a href="/blog/views/fe-interview/browser-eventLoop.html" class="sidebar-link">小伙子，谈谈浏览器端的事件循环吧</a></li><li><a href="/blog/views/fe-interview/setTimeout&amp;setImmediate.html" class="sidebar-link">node中的setTimeout 和 setImmediate有什么区别</a></li><li><a href="/blog/views/fe-interview/js-interview.html" class="sidebar-link">收集一些 javascript 相关的面试题</a></li><li><a href="/blog/views/fe-interview/fuck-interview.html" class="sidebar-link">那些恶心的面试题</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端必知必会的网络基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/network/http-interview.html" class="sidebar-link">HTTP 灵魂之问，巩固你的 HTTP 知识体系</a></li><li><a href="/blog/views/network/tcp-interview.html" class="sidebar-link">TCP 协议灵魂之问，巩固你的网络底层基础</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端应知应会的Nginx知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/nginx/nginx-details.html" class="sidebar-link">Nginx 从入门到实践，万字详解！</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端必不可少的git知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/git/git-command-animation.html" class="sidebar-link">相见恨晚的 Git 命令动画演示，一看就懂！</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端性能优化专题，让你的网站飞起来吧</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/performance/code-split.html" class="sidebar-link">项目不知道如何做性能优化？不妨试试代码分割吧</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端高手进阶专题，告别小菜鸟</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/views/fe-advanced/ad1.html" class="sidebar-link">你真的熟悉 HTML 标签吗？</a></li><li><a href="/blog/views/fe-advanced/ad2.html" class="sidebar-link">如何高效操作 DOM 元素？</a></li><li><a href="/blog/views/fe-advanced/ad3.html" class="sidebar-link">3 个使用场景助你用好 DOM 事件</a></li><li><a href="/blog/views/fe-advanced/ad6.html" class="sidebar-link">浏览器如何渲染页面？</a></li><li><a href="/blog/views/fe-advanced/ad7.html" class="sidebar-link">关于 JavaScript 的数据类型，你知多少</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="二叉树相关算法"><a href="#二叉树相关算法" class="header-anchor">#</a> 二叉树相关算法</h1> <h2 id="_1-剑指-offer-07-重建二叉树"><a href="#_1-剑指-offer-07-重建二叉树" class="header-anchor">#</a> 1. 剑指 Offer 07. 重建二叉树</h2> <p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener noreferrer">题目地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字</p> <p>前序遍历 preorder = [3, 9, 20, 15, 7]
中序遍历 inorder = [9, 3, 15, 20, 7]</p> <p>返回如下的二叉树：</p> <div class="language- extra-class"><pre class="language-text"><code>     3
    / \
   9  20
  /     \
15       7
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val; 
 *     this.left = this.right = null; 
 * }
 */</span>
<span class="token comment">/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */</span>

<span class="token keyword">var</span> <span class="token function-variable function">buildTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> inorder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>preorder<span class="token punctuation">.</span>length <span class="token operator">||</span> <span class="token operator">!</span>inorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 前序遍历：根 -&gt; 左 -&gt; 右</span>
    <span class="token comment">// 中序遍历：左 -&gt; 根 -&gt; 右</span>
    <span class="token keyword">const</span> rootValue <span class="token operator">=</span> preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootValue<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// index有两个含义，一个是根节点在中序遍历结果中的下标，另一个是当前左子树的节点个数</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
        len <span class="token operator">=</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">===</span> rootValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取前序和中序所有的左节点</span>
    node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取前序和中序所有的右节点</span>
    node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> node<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="_98-验证二叉搜索树"><a href="#_98-验证二叉搜索树" class="header-anchor">#</a> 98. 验证二叉搜索树</h2> <p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p> <p>假设一个二叉搜索树具有如下特征：</p> <p>节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。</p> <p>示例 1:</p> <p>输入:</p> <div class="language- extra-class"><pre class="language-text"><code>    2
   / \
  1   3
</code></pre></div><p>输出: true</p> <p>示例 1:</p> <p>输入:</p> <div class="language- extra-class"><pre class="language-text"><code>    2
   / \
  1   3
</code></pre></div><p>输出: true</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">isValidBST</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> min<span class="token punctuation">,</span> max</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment">// 在(min, max) 区间的数才是正常的</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> min <span class="token operator">||</span> root<span class="token punctuation">.</span>val <span class="token operator">&gt;=</span> max<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">// 左子树节点的数范围应该在(min, root.val) 右子树节点的数范围应该在(root.val, max); </span>
        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> min<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 输入的值应该在-Infinity~Infinity之间才算对</span>
    <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">,</span> <span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="剑指-offer-28-对称的二叉树"><a href="#剑指-offer-28-对称的二叉树" class="header-anchor">#</a> 剑指 Offer 28. 对称的二叉树</h2> <p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p> <p>例如，二叉树 [1, 2, 2, 3, 4, 4, 3] 是对称的。</p> <div class="language- extra-class"><pre class="language-text"><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre></div><p>但是下面这个 [1, 2, 2, null, 3, null, 3] 则不是镜像对称的:</p> <div class="language- extra-class"><pre class="language-text"><code>    1
   / \
  2   2
   \   \
   3    3
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {TreeNode} root
 * @return {boolean}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">isSymmetric</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token function">compare</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token parameter">leftNode<span class="token punctuation">,</span> rightNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftNode <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> rightNode <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment">// 只要左右子树中，有一个空的节点，或者左右节点值不一样，那就不是对称的</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftNode <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> rightNode <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> leftNode<span class="token punctuation">.</span>val <span class="token operator">!==</span> rightNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">// 递归比较子节点</span>
        <span class="token keyword">return</span> <span class="token function">compare</span><span class="token punctuation">(</span>leftNode<span class="token punctuation">.</span>left<span class="token punctuation">,</span> rightNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compare</span><span class="token punctuation">(</span>leftNode<span class="token punctuation">.</span>right<span class="token punctuation">,</span> rightNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="剑指-offer-55-ii-平衡二叉树"><a href="#剑指-offer-55-ii-平衡二叉树" class="header-anchor">#</a> 剑指 Offer 55 - II. 平衡二叉树</h2> <p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {TreeNode} root
 * @return {boolean}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">isBalanced</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment">// 左子树和右子树的深度不超过1，然后再判断左子树的子树和右子树的子树的深度不超过1</span>
        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">depth</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">// 判断二叉树的深度在于左子树的深度和右子树深度，两个值的最大值，再+1</span>
        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="剑指-offer-27-二叉树的镜像"><a href="#剑指-offer-27-二叉树的镜像" class="header-anchor">#</a> 剑指 Offer 27. 二叉树的镜像</h2> <p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p> <p>例如输入：</p> <div class="language- extra-class"><pre class="language-text"><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9
</code></pre></div><p>镜像输出：</p> <div class="language- extra-class"><pre class="language-text"><code>     4
   /   \
  7     2
 / \   / \
9   6 3   1
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 方法一：递归</span>
<span class="token keyword">function</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// 1. 递归终结条件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token comment">// 2. 处理当前层逻辑</span>
    <span class="token keyword">const</span> temp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token comment">// 3. 下探到下一层</span>
    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token comment">// 方法二：借助栈来迭代</span>
<span class="token keyword">function</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1. 出栈</span>
        <span class="token keyword">const</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2. 添加子节点： 将 nodenode 左和右子节点入栈；</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3. 交换子元素</span>
        <span class="token keyword">const</span> temp <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="剑指-offer-55-i-二叉树的深度"><a href="#剑指-offer-55-i-二叉树的深度" class="header-anchor">#</a> 剑指 Offer 55 - I. 二叉树的深度</h2> <p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p> <p>例如：</p> <p>给定二叉树 [3, 9, 20, null, null, 15, 7]，</p> <div class="language- extra-class"><pre class="language-text"><code>3
/ \
9  20
 /  \
15   7
</code></pre></div><p>返回它的最大深度 3 。</p> <h3 id="方法一：暴力递归"><a href="#方法一：暴力递归" class="header-anchor">#</a> 方法一：暴力递归</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">maxDepth</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 判断二叉树的深度在于左子树的深度和右子树深度，两个值的最大值，再+1</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h3 id="方法二：层次遍历"><a href="#方法二：层次遍历" class="header-anchor">#</a> 方法二：层次遍历</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">maxDepth</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
        queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">,</span>
        len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>len<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>left <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>right <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        height<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> height<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="_236-二叉树的最近公共祖先"><a href="#_236-二叉树的最近公共祖先" class="header-anchor">#</a> 236. 二叉树的最近公共祖先</h2> <p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof" target="_blank" rel="noopener noreferrer">传送门<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p> <p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p> <p>例如，给定如下二叉树:  root = [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]</p> <p>示例 1:</p> <p>输入: root = [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
示例 2:</p> <p>输入: root = [3, 5, 1, 6, 2, 0, 8, null, null, 7, 4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val; 
 *     this.left = this.right = null; 
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">lowestCommonAncestor</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// 如果root是null，说明我们在这条寻址线路没有找到，我们返回null表示没找到</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 最近公共祖先节点可以为节点本身</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> p <span class="token operator">||</span> root <span class="token operator">===</span> q<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token comment">// 左子树</span>
    <span class="token keyword">const</span> leftSubTree <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 右子树</span>
    <span class="token keyword">const</span> rightSubTree <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 左子树找不到，就返回右子树</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftSubTree <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> rightSubTree<span class="token punctuation">;</span>
    <span class="token comment">// 右子树找不到，就返回左子树</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rightSubTree <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> leftSubTree<span class="token punctuation">;</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_144-二叉树的前序遍历"><a href="#_144-二叉树的前序遍历" class="header-anchor">#</a> 144. 二叉树的前序遍历</h2> <p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener noreferrer">传送门<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>给定一个二叉树，返回它的 前序 遍历。</p> <p>示例:</p> <p>输入: [1, null, 2, 3]</p> <div class="language- extra-class"><pre class="language-text"><code>   1
    \
     2
    /
   3 
</code></pre></div><p>输出: [1, 2, 3]</p> <h3 id="方法一：递归法"><a href="#方法一：递归法" class="header-anchor">#</a> 方法一：递归法</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">preorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 前序遍历: 根 -&gt; 左 -&gt; 右</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 先处理根节点</span>
            res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 再递归处理左节点</span>
            <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 然后递归处理右节点</span>
            <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h3 id="方法二-栈迭代法"><a href="#方法二-栈迭代法" class="header-anchor">#</a> 方法二: 栈迭代法</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">preorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 出栈</span>
        <span class="token keyword">const</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        node <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 栈是先进后出(后进先出)，因此为了保证顺序是左-&gt;右，因此应该先右后左</span>
        node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="_94-二叉树的中序遍历"><a href="#_94-二叉树的中序遍历" class="header-anchor">#</a> 94. 二叉树的中序遍历</h2> <p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener noreferrer">传送门<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>给定一个二叉树，返回它的中序 遍历。</p> <p>示例:</p> <p>输入: [1, null, 2, 3]</p> <div class="language- extra-class"><pre class="language-text"><code>   1
    \
     2
    /
   3
</code></pre></div><p>输出: [1, 3, 2]</p> <h3 id="方法一-递归法"><a href="#方法一-递归法" class="header-anchor">#</a> 方法一: 递归法</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">inorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">inorderHelper</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 左 -&gt; 根 -&gt; 右</span>
            root<span class="token punctuation">.</span>left <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">inorderHelper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            root<span class="token punctuation">.</span>val <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            root<span class="token punctuation">.</span>right <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">inorderHelper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">inorderHelper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h3 id="方法二：栈迭代法"><a href="#方法二：栈迭代法" class="header-anchor">#</a> 方法二：栈迭代法</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">inorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">||</span> root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 遍历左节点</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 左节点遍历完毕，取值，再遍历右节点</span>
        root <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_145-二叉树的后序遍历"><a href="#_145-二叉树的后序遍历" class="header-anchor">#</a> 145. 二叉树的后序遍历</h2> <p>给定一个二叉树，返回它的 后序 遍历。</p> <p>示例:</p> <p>输入: [1, null, 2, 3]</p> <div class="language- extra-class"><pre class="language-text"><code>   1
    \
     2
    /
   3 
</code></pre></div><p>输出: [3, 2, 1]</p> <h3 id="方法一：-递归法"><a href="#方法一：-递归法" class="header-anchor">#</a> 方法一： 递归法</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">postorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">postorderHelper</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 左 -&gt; 右 -&gt; 中</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token function">postorderHelper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token function">postorderHelper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">postorderHelper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h3 id="方法二：迭代法"><a href="#方法二：迭代法" class="header-anchor">#</a> 方法二：迭代法</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">postorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length <span class="token operator">||</span> root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 左 -&gt; 右 -&gt; 中</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 队列：先进先出</span>
        root <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="_102-二叉树的层序遍历"><a href="#_102-二叉树的层序遍历" class="header-anchor">#</a> 102. 二叉树的层序遍历</h2> <p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[][]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> cur <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>queue <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 从左往右压栈(先入后出)</span>
            <span class="token keyword">const</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> cur<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        queue <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="剑指-offer-32-i-从上到下打印二叉树"><a href="#剑指-offer-32-i-从上到下打印二叉树" class="header-anchor">#</a> 剑指 Offer 32 - I. 从上到下打印二叉树</h2> <p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p> <p>例如:
给定二叉树: [3, 9, 20, null, null, 15, 7],</p> <div class="language- extra-class"><pre class="language-text"><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre></div><p>返回：</p> <p><code>[3,9,20,15,7]</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val; 
 *     this.left = this.right = null; 
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        root <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="剑指-offer-32-ii-从上到下打印二叉树-ii"><a href="#剑指-offer-32-ii-从上到下打印二叉树-ii" class="header-anchor">#</a> 剑指 Offer 32 - II. 从上到下打印二叉树 II</h2> <p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p> <p>例如:
给定二叉树: [3, 9, 20, null, null, 15, 7],</p> <div class="language- extra-class"><pre class="language-text"><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre></div><p>返回其层次遍历结果：</p> <div class="language- extra-class"><pre class="language-text"><code>[
  [3],
  [9,20],
  [15,7]
]
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val; 
 *     this.left = this.right = null; 
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[][]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> curr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 用来保存本轮循环的结果</span>
            temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用来缓存本轮循环后queue的结果</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>queue <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> curr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 更新本轮循环后的queue</span>
        queue <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token comment">// curr(数组)入栈</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="剑指-offer-32-iii-从上到下打印二叉树-iii"><a href="#剑指-offer-32-iii-从上到下打印二叉树-iii" class="header-anchor">#</a> 剑指 Offer 32 - III. 从上到下打印二叉树 III</h2> <p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p> <p>例如:
给定二叉树: [3, 9, 20, null, null, 15, 7],</p> <div class="language- extra-class"><pre class="language-text"><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre></div><p>返回其层次遍历结果：</p> <div class="language- extra-class"><pre class="language-text"><code>[
  [3],
  [20,9],
  [15,7]
]
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val; 
 *     this.left = this.right = null; 
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[][]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> curr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 用来存放每一轮循环后的结果</span>
            temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用来缓存每一轮循环后的队列</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>queue <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> curr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> temp<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> temp<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue <span class="token operator">=</span> temp<span class="token punctuation">;</span> <span class="token comment">// 更新每轮循环后的结果给队列</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每轮循环后的结果入栈</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="剑指-offer-54-二叉搜索树的第k大节点"><a href="#剑指-offer-54-二叉搜索树的第k大节点" class="header-anchor">#</a> 剑指 Offer 54. 二叉搜索树的第k大节点</h2> <p>给定一棵二叉搜索树，请找出其中第k大的节点。</p> <p>示例 1:</p> <div class="language- extra-class"><pre class="language-text"><code>输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
示例 2:
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4
</code></pre></div><h3 id="方法一：栈遍历"><a href="#方法一：栈遍历" class="header-anchor">#</a> 方法一：栈遍历</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val; 
 *     this.left = this.right = null; 
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */</span>

<span class="token keyword">var</span> <span class="token function-variable function">kthLargest</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> arr <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="方法二：中序遍历"><a href="#方法二：中序遍历" class="header-anchor">#</a> 方法二：中序遍历</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">kthLargest</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">inorder</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 左 -&gt; 根 -&gt; 右</span>
            root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            root<span class="token punctuation">.</span>val <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 二叉搜素树中序排列后的结果就是有序的,第K大元素即为倒数res.length - k(索引)项</span>
    <span class="token keyword">return</span> res<span class="token punctuation">[</span>res<span class="token punctuation">.</span>length <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="剑指-offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-offer-33-二叉搜索树的后序遍历序列" class="header-anchor">#</a> 剑指 Offer 33. 二叉搜索树的后序遍历序列</h2> <p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p> <p>参考以下这颗二叉搜索树：</p> <div class="language- extra-class"><pre class="language-text"><code>     5
    / \
   2   6
  / \
 1   3
</code></pre></div><p>示例 1：</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [1,6,3,2,5]
输出: false
</code></pre></div><p>示例 2：</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [1,3,2,6,5]
输出: true
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {number[]} postorder
 * @return {boolean}
 */</span>
<span class="token comment">// 终止条件： 当 i &gt;= j ，说明此子树节点数量 &lt;= 1 ，无需判别正确性，因此直接返回 true ；</span>
<span class="token comment">// 递推工作：</span>
<span class="token comment">// 划分左右子树： 遍历后序遍历的 [i, j][i, j] 区间元素，寻找 第一个大于根节点 的节点，索引记为 mm 。此时，可划分出左子树区间 [i, m-1][i, m−1] 、右子树区间 [m, j - 1][m, j−1] 、根节点索引 jj 。</span>
<span class="token comment">// 判断是否为二叉搜索树：</span>
<span class="token comment">// 左子树区间 [i, m - 1][i, m−1] 内的所有节点都应 &lt; postorder[j] 。而第 1. 划分左右子树 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</span>
<span class="token comment">// 右子树区间 [m, j-1][m, j−1] 内的所有节点都应 &gt; postorder[j] 。实现方式为遍历，当遇到 &lt;= postorder[j] 的节点则跳出；则可通过 p = j判断是否为二叉搜索树。</span>

<span class="token keyword">function</span> <span class="token function">verifyPostorder</span><span class="token punctuation">(</span><span class="token parameter">postorder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">return</span> <span class="token function">traverse</span><span class="token punctuation">(</span>postorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> postorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token parameter">postorder<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// 说明此子树节点数量 &lt;= 1 ，无需判别正确性，因此直接返回 true</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> j<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">// 记录左子树指针</span>
    <span class="token keyword">let</span> leftIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>leftIdx<span class="token punctuation">]</span> <span class="token operator">&lt;</span> postorder<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> leftIdx<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment">// 记录中间节点的指针</span>
    <span class="token keyword">let</span> middleIdx <span class="token operator">=</span> leftIdx<span class="token punctuation">;</span>
    <span class="token comment">// 找出中间节点指针</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>leftIdx<span class="token punctuation">]</span> <span class="token operator">&gt;</span> postorder<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> leftIdx<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> leftIdx <span class="token operator">===</span> j <span class="token operator">&amp;&amp;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>postorder<span class="token punctuation">,</span> i<span class="token punctuation">,</span> middleIdx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">traverse</span><span class="token punctuation">(</span>postorder<span class="token punctuation">,</span> middleIdx<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="剑指-offer-34-二叉树中和为某一值的路径"><a href="#剑指-offer-34-二叉树中和为某一值的路径" class="header-anchor">#</a> 剑指 Offer 34. 二叉树中和为某一值的路径</h2> <p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p> <p>示例:
给定如下二叉树，以及目标和 sum = 22，</p> <div class="language- extra-class"><pre class="language-text"><code>              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
</code></pre></div><p>返回:</p> <div class="language- extra-class"><pre class="language-text"><code>[
   [5,4,11,2],
   [5,8,4,5]
]
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">pathSum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> sum</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> target<span class="token punctuation">,</span> path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 初始化path</span>
        path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 1. 递归终止条件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> target <span class="token operator">===</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 2. 处理当前层逻辑</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 3. 下探到下一层</span>
            <span class="token comment">// 更新target, path浅拷贝</span>
            <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> target <span class="token operator">-</span> node<span class="token punctuation">.</span>val<span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> target <span class="token operator">-</span> node<span class="token punctuation">.</span>val<span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_559-n叉树的最大深度"><a href="#_559-n叉树的最大深度" class="header-anchor">#</a> 559. N叉树的最大深度</h2> <h3 id="_1-深度优先"><a href="#_1-深度优先" class="header-anchor">#</a> 1. 深度优先</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 即递归求出每个子树的最大深度，再加上根节点</span>
<span class="token keyword">var</span> <span class="token function-variable function">maxDepth</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>children <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> childDepth <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 对比之前的最大深度和现在的, 取最大值</span>
        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> childDepth<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 最后需要记得加上根节点</span>
    <span class="token keyword">return</span> max <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_2-广度优先"><a href="#_2-广度优先" class="header-anchor">#</a> 2. 广度优先</h3> <p>给定一个 N 叉树，找到其最大深度。</p> <p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p> <p>例如，给定一个 3叉树 :</p> <p>我们应返回其最大深度，3。</p> <div class="language- extra-class"><pre class="language-text"><code>       1
    /  |  \
   3   2   4
  / \
 5   6
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 算出总共有几层即可</span>
<span class="token keyword">var</span> <span class="token function-variable function">maxDepth</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">,</span>
        level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
        length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>length <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>length<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 队列出队</span>
            <span class="token keyword">const</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                queue <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        level<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> level<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_590-n叉树的后序遍历"><a href="#_590-n叉树的后序遍历" class="header-anchor">#</a> 590. N叉树的后序遍历</h2> <p>给定一个 N 叉树，返回其节点值的后序遍历。</p> <p>例如，给定一个 3叉树 :</p> <div class="language- extra-class"><pre class="language-text"><code>       1
    /  |  \
   3   2   4
  / \
 5   6
</code></pre></div><p>返回其后序遍历: [5, 6, 3, 2, 4, 1].</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {Node} root
 * @return {number[]}
 */</span>
<span class="token comment">// 队列迭代法</span>
<span class="token keyword">var</span> <span class="token function-variable function">postorder</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">,</span>
        queue <span class="token operator">=</span> root<span class="token punctuation">.</span>children<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 队列: 先进先出</span>
        <span class="token keyword">const</span> child <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>val <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 有儿子节点，那就全部放到队列中</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>children <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>child<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_429-n叉树的层序遍历"><a href="#_429-n叉树的层序遍历" class="header-anchor">#</a> 429. N叉树的层序遍历</h2> <p>给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。</p> <p>例如，给定一个 3叉树 :</p> <div class="language- extra-class"><pre class="language-text"><code>       1
    /  |  \
   3   2   4
  / \
 5   6
</code></pre></div><p>返回其层序遍历:</p> <div class="language- extra-class"><pre class="language-text"><code>[
     [1],
     [3,2,4],
     [5,6]
]

</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */</span>

<span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[][]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> cur <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>queue <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 从左往右压栈(先入后出)</span>
            <span class="token keyword">const</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> cur<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>children <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>node<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        queue <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h2 id="最后"><a href="#最后" class="header-anchor">#</a> 最后</h2> <p>文中若有不准确或错误的地方，欢迎指出，有兴趣可以的关注下<a href="https://github.com/GolderBrother" target="_blank" rel="noopener noreferrer">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，一起学习呀~~</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2020/9/7 下午8:45:37</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/views/algorithms/linklist.html" class="prev">链表相关算法题</a></span> <span class="next"><a href="/blog/views/algorithms/tencent/array&amp;string.html">腾讯算法题-数组与字符串</a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.74817549.js" defer></script><script src="/blog/assets/js/2.f761193d.js" defer></script><script src="/blog/assets/js/46.c95ab531.js" defer></script>
  </body>
</html>
