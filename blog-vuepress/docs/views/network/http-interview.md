# HTTP 灵魂之问，巩固你的 HTTP 知识体系

为了帮助大家树立完整的 HTTP 知识体系，并达到一定的深度，从容地应对各种灵魂之问，也同时提升自己作为一个 web 开发的专业素养吧。这是本文的思维导图

![img](https://user-gold-cdn.xitu.io/2020/3/23/17104ea1fdee5669?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 001. HTTP 报文结构是怎样的？

对于 **TCP** 而言，在传输的时候分为两个部分:**TCP 头**和**数据部分**。

而 **HTTP** 类似，也是`header + body`的结构，具体而言:

```txt
起始行 + 头部 + 空行 + 实体
```

由于 http **请求报文**和**响应报文**是有一定区别，因此我们分开介绍。

### 起始行

对于请求报文来说，起始行类似下面这样:

```js
GET /home HTTP/1.1
```

也就是**方法 + 路径 + http 版本**。

对于响应报文来说，起始行一般长这个样:

```js
HTTP/1.1 200 OK

```

响应报文的起始行也叫做**状态行**。由**http 协议版本、状态码和描述**三部分组成。
其中协议版本`HTTP/1.1`或者`HTTP/1.0`，`200`就是它的**状态码**，`OK`则为它的**描述**。

值得注意的是，在起始行中，每两个部分之间用**空格**隔开，最后一个部分后面应该接一个**换行**，严格遵循`ABNF`语法规范。

### 头部

展示一下请求头和响应头在报文中的位置:

![img](https://user-gold-cdn.xitu.io/2020/3/22/170ffd6012e2fc88?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到`http`非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：

- 字段名不区分大小写
- 字段名不允许出现**空格**，不可以出现下划线`_`
- 字段名后面必须紧接着`:`

### 空行

很重要，用来区分开**头部**和**实体**。

问: 如果说在头部中间故意加一个空行会怎么样？

那么空行后的内容全部被视为实体。

### 实体

就是具体的数据了，也就是`body`部分。请求报文对应**请求体**, 响应报文对应**响应体**。

## 002. 如何理解 HTTP 的请求方法？

### 有哪些请求方法？

`http/1.1`规定了以下请求方法(注意，都是**大写**):

- `GET`: 通常用来获取资源
- `HEAD`: 获取资源的元信息
- `POST`: 提交数据，即上传数据
- `PUT`: 修改数据
- `DELETE`: 删除资源(几乎用不到)
- `CONNECT`: 建立连接隧道，用于代理服务器
- `OPTIONS`: 列出可对资源实行的请求方法，用来跨域请求。允许客户端查看服务器的性能
- `TRACE`: 追踪请求-响应的传输路径
- `PATCH`: 是对 PUT 方法的补充，用来对已知资源进行局部更新 。

### GET 和 POST 有什么区别？

首先最直观的是**语义**上的区别。

而后又有这样一些具体的差别:

- 从**缓存**的角度:
  - GET 请求会被浏览器主动缓存下来，留下历史记录，而 `POST` 默认不会。
  - GET 请求参数会被保留在浏览器历史记录里，而 POST 中的参数不会被保留。
- 从**编码**的角度，GET 只能进行 `URL` 编码，只能接收 `ASCII` 字符，而 `POST` 没有限制, 支持多种编码方式。
- 从**参数**的角度
  - GET 一般放在 `URL` 中，因此不安全，`POST` 放在请求体中，更适合传输敏感信息。
  - GET 请求在`URL` 中传送的参数是有长度限制的，而`POST`没有, 实际上是大部分浏览器都会限制`url`长度在`2K`个字节
- 从**幂等性**的角度，GET 是幂等的，而`POST`不是。(幂等表示执行相同的操作，结果也是相同的)
- 从**TCP**的角度，GET 请求会把请求报文一次性发出去，而 `POST` 会分为两个 `TCP` 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 `body` 部分。(火狐浏览器除外，它的 POST 请求只发一个 `TCP` 包)

### 003: 如何理解 URI？

**URI**, 全称为(`Uniform Resource Identifier`), 也就是**统一资源标识符**，它的作用很简单，就是区分**互联网上不同的资源**。

但是，它并不是我们常说的网址, 网址指的是`URL`, 实际上`URI`包含了`URN`和`URL`两个部分，由于 `URL` 过于普及，就默认将 `URI` 视为 `URL` 了。

#### URI 的结构

URI 真正最完整的结构是这样的。

![img](https://user-gold-cdn.xitu.io/2020/3/22/170ffd677629b70d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

我们来一一拆解分析这个结构

`scheme` 表示**协议名**，比如`http, https, file, rtsp, rtmp`等等。后面必须和`://`连在一起。

`user:passwd@` 表示登录主机时的**用户信息**，不过很不安全，不推荐使用，也不常用。

`host:port`表示**主机名**和**端口**。

`path`表示**请求路径**，标记资源所在位置。

`query`表示**查询参数**，为`key=va`l 这种形式，多个键值对之间用`&`隔开。比如 `wd=http&rsv_spt=1&rsv_iqid=0xe4c8526f0004bf6d&issp=1&f=8&rsv_bp=1&rsv_idx=2`

`fragment`表示 `URI` 所定位的资源内的一个**锚点**，浏览器可以根据这个**锚点**跳转到对应的位置。

举个栗子:

```js
https://www.baidu.com/s?wd=http&rsv_spt=1&rsv_iqid=0xe4c8526f0004bf6d&issp=1&f=8&rsv_bp=1&rsv_idx=2
```

上面这个 `URI` 中，`https`即`scheme`(**协议**)部分，`www.baidu.com`为`host:port`(**主机名:端口**)部分（注意，`http` 和 `https` 的默认端口分别为`80、443`），`/s`为`path`(**请求路径**)部分，而`wd=http&rsv_spt=1&rsv_iqid=0xe4c8526f0004bf6d&issp=1&f=8&rsv_bp=1&rsv_idx=2`就是`query`(**查询参数**)部分。

### URI 编码

`URI` 只能使用`ASCII`, `ASCII` 之外的字符是不支持显示的，而且还有一部分符号是**界定符**，如果不加以处理就会导致解析出错。

因此，`URI` 引入了**编码**机制，将所有非 `ASCII` 码字符和**界定符**转为**十六进制字节值**，然后在前面加个`%`。

如，**空格**被转义成了`%20`，**神哥**被转义成了`%E7%A5%9E%E5%93%A5`。

可以直接使用`encodeURI`或者`encodeURIComponent`方法对**整个 URI**或者**URI 中的某一段**进行**编码**

我们来看下面的栗子：

```js
const uri = 'https://www.baidu.com/s?wd=http&rsv_spt=1&rsv_iqid=0xdca1d90b00033d32 ';

console.log(encodeURI(uri)); // https://www.baidu.com/s?wd=http&rsv_spt=1&rsv_iqid=0xdca1d90b00033d32%20
console.log(encodeURIComponent(uri)); // https%3A%2F%2Fwww.baidu.com%2Fs%3Fwd%3Dhttp%26rsv_spt%3D1%26rsv_iqid%3D0xdca1d90b00033d32%20
```

`encodeURI`和`encodeURIComponent`的区别

- `encodeURI()`不会对本身属于`URI`的特殊字符进行编码，例如`冒号、正斜杠、问号和井字号`；而`encodeURIComponent()`则会对它发现的**任何非标准字符**进行编码
- 使用`encodeURI()`编码后的结果是**除了空格之外的其他字符**都原封不动，只有空格被替换成了**%20**。而`encodeURIComponent()`方法则会使用对应的编码替换**所有非字母数字字符**

这也正是可以对整个`URI`使用`encodeURI()`，而只能对附加在现有 URI 后面的字符串使用`encodeURIComponent()`的原因所在。一般来说,我们使用`encodeURIComponent()`方法的时候要比使用`encodeURI()`更多,因为在实践中更常见的是对查询字符串参数而不是对基础 URL 进行编码.
经我的观测，很多网站的`cookie`在进行编码的时候，是`encodeURIComponent`格式的，所以应该使用`decodeURIComponent`进行解码

## 004: 如何理解 HTTP 状态码？

`RFC` 规定 `HTTP` 的状态码为**三位数**，被分为五类:

- 1xx: 表示目前是协议处理的**中间状态**，还**需要后续**操作。
- 2xx: 表示**请求成功**状态。
- 3xx: **重定向**状态，资源位置发生变动，需要重新请求。
- 4xx: **请求报文有误**。
- 5xx: **服务器端发生错误**。

接下来我们就一一分析这里面具体的状态码。

### 1xx

**101 Switching Protocols**。切换到新的 HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。比如在`HTTP`升级为`WebSocket`的时候，如果服务器同意变更，就会发送状态码 101。

### 2xx

**200 OK** 是见得最多的成功状态码。通常在响应体中放有数据。

**204 No Content**: 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息, 含义与 `200` 相同，但响应头后没有 **body** 数据。

**206 Partial Content**: 顾名思义，表示部分内容，它的使用场景为 **HTTP 分块下载**和**断点续传**，当然也会带上相应的响应头字段`Content-Range`。

### 3xx

**301 Moved Permanently**: 被请求的资源已永久移动到新位置，即**永久重定向**，对应着`302 Found`，即**临时重定向**。

比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回 301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。
而如果只是暂时不可用，那么直接返回 302 即可，和 301 不同的是，浏览器并不会做缓存优化。

**304 Not Modified**: 当协商缓存命中时会返回这个状态码。详见[浏览器缓存一探究竟~](https://golderbrother.github.io/blog/views/fe-interview/browser-cache.html)

### 4xx

**400 Bad Request**: **语义有误**或者**请求参数有误**, 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。

**401 Unauthorized**: 当前请求**需要用户验证**, 表示发送的请求需要有通过 **HTTP 认证**的认证信息

**403 Forbidden**: 服务器已经理解请求，但是拒绝执行它, 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。

**404 Not Found**: 资源未找到，表示没在服务器上找到相应的资源。

**405 Method Not Allowed**: 请求行中指定的请求方法不能被用于请求相应的资源，请求方法不被服务器端允许。

**406 Not Acceptable**: 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，资源无法满足客户端的条件。

**408 Request Timeout**: 客户端请求超时，服务器等待了太长时间。

**409 Conflict**: 由于和被请求的资源的当前状态之间存在冲突，请求无法完成，相当于多个请求发生了冲突。

**413 Request Entity Too Large**: 请求体的数据过大, 服务器拒绝处理当前请求。

**414 Request-URI Too Long**: 请求行里的 `URI` 太大，长度超过了服务器能够解释的长度。

**429 Too Many Request**: 客户端发送的请求过多。

**431 Request Header Fields Too Large**：请求头的字段内容太大。

### 5xx

**500 Internal Server Error**: 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现，但是出了啥错咱也不知道。

**501 Not Implemented**: 表示客户端请求的功能服务器还不支持。

**502 Bad Gateway**: 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应，服务器自身是正常的，但访问的时候出错了。

**503 Service Unavailable**: 由于临时的服务器维护或者过载，服务器当前无法处理请求。表示服务器当前很忙，暂时无法响应服务。

## 005: 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？

HTTP 特点
HTTP 的特点概括如下:

1. 灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。

2. 可靠传输。`HTTP` 基于 `TCP/IP`，因此把这一特性继承了下来。这属于 `TCP` 的特性，不具体介绍了。

3. 请求-应答。也就是**一发一收、有来有回**， 当然这个请求方和应答方不单单指**客户端**和**服务器**之间，如果某台服务器作为**代理**来**连接后端**的服务端，那么这台服务器也会扮演**请求方**的角色。

4. 无状态。这里的状态是指**通信过程的上下文信息**，而每次 `http` 请求都是**独立、无关**的，默认不需要保留状态信息。

### HTTP 缺点

#### 无状态

所谓的优点和缺点还是要分场景来看的，对于 `HTTP` 而言，最具争议的地方在于它的**无状态**。

在需要**长连接**的场景中，需要保存大量的**上下文信息**，以免传输大量重复的信息，那么这时候**无状态**就是 `http` 的缺点了。

但与此同时，另外一些应用仅仅只是为了获取一些数据，**不需要保存连接上下文信息**，**无状态**反而减少了网络开销，成为了 `http` 的优点。

#### 明文传输

即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。

这当然对于调试提供了便利，但同时也让 `HTTP` 的报文信息暴露给了外界，给攻击者也提供了便利。`WIFI陷阱`就是利用 `HTTP` **明文传输**的缺点，诱导你连上热点，然后**疯狂抓你所有的流量**，从而拿到你的敏感信息。

#### 队头阻塞问题

当 `http` 开启**长连接**时，共用一个 `TCP` 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的**队头阻塞**问题。接下来会有一小节讨论这个问题。

## 006: 对 Accept 系列字段了解多少？

对于Accept系列字段的介绍分为四个部分: **数据格式、压缩方式、支持语言和字符集**。

### 数据格式

上一节谈到 HTTP 灵活的特性，它支持非常多的数据格式，那么这么多格式的数据一起到达客户端，客户端怎么知道它的格式呢？

当然，最低效的方式是直接猜，有没有更好的方式呢？直接指定可以吗？

答案是肯定的。不过首先需要介绍一个标准——**MIME**(Multipurpose Internet Mail Extensions, **多用途互联网邮件扩展**)。它首先用在电子邮件系统中，让邮件可以发任意类型的数据，这对于 `HTTP` 来说也是通用的。

具体而言，这两个字段的取值可以分为下面几类:

- text：`text/html, text/plain, text/css` 等
- image: `image/gif, image/jpeg, image/png` 等
- audio/video: `audio/mpeg, video/mp4` 等
- application: `application/json(最常用), application/javascript, application/pdf, application/octet-stream`

### 压缩方式

当然一般这些数据都是会进行编码压缩的，采取什么样的压缩方式就体现在了发送方的`Content-Encoding`字段上， 同样的，接收什么样的压缩方式体现在了接受方的`Accept-Encoding`字段上。这个字段的取值有下面几种：

- `gzip`: 当今最流行的压缩格式
- `deflate`: 另外一种著名的压缩格式
- `br`: 一种专门为 `HTTP` 发明的压缩算法

比如：

```js
// 发送端
Content-Encoding: gzip
// 接收端
Accept-Encoding: gizp
```

### 支持语言

对于发送方而言，还有一个 `Content-Language` 字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为 `Accept-Language`。如:

```js
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7,zh-TW;q=0.6,ko;q=0.5
```

```js
// 发送端
Content-Language: zh-CN, zh, en
// 接收端
Accept-Language: zh-CN, zh, en

```

### 字符集

最后是一个比较特殊的字段, 在接收端对应为`Accept-Charset`，指定可以接受的字符集，而在发送端并没有对应的`Content-Charset`, 而是直接放在了`Content-Type`中，以`charset`属性指定。如:

```js
// 发送端
Content-Type: application/json; charset=utf-8
// 接收端
Accept-Charset: charset=utf-8

```

最后以一张图来总结一下吧:

![img](https://user-gold-cdn.xitu.io/2020/3/22/170ffd6bb6d09c2d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 参考资料

- [encodeURI()和 encodeURIComponent() 区别](https://blog.csdn.net/qq_34629352/article/details/78959707)

 
 <comment/> 
 